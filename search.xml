<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[在 PingCAP（北京）实习的日子]]></title>
    <url>%2F2a9774a3.html</url>
    <content type="text"><![CDATA[候选者 我是 1 月 9 日入职 PingCAP 的——作为 TiDB 组实习生。 已经记不清具体什么时候几面了…… 听说 PingCAP 第一次听说 PingCAP，是在■■的谷歌内推群里的听■■■说的，当时是说：“各位群聚内推 Google 失败了不要灰心，来了解了解 PingCAP 鸭！” 于是我问了之前帮我内推其他很多公司的■■■："你听说过 PingCAP 吗？""国内很牛逼的公司，你这简历估计肯定会被挂，别想了。“ ■■■不知道的是，那时候我其实是“先斩后奏”，简历已经投递出去了。 面试前 很好评的是，面试前会有 HR 小姐姐打电话过来给你介绍公司基本情况，介绍各个组的主要工作，让你去自己选择去哪里。整个公司文化都很像这样，很在乎每个人发展，在乎每个人兴趣。每个人做的都是有趣的事情。 笔试 漫长的等待了两个星期，终于简历被捞了…… 先是别开生面的一场笔试题，对我的题目是要求一周，在 Github 上写（不亏是开源社区）。 题目本身很有意思，之前在其他公司面试的时候也被问到类似的问题，但是这是第一次让我实现出来，所以非常开心地就开搞了。 那时候还在准备其他公司的面试，而且当时挂了很多了，心态不是很好，做的时候比较急躁。在最后提交上去的时候，感觉还有很多地方可以优化和调整。所以感觉这次凉定了…… 幸运的是，笔试通过了。不知道是因为笔试主要在考察工程能力还是因为只是第一面，会放过的多一些？（作为 Github 装逼用户，CI，badges 这些用的还是很溜的）。（之后看到其他人的笔试，写的真是十分仰慕了）。 一面 一面面试官■■■，刚加微信的时候觉得是个大神，来了公司之后觉得是个二次元技术宅，来了公司一段时间后觉得是个二次元技术大神。 简单问了问三四道算法，在网站中在线撕代码，难度不是很难。不知道是一面还是因为我的组的缘故，我感觉公司对算法题的考察，略低于同实力的其他公司。（不过那几个对算法要求恐怖的组不知道是不知也是这样）。 这时候心态还是比较轻松的，因为觉得自己肯定过不去。 幸运的是，笔试通过了。 二面 二面是我的 mentor ■■，超级好也超级厉害的一个人，对我教了很多东西，影响很大。教了我什么是技，什么是道，对我之后的学习、工作提了很多有用的建议。 二面之后，心态认真了很多。因为自己算法一直是弱项（丢 ACMer 这个名声了），算法既然过了，后面的一些不考察算法的话，我对计算机基础还是有信心的。 结果二面一开口就把我问懵了…… “你知不知道 x86 字节对齐？你知不知道 CPU 流水线？如何避免分支预测失误的开销……” 看来自己对基础的信心拯救不了我啊，sigh…… “那你知不知道哈希？” 我知道我知道！嘿嘿，我准备了很久面试，哈希这么常考的我怎么会不会？不就是——“再哈希、拉链法、线性探测法等那几个课本上的嘛？我不光知道，我还知道装载因子还知道……“ “那你知不知道分布式哈希？一致性哈希？” 啥？这我没听过啊，课本没有啊…… 这次的面试，也让我知道了我的很多不足，潜下心去补了很多知识。 三面 三面是老大 ■■，很温和很有魅力的一个人，对人总是很好，很在乎每一个人的发展…… 三面是把我榨干的一面，问了很多我不太熟悉的分布式知识，以限流算法为引子聊了很多。 因为对分布式基本没接触过，所以只能凭我微薄的算法知识去猜测应该是怎么样怎么样。 然后每次得出一个似是而非的，看起来可以工作的算法，又会被 ■■ 的各种 corner case 击败6 三面面试官懂得非常多，而且技术上各种刁钻细节了如指掌。 被面完感觉自己是条榨干了的咸鱼了…… 很幸运，三面也通过了，就这样，踏上了正式入职 PingCAP 的航班。 面试总结 面试整体体验非常非常非常棒。 之所以这么说，是因为每次面试之后的：“你有什么向我问的吗？“这个环节。这个环节面试官真的是在推心置腹和你说他的看法和宝贵经验。在这个过程中我学到了不少东西，有很多知识点豁然开朗……就算只走一次面试流程，我感觉也不虚此行了。 很多人问我面试会问什么？我感觉这个因人而异吧，面试难度其实不高——PingCAP 使用 Golang，Rust 开发兼容 MySQL 的数据库。我入职之前，不会 Golang,不会 Rust，不会 SQL 语句。这么说来要求确实不高叭？ 不过我感觉公司面试难度也不低，刚刚入职的时候，觉得公司挺在乎候选者的性格、责任心、自我驱动力和对技术的热爱的。 整体而言，PingCAP 面试还是很硬核的，感觉比不少大厂难。 面试的时候，我感觉我会的所有东西都被问到了，问的都很深入，让我感觉很舒适（有一种，就算挂了也很知足，毕竟我展现出了风采）。 而面某大厂，经常是：“我还没用力，面试官怎么就觉得回答的够了。” 实习 我主要在公司负责给团队拖后腿…… 入职的时候，会和老大 ■■ 吃饭，吃饭的时候问了之前的问题：“我这简历我以为会被挂呢……” ■■ 表示：“我们基本不筛简历的。”（所以应届生小伙伴快投啦）。 记得刚来的时候，还挺害怕自己不能胜任工作的，因为大家都很强！ 后来想想：“如果不能胜任工作，不仅仅是我一个人的错，也说明公司的面试流程可能有点问题嘛！” 于是释然…… 体验 体验满分，因为是开源公司，所以很多资料可以放肆学习，整个偌大的社区任我交流学习。 mentor，同事都很关照人，会主动询问你困难，邀请你一起吃饭。 在这里每个人都很关心我的成长和学习，会经常询问我是否遇到困难，亦或是询问我在这里是否学到东西，有什么想学的东西。 这个体验，还不满分嘛？ 很喜欢这里，感觉每个人都很可爱，也很热爱技术，大家都可以讨论自己感兴趣的技术。 而且感觉很尊重每个人，很照顾每个人的感受（吐槽某大厂面试，打了 6 个电话，只有 1 个提前预约了时间，其他 5 个都是突然袭击，其中 2 个还是 21 点以后打来……感觉体验就不是很好了）。 任务 做的具体的任务，可以看我的 Github，毕竟是开源社区。 在这里比较爽的是，没有人把我当实习生看待，给的活都是硬核的适合我的活。我可以随意就技术上的问题和人争论，也可以随意解决我擅长的问题。 记得有一次差点搞坏了，mentor 还说让我随意整，只有随意整，才能学到东西。 待遇 工作时间上真的很弹性，有一位后来入职的伙伴还觉得公司上班时间好晚…… 是真正的弹性工作，随意来，随意走，蛮爽的。（毕竟支持 remote 的公司，怎么可能不支持弹性工作嘛！） 公司有很多人文关怀，不会因实习生而不同。一起参加年会，过节小礼，年岁红包、抽奖，并不会因你是实习生而不同。 具体待遇，真的很爽，不过就不在这里说啦。 对我的帮助 开源社区 开源社区，对个人帮助很大，Github 上闪闪发光，走到哪里都是履历上靓丽的一笔。 做事 能做的很多，可以随便搞，不会有权限控制你，让你做一些简单重复性劳动。 关注个人提升 无论是 ■■ 还是 ■■，都十分关注个人的提升和成长。 活动多 公司内部有很多讲座活动： meetup paper reading（这个 Bilibili 可以看哦~） 内部培训 …… ​ 指路 无论是 ■■ 还是 ■■ ， 在我将要短暂离开的时候，都和我谈了很多心里话，带给我很多启发和思考。推心置腹地告诉我了我很多他们多年开发的经验。并且站在我的角度替我考虑了很多，为我之后规划提供了很多建议。 可能的缺点 说了这么多，公司其实还是有一些可以提升的空间的。（毕竟我不是托……） 对我来说： 公司内部的文档、资料等，会有一些重复的情况……比如第一版在 ■■ 里，第二版又在 ■■ 里。 有时候资料分类不是很恰当，比如需要 ■■ 需要在 ■■ 找，需要 ■■，可能又在 ■■ 里…… 自带电脑……对于我这种 windows 开虚拟机 linux 开发的……经常会 OOM 或者死机，比较难过了……对正式员工会有报销电脑的政策，实习生在这点上使用起来不太方便……（穷苦大学生的渣渣电脑）。 问题 我是带着问题来实习的，自然也要解决问题。 带着问题来实习，感觉对自己帮助也会很大。 大型软件如何开发？ 之前只会做做 ACM，学学基础知识的样子，一直害怕自己不适合做真正的开发。 来了这里之后得益于优秀的新人辅导计划，很快上手工作。 发现工作比自己想象中可能还要简单一些。因为工作有些时候是修改别人的内容，这时对语言语法掌握不精通，也可以现场看和查。所以在这一块倒是没有太大压力（也可能是 Go 语法太简单了？）。 也算理解了为什么之前有人说一门新语言不到一周就可以上手——因为实际开发中很少用到很多的语法糖，毕竟不是每个人都系统学过 XX 语言嘛。 大型软件开发起来，其实对于一个具体的需求，关注点没有想象中那么多。毕竟对于某个功能，运行的代码可能只有很少一部分。比如你去解决 show table 语句，显然就不需要关注其他 DDL，DML 语句的代码嘛。 什么是核心竞争力？ 在这里一直在观察，自己和从业多年的开发人员的最大的差距在哪里？ ■■ 在这里教了我许多，告诉了我什么是计算机的道，什么是计算机的术。 也让我重视了之前一直不重视，觉得像个文科的软件工程…… 并且推荐了我一本书： Clean Code。 说是帮助很大，会找到自己的道…… 因为还没有拜读，所以就先说这么多啦。 2019 年 4 月 12 日星期五于北京西开往西安北 G87 次车厢]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>实习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈哈希]]></title>
    <url>%2F819591f7.html</url>
    <content type="text"><![CDATA[大家熟悉的哈希qwq 哈希 哈希在我的理解里就是，一一对应！ 比如我们把某个字符串A，对应为某个数字x鸭，某个字符串B，对应为某个数字y鸭；把某个图片对应为某个数字鸭，之类der…… 根据这个特性， 理想的哈希应该能满足一些很重要的特性： 对应是不变的，如A不管什么时间什么地点，永远对应的是x； 对应是不冲突的，如只有A可以对应x，其他字符串不能对应到x； 第一个特性很好得到，只要我们的哈希函数确定，显然无论什么时候，只要哈希函数不变，就会一直对应。 但是第二个特性就不那么好做到了，只能存在于理想中了…… 哈希冲突 我们把不同的字符串，对应到了同一个位置/数字，称之为哈希冲突。 对应哈希冲突，有一些常见的解决方法。 (我个人认为，发生哈希冲突时，首先要着眼的是哈希函数的设计，如果哈希函数设计不当，哈希甚至会退化成线性表(画面太美，不敢看)) 教科书中的解决方案 我们首先把问题简化一下，看做是将某个数据哈希到array[hashcode]中，换句话说，就是拿数组下标当哈希值，里面存放对应的内容。 线性探测法 对于哈希冲突，比如A和B，我们将array[hash(A)] = A。此时放入B，但是hash(A) == hash(B)。 这种情况下，我们不断的去寻找，空着的位置在哪里…… 因为这里array[hash(B)(也就是hash(A))已经有人住了，所以我们就在这个数组下标中一个一个往后寻找，直到找到一个空位，安插进去，就是B所在的位置啦。 这样做很多缺点： 有集聚效应，当发生冲突后，因为占用了别人的位置(那个位置可能是hash(C)的位置阿喂！)，所以之后可能会很频繁的发生冲突。 难以删除，因为很可能一串都是同一个哈希数的家，所以中间删除一个以后，后面的可能会难以查找了。因此只能对删除的元素打标记，但是这样又可能导致空间浪费…… 为了解决这些问题，也有一些方案。比如发生冲突时，我们不再是一个一个向后寻找，而是隔几个向后寻找……或是对不同的hash值，跳跃的个数不同……以此来避免上述的一些问题。 再哈希法 顾名思义，发生冲突后，对该元素使用另一个哈希函数，再一次哈希以确定应该放置的位置。 拉链法 对于每一个数组位置，放置的元素相当于一个链表。 当有冲突时，我们将这个元素插入到链表尾部，以此来避免冲突。 哈希中的装载因子 哈希中，我们的数组有多少个，相当于我们有多少个bucket，装载因子是:总键值对数/箱子个数 ，它体现了哈希表的【满】的程度。 该数值越大，意味着哈希表越满，越容易导致冲突，性能也就越低。 大多哈希的实现，当装载因子达到0.75以上后，一般就会自动扩容。 哈希扩容中，一般会创建两倍大小的bucket，再将之前所有的数据，进行再次哈希，装载到新箱子中。 这里容易成为性能瓶颈，一方面，可能某个用户一来，恰好进行了扩容操作，那么对于该用户来说，是不公平的(为什么我等待时间这么长5555)；另一方面，所有哈希值可能都没用，也太弟弟了！ 在这里有一个结论： 扩容扩两倍，原有的哈希值发生变动的可能和情况最少！ 一致性哈希 为了避免可能的再次哈希情况，引入了一致性哈希。 一致性哈希也经常用于分布式实现中。 我们把哈希值唯一确定，之后映射到一个圆环中。 那么，当分布式出现崩溃或新增节点的情况时，只会影响圆环中的一部分。 这样可能会出现没有考虑到不同节点的性能不同的问题，或者负载不够均衡的问题。 我们可以进一步引入虚拟节点，再把多个虚拟节点向实际节点映射，完事~。 (感觉计算机很多方面的问题，都可以通过引入抽象层解决) 参考资料 分布式哈希算法 深入理解哈希表 DHT分布式哈希表]]></content>
      <categories>
        <category>工程</category>
      </categories>
      <tags>
        <tag>优化</tag>
        <tag>工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈利用分支预测提高效率]]></title>
    <url>%2Feb3f5378.html</url>
    <content type="text"><![CDATA[分支预测与流水线 现代CPU会使用大量的流水线，并配合分支预测进行运行效率的提升。 分支预测即就是通过对程序if else等条件分支进行预测，并提前执行相关代码。如果预测正确，显然会提升效率，如果预测失败，那么将不得不清空流水线，重新来过，此时便会影响效率。 目前市面上主流CPU的分支预测，正确率可以达到90%以上。 避免分支预测开销 编译器会进行一定的优化，主要是将条件分支语句转化为条件传送语句。 优化前： 1234if( a &gt; b ) return a - b ;else return b - a; 优化后: 1return a &gt; b ? a - b : b - a ; 这两种写法的区别在于，第二种写法，在编译器优化情况下，会被转化成条件传送语句comvl，CPU可以不需要预测就继续执行下去。效率因此得到提高。 那么，作为程序员都有哪些方法去写更优雅的代码，提升效率呢？ 合并条件 主要是通过优化，尽可能减少分支预测失败时对效率的影响。 优化前: 123if(case1) if( case2 ) do(); 优化后: 12if( case1 &amp;&amp; case2 ) do(); 优化前: 12if( case1 == 0 &amp;&amp; case2 == 0 &amp;&amp; case3 == 0 ) do(); 优化后: 12if( ( case1 | case2 | case3 ) == 0 ) do(); 提前进行分支预测 主要通过提前进行分支预测，避免在循环中大量的预测错误，导致开销。 优化前： 12345for( int i = 0 ; i &lt; n ; i++) if( case1 ) do1(); else do2(); 优化后: 12345678if( case1 ) flag = 1 ;if( flag ) for( int i = 0 ; i &lt; n ; i++ ) do1();else for( int i = 0 ; i &lt; n ; i++ ) do2(); 跳转取消分支预测 如将if else改写switch(switch使用跳转指令，直接跳转到对应分支) 将多个函数使用函数指针，直接进行调用等。 位运算取消预测 如对于if(color &lt; 0 ) color = 0，可改成color &amp;=~(color &gt;&gt; 31 ) 参考资料 浅谈分支预测、流水线与条件转移 Why is it faster to process a sorted array than an unsorted array? 如何编写C++以减少CPU分支预测错误？]]></content>
      <categories>
        <category>工程</category>
      </categories>
      <tags>
        <tag>优化</tag>
        <tag>工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode761 Special Binary String]]></title>
    <url>%2F958a9135.html</url>
    <content type="text"><![CDATA[leetcode761 Special Binary String 题目连接 https://leetcode.com/problems/special-binary-string/description/ 题目大意 定义Special Binary String: 1和0的数量一定相等 所有以1开始的前缀一定是1的数量大于等于0的数量。 现在给出一个Special Binary String,可以任意交换满足Special Binary String的子串，求满足条件的Special Binary String字典序最大的串。 做法 题目很费解……看了好久才看懂…… 当时刚看到这道题的时候，有点一头雾水无从下手。想着这里要交换交换，还是要统计统计所有的前缀情况……？ 看了一下别人的题解，发现思路挺清晰的。把这个串的定义运用到了极致。 对于每个Special Binary String，递归进去处理他们的子串。 让每个Special Binary String子串，进行排序，按照字典序最大的方法去加和他们。 那么原串Special Bianry String一定是字典序最大的。 只要这样递归操作下去即可。 这个方法一开始想了好久，觉得对于100、110，这种情况，好像处理有问题——回过头来看看这个题目的意思和定义，就秒懂了。。 代码 ACcode12345678910111213141516171819202122232425262728293031323334353637383940/********************************************************** * Author : xie keyi * Email : xiekeyi98@snnu.edu.cn * Last modified : 2018-12-13 15:04 * Filename : 761SpecialBinaryString.cpp * Description : * *******************************************************/class Solution &#123;public: string makeLargestSpecial(string S) &#123; auto &amp;s = S; int flag = 0 ; vector&lt;string&gt; t; string res; int pre = 0 ; for( int i = 0 ; i &lt; s.size() ; i++) &#123; flag += (s[i] == '1' ) ? 1 : -1; // 当前串是个符合条件的串 // 递归下去 if( flag == 0 ) &#123; // 符合条件的串开头和结尾一定是1和0 // 里面的串也要进行整理和排序 t.push_back( "1" + makeLargestSpecial( s.substr(pre + 1 , i - pre - 1) ) + "0" ); pre = i + 1; &#125; &#125; // 对所有符合条件的串，排序，进行交换和重组 // 使字典序最大 sort( t.begin() , t.end() , greater&lt;string&gt;() ); for( auto i : t ) res += i ; return res; &#125;&#125;;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 1084C - The Fair Nut and String]]></title>
    <url>%2F6b764ba.html</url>
    <content type="text"><![CDATA[Codeforces 1084C - The Fair Nut and String 题目连接 Codeforces 1084C - The Fair Nut and String 题目大意 给出一个字符串，查找有多少个被b隔开的a的子串。如a、aba,abba,abbbba等都是合法的，但aa是非法的。 但要注意的是aba,abba,abbbbbba等在统计的过程中只计算一个。 做法 开始思路(错误) 一开始读错题了，想着前缀和统计出来a的个数，对于遇到一串b，答案就加上:这串b前面的a个个数乘这串b后面的a的个数。 然后再加上所有a的个数(考虑单独的a)。 这样的做法WA在了第十组测试用例上。 考虑到我这种做法只能解决单独的a和abba等这种情况，难以解决如ababa这种情况，于是gg。 AC思路 首先很显然，删除除了a和b以外的字符(对于一开始的错误做法，删不删没啥影响)。 之后我们统计被b隔开的a的情况，存到一个数组中。 如abbaaabaa，存到数组中变成[1,3,2]的形式。 这样我们就可以把abbaaabaa的情况简化成ababa的情况。 接下来我们考虑ababa的情况: 初始化ans = 0 对于第一个a，答案是1(自身), ans = 1 对于b跳过(下同) 考虑前两个a,答案是1(自身) + 1(加上前面对应的1), ans = 2; 对于前三个a，答案是1(自身) + 2(加上前面对应的两个2) , ans = 3; 最终答案是3个，分别是[1],[3],[5],[1,3],[1,3],[1,5]。 很显然的容易发现ans = lastans + 1 但是考虑到，我们之前把很多a压缩成了1个(即把abbaaabaa变成了ababa)，在这里把b缩成一个是没有影响的。 但是对于a却影响了答案，如何解决这个问题呢？ 观察到每个a其实都是找之前被b隔开的a,而两个b之间夹着的一串a之间是互相不影响的。 那么我们其实只要乘上这个一串a的个数就好了。即对于abbaaabaa: 初始化ans = 0 对于第一个a，答案是1(自身), ans = 1 对于b跳过(下同) 考虑第二串a的第一个a,答案是1(自身) + 1(加上第一串的一个a), ans = 2; 考虑第二串a的第二个a,答案是1(自身) + 1(加上第一串的一个a), ans = 3; 考虑第二串a的第三个a,答案是1(自身) + 1(加上第一串的一个a), ans = 4; ………… 即就是1(自身) + 1(之前对应的第一串的一个a) * 3(这一串a的个数) ) 很显然的容易发现ans = ( lastans + 1 ) * 这一串a的个数 到这里，答案也就呼之欲出了(也可能是叽里呱啦一堆，语无伦次让人一头雾水2333)。 具体看代码吧。 官方题解思路 官方题解的思路是，对于每一串a看成一个集合，如abaaabbaaaa，就可以看做是有三个集合，三个集合的元素个数分别为[1,3,4] 那么答案可以看做是从每一个集合中可以选取0到任意个。 所以答案就是所有集合元素个数+1再相乘，即245个。 考虑到会有一种是全零的情况(即一个都没有选)，所以他最终答案再减去1。 这种思路可能更好理解一点？ 代码 ACcode12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/********************************************************** * Author : xie keyi * Email : xiekeyi98@snnu.edu.cn * Last modified : 2018-12-11 13:18 * Filename : 1084c.cpp * Description : * *******************************************************/#include&lt;bits/stdc++.h&gt;using namespace std ;using ll = long long ; const int MOD = 1000000000 + 7 ; int main()&#123; string s ; cin &gt;&gt; s ; // 删取除了a和b以外的其他字符 for( auto i = s.begin() ; i != s.end() ; ) &#123; if( *i &gt; 'b' ) s.erase(i); else i++; &#125; int n = s.size(); // 开头插入一个'b'，不影响答案，但方便了从1开始计数 // 而且对于之后统计连续的a的个数也好进行统计 s.insert(s.begin(),'b'); vector&lt;int&gt; cnt; // cnt里面存的就是被b隔开的每一串a的个数 for( int i = 1 ; i &lt;= n ; i++) &#123; if( s[i] == 'a' ) &#123; if( s[i-1] == 'b' ) cnt.push_back(1); else (*(cnt.rbegin()))++; &#125; &#125; ll ans = 0; // 计算答案 // ans = ( lastans + 1 ) * 这一串a的个数。 // 因为cnt[i]里存的不同元素，一定是被b隔开的情况 // 所以只要考虑cnt数组就可以了 for( int i = 0 ; i &lt; cnt.size() ; i++) &#123; ans += ( ans + 1 ) * cnt[i] ; ans %= MOD ; &#125; cout &lt;&lt; ans &lt;&lt; endl ; &#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode146与895]]></title>
    <url>%2Ff19909a4.html</url>
    <content type="text"><![CDATA[Leetcode 146 LRU Cache 题目连接 LRU Cache 题目大意 实现一个数据结构，以充当LRU缓存。 两种操作: 1. get(x): 查询key为x是否存在缓存中，如果存在，返回x所对应的value，否则返回-1. 2. put(key,value): 删除原有的key-value对，插入新的key-value对。如果LRU容量满了，删除最远的被访问到的元素。 做法 一开始的想法是，通过对某个元素访问get过就加1，然后满了删除最小的，用set之类的维护。 但是一方面这个不是LRU(如果访问1 1 1 1 1 2,来了个3,那么1就要被删，然而我删的是2)，另一方面，要求O(1)维护，这个怎么也是O(logn)了。 之后很容易考虑到的想法就是一个数组，对于每个元素访问过放到队头，删除删掉队尾的元素。 这样是正解，但是如何维护呢？ 一开始考虑用数组，这样每次维护显然最坏一次操作就是O(n)了(因为要整理数组)。 使用链表的话，对于get函数，也要最坏O(n)。 这时候发现很巧妙的一个地方就是，只要我们把链表的每个地址(迭代器)用hash记录下来不就好了，这样查找就是O(1)了，放到队首也是O(1)(链表交换O(1))。 于是就有了正解。 代码 ACcode123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/********************************************************** * Author : xie keyi * Email : xiekeyi98@snnu.edu.cn * Last modified : 2018-12-04 00:25 * Filename : 146LRUCACHE.cpp * Description : * *******************************************************/class LRUCache &#123;public: LRUCache(int capacity) &#123; this-&gt;capacity = capacity; l.clear(); mp.clear(); &#125; int get(int key) &#123; auto it = mp.find( key ); if( it == mp.end() ) return -1; else &#123; // 元素放到队首 l.push_front( make_pair( it-&gt;second-&gt;first , it-&gt;second-&gt;second ) ); // 删除原来的元素 l.erase(it-&gt;second); // 记录新的位置 mp[key] = l.begin(); return (l.begin())-&gt;second; &#125; &#125; void put(int key, int value) &#123; auto it = mp.find(key); if( it != mp.end() ) l.erase(it-&gt;second); // 如果原来有，删除原来的元素 // 插入新元素 l.push_front( make_pair( key , value ) ); mp[key] = l.begin(); ; // 大于容量了，删除队尾 if( l.size() &gt; capacity ) &#123; mp.erase( l.rbegin()-&gt;first ); l.pop_back(); &#125; &#125;private: int capacity = -1; list&lt; pair&lt;int,int&gt; &gt; l; // key,value unordered_map&lt; int , list&lt; pair&lt;int,int&gt; &gt;:: iterator &gt; mp; // 记录list位置&#125;;/** * Your LRUCache object will be instantiated and called as such: * LRUCache obj = new LRUCache(capacity); * int param_1 = obj.get(key); * obj.put(key,value); */ Leetcode 895 Maximum Frequency Stack 题目连接 Mximum Frequency Stack 题目大意 实现一个数据结构，以实现“最频繁栈”。 两个操作： 1. pop()，弹出栈中元素数目最多的，如果有多个，弹出最后一个入栈的。(保证不会对空栈执行pop操作)。 2. push(x)，进入一个x元素。 做法 最暴力的做法是，维护一个真的栈，顺便统计栈中每个元素的出现次数(map&lt;int,int&gt;)，每次遇到pop操作，边查找整个栈中出线最频繁且最靠近栈尾的元素，进行出栈并进行维护。 这样的操作每次O(n)，显然不够优雅。 进一步观察出栈信息，其实我们可以把元素“割裂”开来，如5个5，不要看成一体。而是看成在出现1次的数中5有一个，在出现2次的数中5有一个……以此类推…… 这样我们就可以维护n个栈，栈i表示出现i次的元素的情况。 如数据1 2 1 2 ，就可以看成： 1. 栈1中有元素1，表示出现1次的元素有1。 2. 栈1中进入元素2，有1 2 ，表示出现1次的元素有1 2（这时如果出栈，先出2，刚好是满足要求的). 3. 栈2中进入元素1，表示出现2次的元素有1。 4. 栈2中进入元素2，表示出现2次的元素有1 2.(优先出标号大的栈中元素) 这样即可达到要求了。（真是巧妙的很，我醉了）。 代码 ACcode12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/********************************************************** * Author : xie keyi * Email : xiekeyi98@snnu.edu.cn * Last modified : 2018-12-10 21:00 * Filename : 895MaximumFrequencyStack.cpp * Description : * *******************************************************/// 实现一个栈，弹出里面出现最频繁的数字// 一样频繁按照栈的顺序出class FreqStack &#123;public: FreqStack() &#123; max_freq = -1 ; &#125; void push(int x) &#123; mp1[x]++; // 元素x的出现次数+1 // 如果元素x的出现次数变成最大了 // 修改max_freq(出现次数最多的栈编号) if( mp1[x] &gt;= max_freq ) max_freq = mp1[x]; // 编号为mp1[x]的栈进入元素x mp2[mp1[x]].push(x); return ; &#125; int pop() &#123; // 记录出现次数最多的栈编号里面的栈顶元素(返回值) auto res = mp2[max_freq].top(); mp2[max_freq].pop(); // 元素出栈 mp1[res]--; // 元素出现次数减一 // 如果最频繁的元素都出完了，最大编号-1 if( mp2[max_freq].empty() ) max_freq--; return res; &#125;private: int max_freq ; // 出现次数最多的数字 map&lt;int,int&gt; mp1 ; // mp1[x] 表示数字x出现的次数 map&lt;int , stack&lt;int&gt; &gt; mp2; // mp2[x] 表示出现x次的数字出现的顺序(按照stack) &#125;;/** * Your FreqStack object will be instantiated and called as such: * FreqStack obj = new FreqStack(); * obj.push(x); * int param_2 = obj.pop(); */]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络流24题之魔术球问题]]></title>
    <url>%2F74901417.html</url>
    <content type="text"><![CDATA[luoguP2765魔术球问题，给出n个柱子，要求柱子每次只能从最上面放球，任意相邻两个球之和为完全平方数。球编号为1、2、3....，每个球都必须放，不能不放。求最后能放多少个球，每根柱子上的球分别是什么？ luoguP2765魔术球问题 分析 这算是我做到的网络流问题的第一个变种吧，并不再能一眼看出是网络流了233333. 首先这道题对于每个球，显然可以决策，放在某个柱子还是不放。所以一开始如果不是tag上有网络流24题，大概我就会钻进DP里出不来了吧。仔细想想会发现，dp的话，状态很难存储那么那么多(基本是无法表示的，尤其对于一个球可能能放到多个柱子上)。 所以考虑贪心，贪心的做法就是找到第一个能放的地方放柱子上，放不了就放到新柱子上。然而一方面贪心不会证明正确性(题解似乎有dalao证明了正确性)，一方面我是来练网络流的233333 这道题关键的建模在于【最小路径覆盖】，可以把柱子看成是最小路径覆盖数，每个球是点，边要求完全平方数，也就是连边条件。 又知道 最小路径覆盖数字 = 顶点数 - 最大匹配数 ， 在这里我们能确定最小路径覆盖数，然后顶点数不断增加，并通过跑匈牙利或最大流求出最大匹配数。 直到顶点数 - 最大匹配数 大于 最小路径覆盖数，就说明此时已经到边界外了，即退出循环即可。 这道题还需要用到的常用套路是，对于有向图的二分图最大匹配，需要【拆点】后，再进行匹配。原因是类似于1-&gt;2-&gt;3这种情况，如果直接跑匈牙利，是很难跑出答案的，或者跑出的答案很难输出方案。所以我们要拆成1-&gt;2 2'-&gt;3，这样即可。 最后，做二分图到底该用匈牙利还是dinic呢...? 源代码 贪心 ACcode1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 直接贪心// 找到能放的就放，不能就新开一个。//#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100 ;int dp[maxn];vector&lt;int&gt; a[maxn];bool isPerfect( int n )&#123; int t = sqrt(n); if( t * t == n ) return true ; return false ;&#125;int main()&#123; int n ; cin &gt;&gt; n ; int ans = 0 ; for( int i = 1 ; i &lt;= 10000; i++) &#123; bool flag = false ; for( int j = 1 ; j &lt;= n ; j++) &#123; if( dp[j] == 0 || isPerfect( *(a[j].rbegin()) + i) ) &#123; dp[j]++; ans++; a[j].push_back(i); flag = true ; break; //dp[j][1] = i ; &#125; &#125; if(!flag) break; &#125; cout &lt;&lt; ans &lt;&lt; endl ; for( int i = 1 ; i &lt;= n ; i++) &#123; for( auto j : a[i] ) cout &lt;&lt; j &lt;&lt; ' ' ; cout &lt;&lt; endl ; &#125; return 0 ;&#125; 匈牙利算法 ACcode123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135/********************************************************** * Author : xie keyi * Email : xiekeyi98@snnu.edu.cn * Last modified : 2018-10-17 21:34 * Filename : P2765网络流24题-3.cpp * Description : * *******************************************************/// 把柱子看成最小路径覆盖数// 球看成最大匹配数// 完全平方数条件看成匹配条件（建边条件)//#include &lt;bits/stdc++.h&gt;using namespace std;const int maxm = 200010;const int maxp = 5000;const int maxn = 10010+ maxp;struct Edge&#123; int nxt = -1 ; int to ;&#125;edge[maxm];int tol = 0 ;int head[maxn];void init()&#123; tol = 0 ; memset(edge,-1,sizeof(edge)); memset(head,-1,sizeof(head));&#125;void addedge( int u , int v )&#123; edge[tol].to = v ; edge[tol].nxt = head[u]; head[u] = tol++;&#125;bool used[maxn];int linker[maxn];int dfs( int u )&#123; for( int i = head[u] ; ~i ; i = edge[i].nxt ) &#123; int to = edge[i].to; if( !used[to] ) &#123; used[to] = true ; if( linker[to] == 0 || dfs( linker[to] ) ) &#123; linker[to] = u ; linker[u] = to ; return 1 ; &#125; &#125; &#125; return 0 ;&#125;int xiongyali()&#123; int res = 0 ; memset(linker,0,sizeof(linker)); memset(used,0,sizeof(used)); for( int i = 1; i &lt;= maxp ; i++ ) &#123; memset(used,0,sizeof(used)); res += dfs( i ) ; &#125; return res;&#125;bool isPerfect( int n )&#123; int t = sqrt(n) ; return t * t == n ;&#125;void print( int i )&#123; int t = i + maxp; while( t != 0 ) &#123; t = t - maxp; used[t] = true ; cout &lt;&lt; t &lt;&lt; ' ' ; t = linker[t]; &#125; cout &lt;&lt; endl ; &#125;int main()&#123; init(); int n ; cin &gt;&gt; n ; int m = 0 ; // m 是小球数量(点数) ， n是最小路径覆盖数, ans是最大匹配数 // 点数-最大匹配数 = 最小路径覆盖数字 int ans = 0 ; while( m - ans &lt;= n ) &#123; m++; for( int i = 1 ; i &lt;= m - 1 ; i++) &#123; if( isPerfect(i+m) ) &#123; addedge(i , m + maxp); addedge(m+maxp , i); &#125; &#125; // memset( used,0,sizeof(used)); // cout &lt;&lt; "m+maxp:" &lt;&lt; m + maxp &lt;&lt; endl ; // ans += dfs(m+maxp); ans = xiongyali(m) ; // 为什么从拆的点（Y部)匈牙利就会对， // 从原点1到n匈牙利，方案就会不一样？ m--; cout &lt;&lt; m &lt;&lt; endl; memset(used,0,sizeof(used)); for( int i = 1 ; i &lt;= m ; i++) &#123; if( !used[i] ) print(i); &#125; return 0 ;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>匈牙利</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[怎样解题表[转]]]></title>
    <url>%2Fc1caff0e.html</url>
    <content type="text"><![CDATA[原文是Polya的数学教育书系列~How to solve it~中的一部分。阐释了数学问题的一般性解决思路。 我是在《最小割模型在信息学竞赛中的应用》中第一次看到这个表。 感觉这个表很好，所以放在这里，希望能时刻提醒我。 怎样解题表 How to solve it 弄清问题 首先你必须弄清问题 未知数是什么？已知数是什么？条件是什么？ 满足条件是否可能？要确定未知数，条件是否充分？或者多余？还是矛盾？ 画一张图，使用恰当的符号 理清不同的条件，试着把它们都写下来。 拟定计划 找出已知数与未知数之间的联系。如果没有直接的联系，就必须考虑辅助性的问题。最终应该得到一个求解计划。 你以前见过它吗？你是否见过相同的或形式稍有不同的问题？ 你是否知道与此有关的问题？或者一个可以用的上的定理？ 看着未知数，试着想出一个有相同或相似未知数的熟悉问题。 如果有一个与现在的问题有关并且早已解决的问题，你能否利用它？能否利用它的结果或方法？为了利用它是否应该先引入某些辅助元素？ 你能否重新叙述这个问题，尽可能地从不同的角度？很多时候你必须回到定义中去。 如果你不能解决所提出的问题，可以尝试先解决一个与此有关的。你能否提出一个更容易着手的相关问题——像是一个更普遍的或者更特殊的，或者一个类比的问题？ 你能否解决这个问题的一部分？仅仅保留条件的一部分而舍弃其余,这样对于未知数能确定到什么程度？它还能怎样变化？你能否从已知数据推导出某些有用的信息？你是否考虑过用其它数据来确定未知数？如果需要的话，你能否转化未知数或数据(或者二者同时)，以使得新未知数和新数据联系更紧密？ 你是否利用了所有的已知数据？你是否利用了全部的条件？你是否考虑了问题中包含的所有基本概念？ 实行计划 实行你的计划 实现你的解题计划，检查每个步骤。你能否清楚地看出这一步骤的正确性？你能否证明？ 回顾 验算所得到的解 你能否验算这个解？能否解决争议？ 你能否用别的方法得到这个解答？或者你其实能够一眼就看出它来？ 你能否把本题的结果或方法应用于其它的问题?]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO-Chapter4-Section4.2]]></title>
    <url>%2F10ca572f.html</url>
    <content type="text"><![CDATA[USACO第四章第二节——网络流 1ditch ACcode123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133/*ID:xiekeyi1PROG:ditchLANG:C++11*/#include&lt;bits/stdc++.h&gt;using namespace std ;const int maxn = 500;struct node&#123; int to , capcity; node( int a , int b )&#123; to = a , capcity = b ; &#125; ;&#125;;int st , ed ;int n , m ;vector&lt;node&gt; a[maxn];int dep[maxn];bool bfs()&#123; memset(dep,0,sizeof(dep)); queue&lt;int&gt; q ; q.push(st); dep[st] = 1 ; bool succ =false ; while( !q.empty() ) &#123; int t = q.front(); if( t == ed ) succ = true ; q.pop(); for( int i = 0 ; i &lt; a[t].size() ; i++) &#123; if( dep[ a[t][i].to ] == 0 &amp;&amp; a[t][i].capcity &gt; 0 ) &#123; dep[a[t][i].to] = dep[t] + 1 ; q.push( a[t][i].to ) ; &#125; &#125; &#125; return succ ; &#125;int dfs( int st , int flow )&#123; if( st == ed ) return flow ; for( int i = 0 ; i &lt; a[st].size() ; i++ ) &#123; if( dep[a[st][i].to] == dep[st] + 1 &amp;&amp; a[st][i].capcity &gt; 0 ) &#123; int di = dfs( a[st][i].to , min( flow , a[st][i].capcity ) ); if( di &gt; 0 ) &#123; a[st][i].capcity -= di; for( int j = 0 ; j &lt; a[i].size() ; j++) &#123; if( a[a[st][i].to][j].to == st ) &#123; a[a[st][i].to][j].capcity += di ; break ; &#125; &#125; //printf("ADD %d --&gt; %d \n " , st , a[st][i].to ); return di ; &#125; &#125; &#125; return 0 ;&#125;int dinic( )&#123; int ans = 0 ; while( bfs() ) &#123; while( int d = dfs( st , 0x7fffffff ) ) ans += d ; &#125; return ans ;&#125;int main()&#123; freopen("ditch.in","r",stdin); freopen("ditch.out","w",stdout); cin &gt;&gt; n &gt;&gt; m ; st = 1 ; ed = m ; for( int i = 1 ; i &lt;= n ; i++) &#123; int from , to , capcity ; cin &gt;&gt; from &gt;&gt; to &gt;&gt; capcity ; bool flag = false ; for( int j = 0 ; j &lt; a[from].size(); j++) &#123; if( a[from][j].to == to ) &#123; flag = true ; a[from][j].capcity += capcity; break ; &#125; &#125; if( !flag ) a[from].push_back( node( to , capcity ) ) ; flag = false ; for( int j = 0 ; j &lt; a[to].size() ; j++) &#123; if( a[to][j].to == from ) &#123; flag = true ; a[to][j].capcity += 0 ; break; &#125; &#125; if( !flag ) a[to].push_back( node( from , 0 ) ) ; &#125; cout &lt;&lt; dinic() &lt;&lt; endl ; return 0 ;&#125; 2stall4 ACcode123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/*ID:xiekeyi1PROG:stall4LANG:C++11*/#include&lt;bits/stdc++.h&gt;using namespace std ;const int maxn = 222;bool graph[maxn][maxn];bool used[maxn];int stalls[maxn];int n , m ;int found( int st )&#123; for( int i = 1 ; i &lt;= n ; i++) &#123; if( graph[st][i] &amp;&amp; !used[i] ) &#123; used[i] = true; if( stalls[i] == 0 || found( stalls[i] ) ) &#123; stalls[i] = st ; return 1 ; &#125; &#125; &#125; return 0 ; &#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(0); freopen("stall4.in","r",stdin); freopen("stall4.out","w",stdout); cin &gt;&gt; n &gt;&gt; m ; for( int i = 1 ; i &lt;= n ; i++) &#123; int num ; cin &gt;&gt; num ; for( int j = 1 ; j &lt;= num ; j++) &#123; int t ; cin &gt;&gt; t ; graph[i][t] = true ; &#125; &#125; int ans = 0 ; for( int i = 1 ; i &lt;= n ; i++) &#123; memset( used , 0 , sizeof( used ) ) ; ans += found( i ) ; &#125; cout &lt;&lt; ans &lt;&lt; endl ; &#125; 3 job ACcode1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/*ID:xiekeyi1PROG:jobLANG:C++11*/#include&lt;bits/stdc++.h&gt;using namespace std ;struct node&#123; int v ; int t; node( int _v , int _t ) : v(_v) , t(_t) &#123;&#125;; bool operator&lt;( const node &amp;v ) const &#123; return t &lt; v.t ; &#125;; bool operator&gt;( const node &amp;v ) const &#123; return t &gt; v.t ; &#125;;&#125;;int main()&#123; ios::sync_with_stdio(false); cin.tie(0); freopen("job.in","r",stdin); freopen("job.out","w",stdout); int n , m1 , m2 ; cin &gt;&gt; n &gt;&gt; m1 &gt;&gt; m2 ; int ans1 = 0 , ans2 = 0 ; int tt[1010]= &#123;0&#125;; priority_queue&lt; node, vector&lt;node&gt; , greater&lt;node&gt; &gt; pq1; priority_queue&lt; node, vector&lt;node&gt; , greater&lt;node&gt; &gt; pq2; for( int i = 1 ; i &lt;= m1 ; i++) &#123; int v; cin &gt;&gt; v ; pq1.push(node(v,v));; &#125; for( int i = 1 ; i &lt;= n ; i++) &#123; auto t = pq1.top(); pq1.pop(); ans1 = max( ans1 , t.t ) ; tt[i] = ans1; t.t += t.v; pq1.push(t); &#125; for( int i = 1 ; i &lt;= m2 ; i++) &#123; int v ; cin &gt;&gt; v ; pq2.push( node( v , v )); &#125; for( int i = n ; i &gt;= 1 ; i-- ) &#123; auto t = pq2.top(); pq2.pop(); ans2 = max( ans2 , t.t + tt[i] ) ; t.t += t.v ; pq2.push(t); &#125; cout &lt;&lt; ans1 &lt;&lt; ' ' &lt;&lt; ans2 &lt;&lt; endl ; return 0 ; &#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>USACO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO-Chapter4-Section4.1]]></title>
    <url>%2F89c30695.html</url>
    <content type="text"><![CDATA[最优化问题 1nuggets ACcode1234567891011121314151617181920212223242526272829303132333435363738394041/*ID:xiekeyi1PROG:nuggetsLANG:C++11*/#include&lt;bits/stdc++.h&gt;using namespace std ;const int maxn = 260;bool dp[maxn*maxn];int a[maxn];int main()&#123; freopen("nuggets.in","r",stdin); freopen("nuggets.out","w",stdout); ios::sync_with_stdio(false); cin.tie(0); int n ; cin &gt;&gt; n ; for( register int i = 1 ; i &lt;= n ; i++) cin &gt;&gt; a[i]; memset(dp ,false,sizeof(dp)); for( register int i = 1 ; i &lt;= n ; i++) dp[a[i]] = true ; for( register int i = 1 ; i &lt;= n ; i++) for( int j = a[i] ; j &lt;= maxn * maxn ; j++) if( dp[ j - a[i] ] == true ) dp[j] = true ; int ans = 0 ; for( register int i = maxn * maxn ; i &gt;= 0 ; --i) if( !dp[i] ) &#123; ans = i; break; &#125; if( ans &gt; 256 * 256 ) ans = 0 ; cout &lt;&lt; ans &lt;&lt; endl ; return 0 ;&#125; 2fence6 通过这道题大概学会了如何用floyd求最小环和如何把边邻接矩阵转换建图 本质上就是把利用map把点编号，对于某端连接的点全部一样就可以看成是一个端点。不一样的就新建一个点。(有点像离散化、动态开点、内存池等那种做法) ACcode123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/*ID:xiekeyi1PROG:fence6LANG:C++11*/#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 110;struct edge&#123; int ns; int a[9]; edge()&#123; memset(a,0,sizeof(a)); ns=0;&#125;; bool operator =( const edge &amp;b) const &#123; for( int i = 0 ; i &lt; 9 ; i++) if( a[i] != b.a[i] ) return false ; return true ; &#125; bool operator &lt;( const edge &amp;b ) const &#123; for( int i = 0 ; i &lt; 9 ; i++) &#123; if( a[i] &lt; b.a[i] ) return true ; else if( a[i] &gt; b.a[i] ) return false ; &#125; return false ; &#125;&#125;;int graph[maxn][maxn];map&lt;edge,int&gt; mp;int cnt;int main()&#123; freopen("fence6.in","r",stdin); freopen("fence6.out","w",stdout); int n ; cin &gt;&gt; n ; memset( graph , 0x1f , sizeof(graph) ); for( int i = 1; i &lt;= n ; i++) &#123; edge f1 , f2; int s , ls , n1s , n2s ; cin &gt;&gt; s &gt;&gt; ls &gt;&gt; n1s &gt;&gt; n2s; f1.a[n1s]=s; f2.a[n2s]=s; for( int j = 0 ; j &lt; n1s ; j++) cin &gt;&gt; f1.a[j]; for( int j = 0 ; j &lt; n2s ; j++) cin &gt;&gt; f2.a[j]; sort( f1.a , f1.a + 9 ) ; sort( f2.a , f2.a + 9 ); if( mp[f1] == 0 ) mp[f1] = ++cnt; if( mp[f2] == 0 ) mp[f2] = ++cnt; graph[mp[f1]][mp[f2]] = ls; graph[mp[f2]][mp[f1]] = ls; &#125; int dist[maxn][maxn]; memcpy(dist,graph,sizeof(dist)); int ans = 0x7fffffff ; for( int k = 1 ; k &lt;= cnt ; k++) &#123; for( int i = 1 ; i &lt;= k; i++) for( int j = i + 1 ; j &lt;= k; j++) ans=min(ans,dist[i][j]+graph[i][k]+graph[k][j] ); for( int i = 1 ; i &lt;= cnt ; i++) for( int j = 1 ; j &lt;= cnt ; j++) dist[i][j] = min( dist[i][j] , dist[i][k] + dist[k][j] ); &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>USACO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO-Chapter3-Section3.4]]></title>
    <url>%2F887e0d10.html</url>
    <content type="text"><![CDATA[计算几何 ## 1.heritage ACcode12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/*ID:xiekeyi1PROG:heritageLANG:C++11*/#include&lt;bits/stdc++.h&gt;using namespace std ;const int maxn = 200 ; struct node &#123; char value = '\0'; int leftchild = -1 ; int rightchild = -1 ;&#125;tree[200];int head = 1 , p = 0 ;void build( string s1 , string s2 )&#123; if( s1.size() == 0 || s2.size() == 0 ) return ; tree[++p].value = s2[0]; int partion = -1; for( int i = 0 ; i &lt; s1.size() ; i++) &#123; if( s1[i] == s2[0] ) &#123; partion = i ; break ; &#125; &#125; int tp = p ; if( partion != 0 ) &#123; tree[tp].leftchild = p + 1 ; build( s1.substr( 0 , partion ) , s2.substr( 1 , partion ) ); &#125; if( partion + 1 != s1.size() || partion + 1 != s2.size() ) &#123; tree[tp].rightchild = p + 1 ; build( s1.substr( partion + 1 , 100 ) , s2.substr( partion + 1 , 100 ) ); &#125;&#125;void print( int head )&#123; if( tree[head].value != '\0' ) &#123; print(tree[head].leftchild); print(tree[head].rightchild); cout &lt;&lt; tree[head].value ; &#125;&#125;int main()&#123; freopen("heritage.in","r",stdin); freopen("heritage.out","w",stdout); string inorder , preorder ; cin &gt;&gt; inorder &gt;&gt; preorder ; // 中序遍历 前序遍历 build( inorder , preorder ); print(head); cout &lt;&lt; endl ; return 0 ; &#125; 2fence9 ACcode12345678910111213141516171819202122232425262728293031323334/*ID:xiekeyi1PROG:fence9LANG:C++11*/#include&lt;bits/stdc++.h&gt;using namespace std ;int gcd( int x , int y ) &#123; if( y == 0 ) return x ; else return gcd( y , x % y ) ;&#125;int main()&#123; freopen("fence9.in","r",stdin); freopen("fence9.out","w",stdout); int n , m , p ; cin &gt;&gt; n &gt;&gt; m &gt;&gt; p ; // (扩展)欧几里得定理 int edge1 = gcd(n,m) ; int edge2 = gcd(abs(p-n),m); int edge3 = gcd(p,0); int area = p * m / 2 ; // 匹克定理： 2S = 2a + b - 2 , a为多边形内部点数，b为边界上的点数，S为面积 int ans = area - (edge1+edge2+edge3)/2 + 1 ; cout &lt;&lt; ans &lt;&lt; endl ; return 0;&#125; 3rockers ACcode12345678910111213141516171819202122232425262728293031323334353637/*ID:xiekeyi1PROG:rockersLANG:C++11*/#include&lt;bits/stdc++.h&gt;using namespace std ;const int maxn = 22;int a[maxn];int dp[maxn][maxn]; // dp[i][j]表示装在前i张碟片每张j分钟的总歌曲数目/* * DP[i][j] = dp[i-1][j] , dp[i-1][j-a[i]]+1,dp[i-1][j-a[i] **/int main()&#123; freopen("rockers.in","r",stdin); freopen("rockers.out","w",stdout); int n , t , m ; cin &gt;&gt; n &gt;&gt; t &gt;&gt; m ; for( int i = 1 ; i &lt;= n ;i++) cin &gt;&gt; a[i] ; for( int i = 1 ; i &lt;= n ; i++) for( int j = m ; j &gt;= 1 ; j-- ) for( int k = t ; k &gt;= a[i] ; k--) &#123; dp[j][k] = max( &#123; dp[j][k] , dp[j-1][t] + 1 , dp[j][ k-a[i] ] + 1 &#125; ); &#125; cout &lt;&lt; dp[m][t] &lt;&lt; endl ; return 0 ; &#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>USACO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO-Chapter3-Section3.3]]></title>
    <url>%2F161a98b3.html</url>
    <content type="text"><![CDATA[USACO-Chapter3-Section3.3 欧拉回路 1.fence ACcode123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687/*ID:xiekeyi1PROG:fenceLANG:C++11*/#include&lt;bits/stdc++.h&gt;using namespace std ;const int maxn = 1100;vector&lt;int&gt; a[maxn];stack&lt;int&gt; s;void Euler( int start)&#123; bool flag = false ; for( int i = 0 ; i &lt; a[start].size() ; ) &#123; // for( int j = 0 ; i &lt; a[ a[start][i] ].size() ; j++) // &#123; // if( a[ a[start][i] ][j] == start ) // &#123; // a[a[start][i]].erase( a[a[start][i]].begin() + j ); // break; // &#125; // &#125; a[ a[start][i] ].erase( find( a[a[start][i]].begin() , a[a[start][i]].end() , start ) ) ; int to = a[start][i]; a[start].erase( a[start].begin() + i ) ; flag = true ; Euler(to); if( !flag ) i++; &#125; s.push(start);&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(0); freopen("fence.in","r",stdin); freopen("fence.out","w",stdout); int n; cin &gt;&gt; n ; int start = -1; int degree[maxn] ; memset( degree , 0 , sizeof( degree ) ) ; for( int i = 1 ; i &lt;= n ; i++) &#123; int x , y ; cin &gt;&gt; x &gt;&gt; y ; degree[y]++; degree[x]++; a[x].push_back(y); a[y].push_back(x); &#125; for( int i = 1 ; i &lt; maxn ; i++) &#123; if( degree[i] % 2 == 1 ) &#123; start = i ; break ; &#125; &#125; if( start == -1 ) &#123; for( int i = 1 ; i &lt; maxn ; i++) &#123; if( a[i].size() &gt; 0 ) &#123; start = i ; break ; &#125; &#125; &#125; for( int i = 1 ; i &lt; maxn; i++) sort( a[i].begin() , a[i].end() ) ; Euler(start); while( !s.empty() ) &#123; cout &lt;&lt; s.top() &lt;&lt; endl ; s.pop(); &#125; return 0 ;&#125; 2shopping ACcode123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102/*ID:xiekeyi1PROG:shoppingLANG:C++11*/#include&lt;bits/stdc++.h&gt;using namespace std ;const int maxn = 1010;int main()&#123; freopen("shopping.in","r",stdin); freopen("shopping.out","w",stdout); int s ;//物品种类 cin &gt;&gt; s ;// int n ; // 促销种类// cin &gt;&gt; n ; int reduced[maxn][maxn]; int price[maxn]; memset( reduced , 0 , sizeof( reduced ) ) ; memset( price , 0 , sizeof( price ) ) ; int idd[maxn] ; memset(idd , 0 , sizeof(idd) ) ; int cnt = 0 ; for( int i = 1 ; i &lt;= s ; i++) &#123; int t ; cin &gt;&gt; t ; for( int j = 1 ; j &lt;= t ; j++) &#123; int num , id; cin &gt;&gt; id &gt;&gt; num ; // num个编号id物品 // 离散化 if( idd[id] == 0 ) &#123; ++cnt; idd[id] = cnt; &#125; reduced[ i ][idd[id]] = num;// 记录对于第i个优惠政策来说，num物品的个数 &#125; int p ; cin &gt;&gt; p ; price[i] = p ; // 第i种优惠方案的价格 &#125; int yuanprice[maxn] ; // 每种物品原价 memset(yuanprice , 0 , sizeof(yuanprice) ) ; int need[maxn]; // 每种物品需要的个数 memset(need, 0 , sizeof(need) ) ; int b; cin &gt;&gt; b ; for( int i = 1 ; i &lt;= b ; i++) &#123; int x , y , z ; cin &gt;&gt; y &gt;&gt; x &gt;&gt; z ; if( idd[y] == 0 ) &#123; ++cnt; idd[y] = cnt ; &#125; need[idd[y]] = x ; yuanprice[ idd[y] ] = z; &#125; int dp[10][10][10][10][10]; // dp[i][j][k][l][m]表示买i个1物品j个2物品k个3物品4个l物品5个m物品的最小花费 memset( dp , 0 , sizeof(dp ) ); for( int i1 = 0 ; i1 &lt;= need[1] ; i1++) &#123; for( int i2 = 0 ; i2 &lt;= need[2] ; i2++) &#123; for( int i3 = 0 ; i3 &lt;= need[3] ; i3++) &#123; for( int i4 = 0 ; i4 &lt;= need[4] ; i4++) &#123; for( int i5 = 0 ; i5 &lt;= need[5] ; i5++) &#123; dp[i1][i2][i3][i4][i5] = yuanprice[1] * i1 + yuanprice[2] * i2 + yuanprice[3] * i3 + yuanprice[4] * i4 + yuanprice[5] * i5 ; for( int j = 1 ; j &lt;= s ; j++) &#123; if( i1 - reduced[j][1] &gt;= 0 &amp;&amp; i2 -reduced[j][2] &gt;= 0 &amp;&amp; i3 - reduced[j][3] &gt;= 0 &amp;&amp; i4 - reduced[j][4] &gt;= 0 &amp;&amp; i5 - reduced[j][5] &gt;= 0 ) &#123; dp[i1][i2][i3][i4][i5] = min( dp[i1][i2][i3][i4][i5] , dp[ i1-reduced[j][1]][i2-reduced[j][2]][i3-reduced[j][3]][i4-reduced[j][4]][i5-reduced[j][5]] + price[j] ); &#125; &#125; &#125; &#125; &#125; &#125; &#125; cout &lt;&lt; dp[need[1]][need[2]][need[3]][need[4]][need[5]] &lt;&lt; endl ; return 0 ;&#125; 3.camelot ACcode123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122/*ID:xiekeyi1PROG:camelotLANG:C++*/#include&lt;bits/stdc++.h&gt;using namespace std ;const int dx[] = &#123;0, 2 , 2 ,-2 , -2 , 1 , 1 , -1 , -1 &#125;;const int dy[] = &#123;0, 1 , -1 ,1 , -1 , 2 , -2 , 2 , -2 &#125;;int row , col ; // 地图行列struct point&#123; int x , y ;&#125;gw,qs[1000]; // 国王 骑士 坐标int p = 0 ;int dist[31][31][31][31]; // dist[i][j][k][l] 表示从i,j到kl所需最短距离(骑士走)struct qnode&#123; int x , y , dist ; qnode( int _x , int _y , int _dist) &#123; x = _x , y = _y , dist = _dist ; &#125; ;&#125;;inline bool check( const int &amp;x , const int &amp;y )&#123; if( x &gt; 0 &amp;&amp; x &lt;= row &amp;&amp; y &gt; 0 &amp;&amp; y &lt;= col ) return true ; return false ;&#125;void BFS(int x , int y )&#123; queue&lt;qnode&gt; q; q.push( qnode(x,y,0 ) ) ; bool vis[50][50]; memset( vis , false , sizeof(vis) ) ; while( !q.empty() ) &#123; qnode t = q.front(); q.pop(); //assert( ! (dist[x][y][t.x][t.y] != 0x3f3f3f3f &amp;&amp; t.dist &lt; dist[x][y][t.x][t.y] ) ); dist[x][y][t.x][t.y] = min( t.dist , dist[x][y][t.x][t.y] ) ; for( int i = 1 ; i &lt;= 8 ; i++) &#123; if( !vis[t.x+ dx[i] ][t.y+dy[i]] &amp;&amp; check(t.x + dx[i] , t.y + dy[i] ) ) &#123; vis[t.x + dx[i]][t.y + dy[i]] = true ; q.push( qnode( t.x+dx[i] , t.y+dy[i] , t.dist + 1 ) ) ; &#125; &#125; &#125;&#125;int solve()&#123; // 枚举行列作为集合点 int ans = 0x7fffffff ; for( int i = 1 ; i &lt;= row ; i++) &#123; for( int j = 1 ; j &lt;= col ; j++) &#123; int s1 = 0 ; bool flag = false ; for( int k = 1 ; k &lt;= p ; k++) &#123; if( dist[qs[k].x][qs[k].y][i][j] &gt; row * col + 1000 ) &#123; flag= true ;break; &#125; s1 += dist[ qs[k].x ][ qs[k].y ][i][j] ; &#125; if( flag ) continue; ans = min( ans , s1 + max( abs( gw.x- i ) , abs(gw.y - j ) ) ) ; for( int k = 1 ; k &lt;= p ; k++) &#123; int s2 = 0x3f3f3f3f; for( int k1 = max( 1 , gw.x - 2 ) ; k1 &lt;= min( row , gw.x +2) ; k1++ ) &#123; for( int k2 = max( 1 , gw.y - 2 ) ; k2 &lt;= min( col , gw.y + 2 ) ; k2++ ) &#123; if( dist[qs[k].x][qs[k].y][k1][k2] &gt; row * col + 10000) continue; s2 = min( s2 , dist[qs[k].x][qs[k].y][k1][k2] + max(abs(gw.x-k1) , abs(gw.y-k2) ) + dist[k1][k2][i][j] ); &#125; &#125; ans = min( ans , s1 + s2 - dist[qs[k].x][qs[k].y][i][j] ); &#125; &#125; &#125; return ans ; &#125;int main()&#123; freopen("camelot.in","r",stdin); freopen("camelot.out","w",stdout); cin &gt;&gt; row &gt;&gt; col ; int trow ; char tcol; cin &gt;&gt; tcol &gt;&gt; trow ; gw.x = trow , gw.y = tcol - 'A' + 1 ; while( cin &gt;&gt; tcol &gt;&gt; trow ) &#123; qs[++p].x = trow , qs[p].y = tcol - 'A' + 1 ; &#125; memset( dist , 0x3f , sizeof(dist ) ) ; for( int i= 1 ; i &lt;= row ; i++) for( int j = 1 ; j &lt;= col ; j++) BFS( i , j ) ; // 以(i,j)为起点bfs，陆续得到dist[x][y][i][j] cout &lt;&lt; solve() &lt;&lt; endl ; &#125; 4.range ACcode12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/*ID:xiekeyi1PROG:rangeLANG:C++11*/#include&lt;bits/stdc++.h&gt;//#define DEBUGusing namespace std ;const int maxn = 255;int graph[maxn][maxn];int dp[maxn][maxn] ; // dp[i][j]表示以(i,j)为右下角的，最大正方形边长有多大int ans[maxn*maxn]; // ans[i]表示边长为i的矩形有ans[i]个int main()&#123; ios::sync_with_stdio(false); cin.tie(0); freopen( "range.in" , "r" , stdin); freopen( "range.out" , "w" , stdout); int n ; cin &gt;&gt; n ; for( int i = 1 ; i &lt;= n ; i++) &#123; for( int j = 1 ; j &lt;= n ; j++) &#123; char ch ; cin &gt;&gt; ch ; graph[i][j] = ch - '0'; &#125; &#125; for( int i = 1 ; i &lt;= n ; i++) &#123; for( int j = 1 ; j &lt;= n ; j++) &#123; if( graph[i][j] == 1 ) &#123; dp[i][j] = min( &#123;dp[i-1][j] , dp[i][j-1] , dp[i-1][j-1] &#125;) + 1 ; ans[ dp[i][j] ]++; &#125; &#125; &#125;#ifdef DEBUG for( int i = 1 ; i &lt;= n ; i++) &#123; for( int j = 1 ; j &lt;= n ; j++) cout &lt;&lt; graph[i][j] ; cout &lt;&lt; endl ; &#125; cout &lt;&lt; "--------------------" &lt;&lt; endl &lt;&lt; endl ; for( int i = 1 ; i &lt;= n ; i++) &#123; for( int j = 1 ; j &lt;= n ; j++) cout &lt;&lt; dp[i][j] ; cout &lt;&lt; endl ; &#125;#endif // DEBUG // 因为长度为3的正方形中漏算一个长度为2的正方形，同理…… for( int i = n ; i &gt;= 2 ; i-- ) ans[i-1] += ans[i]; for( int i = 2 ; i &lt;= n ; i++) &#123; if( ans[i] ) cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; ans[i] &lt;&lt; endl ; &#125; return 0 ;&#125; 5.game1 ACcode12345678910111213141516171819202122232425262728293031323334353637383940414243/*ID:xiekeyi1PROG:game1LANG:C++11*/#include&lt;bits/stdc++.h&gt;using namespace std ;const int maxn = 220;int a[maxn];int dp[maxn][maxn]; // dp[i][j]表示先手拿从i到j可以获得的最大价值int sum[maxn];int main()&#123; freopen("game1.in","r",stdin); freopen("game1.out","w",stdout); int n ; cin &gt;&gt; n ; for( int i = 1 ; i &lt;= n ; i++) &#123; cin &gt;&gt; a[i]; sum[i] = sum[i-1] + a[i]; &#125; for( int i = 1 ; i &lt;= n ; i++) dp[i][i] = a[i]; // dp[i][j] = max( ( sum[i..j] - dp[i][j-1] ) , // ( sum[i...j] - dp[i+1][j] ) // ) // dp[i][j] 需要 dp[i+1][j] 和 dp[i][j-1] for( int i = n ; i &gt;= 1 ; i-- ) &#123; for( int j = i + 1; j &lt;= n ; j++ ) &#123; dp[i][j] = max( ( sum[j-1] - sum[i-1] - dp[i][j-1] ) + a[j] , ( sum[j] - sum[i] - dp[i+1][j] + a[i] ) ); &#125; &#125; cout &lt;&lt; dp[1][n] &lt;&lt; ' ' &lt;&lt; sum[n] - dp[1][n] &lt;&lt; endl ; return 0 ; &#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>USACO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[无向图欧拉回路]]></title>
    <url>%2F5626f223.html</url>
    <content type="text"><![CDATA[无向图Hierholzer(逐步插入回路法)求欧拉回路 欧拉回路与欧拉通路 如果图G中的一个路径包括每个边恰好一次，则该路径称为欧拉路径(Euler path)。 如果一个回路是欧拉路径，则称为欧拉回路(Euler circuit)。 具有欧拉回路的图称为欧拉图（简称E图）。具有欧拉路径但不具有欧拉回路的图称为半欧拉图。 引理: 1. 无向图G是欧拉图的充分必要条件是G是连通图并且没有奇数度数点。 2. 无向图G是半欧拉图的充分必要条件是G是连通的并且恰好有两个奇数度顶点。 逐步插入回路法 算法本身很简单，把其理解成DFS也可以。 算法流程: 1234567Func(x) 循环寻找和X相连的边i &#123; 删除这条边i 递归Func(i) &#125;将x插入stack中 最后输出stack即为所求。 这个算法写起来非常简单，但是难点在于如何理解其正确性。网上很多博客也寥寥几笔，对此说的比较少。 这个算法其实就像是DFS找环一样，跑这个算法必须保证从当前点开始存在欧拉回路，否则会GG。所以我们在保证了当前点开始有欧拉回路后，就是DFS找环，并且利于回溯，在环中加入新节点来实现的寻找欧拉回路。 考虑仅仅有一个环的图，我们这个函数就是在里面找到了这个环，并且把环上的点加入进来。 如果说在这个环上加了一个新点，因为图是保证联通的，所以新点必然也可以到达之前环上的点，我们就等于是利用递归+删边，把这个环拆开加入了新点。]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>欧拉回路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO-Chapter3-Section3.2]]></title>
    <url>%2F611da825.html</url>
    <content type="text"><![CDATA[USACO-Chatper3-Section3.2 1.fact4 ACcode12345678910111213141516171819202122232425262728293031/*ID:xiekeyi1PROG:fact4LANG:C++11*/#include&lt;bits/stdc++.h&gt;using namespace std ;int main()&#123; freopen("fact4.in","r",stdin); freopen("fact4.out","w",stdout); int n ; cin &gt;&gt; n ; long long ans = 1ll ; for( int i = 1 ; i &lt;= n ; i++) &#123; ans *= i ; while( ans % 10ll== 0 ) ans /=10ll; ans = ans % 10000; &#125; while( ans % 10ll== 0 ) ans /=10ll; cout &lt;&lt; ans % 10 &lt;&lt; endl ; return 0 ;&#125; 2.kimbits ACcode12345678910111213141516171819202122232425262728293031323334353637383940/*ID:xiekeyi1PROG:kimbitsLANG:C++11*/#include&lt;bits/stdc++.h&gt;using namespace std ;long long dp[50][50];int main()&#123; freopen("kimbits.in","r",stdin); freopen("kimbits.out","w",stdout); for( int i = 0 ; i &lt;= 32 ; i++) dp[0][i] = 1 ; for( int i = 1 ; i &lt;= 32 ; i++) &#123; dp[i][0] = dp[i-1][0]; for( int j = 1 ; j &lt;= 32; j++) &#123; dp[i][j] = dp[i-1][j] + dp[i-1][j-1] ; &#125; &#125; long long n , m , l; cin &gt;&gt; n &gt;&gt; m &gt;&gt; l ; string s ; for( int i = n ; i &gt;= 1 ; i--) &#123; if( dp[i-1][m] &gt;= l ) s.push_back('0'); else &#123; s.push_back('1'); l-=dp[i-1][m]; m--; &#125; &#125; cout &lt;&lt; s &lt;&lt; endl ;&#125; 3.spin ACcode12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/*ID:xiekeyi1PROG:spinLANG:C++11*/#include&lt;bits/stdc++.h&gt;using namespace std ;int speed[10];int a[10][400];int timing = -1 ;bool judge()&#123; int jj[400]; memset( jj , 0 , sizeof(jj) ) ; for( int i = 1 ; i &lt;= 5 ; i++) &#123; for( int j = 0 ; j &lt; 360 ; j++) &#123; if( a[i][j] ) jj[ ( j + speed[i] * timing ) % 360 ]++; &#125; &#125; for( int i = 0 ; i &lt; 360 ; i++) &#123; if( jj[i] == 5 ) return true ; &#125; return false ;&#125;int main()&#123; freopen("spin.in","r" ,stdin); freopen("spin.out","w",stdout); for( int i = 1 ; i &lt;= 5 ; i++) &#123; int t ; cin &gt;&gt; speed[i] &gt;&gt; t ; for( int j = 1 ; j &lt;= t ; j++) &#123; int x , e ; cin &gt;&gt; x &gt;&gt; e ; for( int k = x ; k &lt;= x + e ; k++) a[i][k % 360 ] = 1 ; &#125; &#125; while( ++timing &lt;= 1200) &#123; if( judge() ) &#123; cout &lt;&lt; timing &lt;&lt; endl ; return 0 ; &#125; else if( timing &gt;= 1000 ) &#123; cout &lt;&lt; "none" &lt;&lt; endl ; return 0 ; &#125; &#125; return 0 ;&#125; 4.ratios ACcode1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/*ID:xiekeyi1PROG:ratiosLANG:C++11*/#include&lt;bits/stdc++.h&gt;using namespace std ;const int inf = 0x7fffffff;int a[10][10];int gcd( int x , int y ) &#123; if( y == 0 ) return x ; else return gcd( y , x % y) ;&#125;int main()&#123; bool succ = false ; freopen("ratios.in","r",stdin); freopen("ratios.out","w",stdout); for( int i = 1 ; i &lt;= 4 ; i++) cin &gt;&gt; a[i][1] &gt;&gt; a[i][2] &gt;&gt; a[i][3] ; int x , y , z ; int ans_total = inf , ans1 = inf , ans2 = inf , ans3 = inf , ans4 = inf ; for( int i = 0 ; i &lt;= 100 ; i++) &#123; for( int j = 0 ; j &lt;= 100 ; j++) &#123; for( int k = 0 ; k &lt;= 100 ; k++) &#123; x = a[2][1] * i + a[3][1] * j + a[4][1] * k; y = a[2][2] * i + a[3][2] * j + a[4][2] * k ; z = a[2][3] * i + a[3][3] * j + a[4][3] * k ; int temp_total = i+j+k ; int t = -1; if( x != 0 &amp;&amp; a[1][1] != 0 ) t = x / a[1][1] ; else if( y != 0 &amp;&amp; a[1][2] != 0 ) t = y / a[1][2]; else if( z != 0 &amp;&amp; a[1][3] != 0 ) t = z / a[1][3] ; if( a[1][1] * t == x &amp;&amp; a[1][2] * t == y &amp;&amp; a[1][3] * t == z &amp;&amp; temp_total &lt;= ans_total ) &#123; ans1 = i , ans2 = j , ans3 = k , ans4 = t ; ans_total = temp_total; succ = true ; &#125; &#125; &#125; &#125; if( succ ) cout &lt;&lt; ans1 &lt;&lt; ' ' &lt;&lt; ans2 &lt;&lt; ' ' &lt;&lt; ans3 &lt;&lt; ' ' &lt;&lt; ans4 &lt;&lt; endl ; else cout &lt;&lt; "NONE" &lt;&lt; endl ; return 0 ;&#125; 5.msquare ACcode123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143/*ID:xiekeyi1PROG:msquareLANG:C++11*/#include&lt;bits/stdc++.h&gt;using namespace std ;const int maxn = 10;int target[maxn];int src[maxn] = &#123; -1,1,2,3,4,8,7,6,5&#125;;struct node&#123; int num = 0 ; string s ; int a[maxn]; node( int sr[maxn] ) &#123; for( int i = 1 ; i &lt;= 8 ; i++ ) a[i] = sr[i] ; &#125;;&#125;;void transA( int a[maxn] )&#123; for( int i = 1 ; i &lt;= 4 ; i++) swap( a[i+4] , a[i] ) ;&#125;void transB(int a[maxn])&#123; for( int i = 4 ; i &gt;= 2 ; i-- ) &#123; swap( a[i],a[i-1]); swap( a[i+4] , a[i+3]); &#125;&#125;void transC( int a[maxn] )&#123; swap(a[2],a[3]); swap(a[2],a[6]); swap( a[6] , a[7]);&#125;int fac(int n )&#123; if( n == 0 ) return 1 ; else return fac(n-1)*n;&#125;int cantor(int a[maxn] )&#123; int ans = 0 ; for( int i = 1 ; i &lt;= 8 ; i++) &#123; int tmp = 0 ; for( int j = i + 1 ; j &lt;= 8 ; j++) if( a[j] &lt; a[i] ) tmp++; ans += tmp * fac(8-i); //ans += ( a[i] - 1 ) * fac(8-i); &#125; return ans ; &#125;bool found( int a[maxn] ,int b[maxn] )&#123; for( int i = 1 ; i &lt;= 8 ; i++) if( a[i] != b[i] ) return false ; return true ;&#125;void BFS()&#123; set&lt;int&gt; st; queue&lt;node&gt; q; q.push(node(src)); st.insert( cantor( src ) ) ; while( !q.empty() ) &#123; node t = q.front(); q.pop(); if( found( t.a , target ) ) &#123; cout &lt;&lt; t.num &lt;&lt; endl ; cout &lt;&lt; t.s &lt;&lt; endl ; return ; &#125; node t1 = t ; t1.s.push_back('A'); t1.num++; transA(t1.a); if( st.count( cantor( t1.a ) ) == 0 ) &#123; q.push(t1); st.insert( cantor(t1.a) ) ; &#125; t1 = t ; t1.s.push_back('B'); t1.num++; transB( t1.a ); if( st.count( cantor( t1.a ) ) == 0 ) &#123; q.push(t1); st.insert( cantor(t1.a) ) ; &#125; t1 = t ; t1.s.push_back('C'); t1.num++; transC( t1.a); if( st.count( cantor( t1.a ) ) == 0 ) &#123; q.push(t1); st.insert( cantor(t1.a) ) ; &#125; &#125;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(0); freopen("msquare.in","r",stdin); freopen("msquare.out","w",stdout); for( int i = 1 ; i &lt;= 4 ; i++) cin &gt;&gt; target[i]; for( int i = 8 ; i &gt;= 5 ; i-- ) cin &gt;&gt; target[i]; BFS(); return 0 ;&#125; 6.butter ACcode123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596/*ID:xiekeyi1PROG:butterLANG:C++11*/#include&lt;bits/stdc++.h&gt;using namespace std ;const int maxn = 1100;int dist[maxn];struct node&#123; int from; int to ; int value ; node( int f, int t , int v ) &#123; from = f , to = t, value = v ; &#125; ; bool operator &lt; ( const node &amp;b ) const &#123; return this-&gt;value &gt; b.value ; &#125;;&#125;;vector&lt;node&gt; graph[maxn] ; map&lt;int,int&gt; mp ;int dij( int from , int to )&#123; int vis[maxn]; memset( vis , false , sizeof(vis) ) ; memset( dist , 0x3f , sizeof(vis) ); priority_queue&lt; node &gt; pq ; dist[from] = 0 ; pq.push(node(from,from,0)); while( !pq.empty() ) &#123; node h = pq.top(); pq.pop(); if( vis[h.from] ) continue ; vis[h.from] = true ; for( int i = 0 ; i &lt; graph[h.from].size() ; i++) &#123; int val = graph[h.from][i].value ; int to = graph[h.from][i].to; int nownode = h.from; if( dist[to] &gt; dist[nownode] + val ) &#123; dist[to] = dist[nownode] + val ; pq.push( node( to , to , dist[to] ) ); &#125; &#125; &#125; return dist[to] ;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(0); freopen("butter.in","r",stdin); freopen("butter.out","w",stdout); int n , p , c ; cin &gt;&gt; n &gt;&gt; p &gt;&gt; c ; // sq存每头牛在的牧场情况 for( int i = 1 ; i &lt;= n ; i++) &#123; int t ; cin &gt;&gt; t ; mp[t]++; &#125; for( int i = 1 ; i &lt;= c ; i++) &#123; int from , to , value ; cin &gt;&gt; from &gt;&gt; to &gt;&gt; value ; graph[from].push_back( node( from, to , value ) ) ; graph[to].push_back( node( to , from , value ) ) ; &#125; int ans = 0x3f3f3f3f ; for( int i = 1 ; i &lt;= p ; i++) &#123; int t = 0 ; dij(i,p); for( auto j = mp.begin() ; j != mp.end() ; ++j ) &#123; t += dist[j-&gt;first] * j-&gt;second ; &#125; ans = min( t , ans ) ; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0 ;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>USACO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vim(.vimrc)配置备份]]></title>
    <url>%2F6f81dae4.html</url>
    <content type="text"><![CDATA[自己的vim配置备份(有注释) Vim 8.0 配置文件在vimrc，插件相关配置在vimrc.bundle内。 需先安装plug vimrc123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165&quot;set nocompatible &quot;取消和vi的兼容，避免以前的bug和功能&quot;autocmd GUIEnter * simalt ~x &quot;GVIM函数，启动GUI后自动全屏&quot;set guifont=Fixedsys:h16:cGB2312:qDRAFT &quot;设置字号&quot;set backspace=indent,eol,start &quot;GVIM设置，否则退格键有问题。&quot; -------- GVIM ------ &quot;为了兼容VI，所以backspace有好几种模式&quot; indent: 表示可以删除自动缩进的部分.&quot; eol: 表示在行尾可以合并两行&quot; start:表示可以删除之前的输入set fileencodings=utf-8,gb2312,gb18030,gbk,ucs-bom,cp936,latin1 &quot;设置文件编码格式syntax on &quot;开启代码高亮set nu &quot;设置行号set showcmd &quot;右下角显示输入命令set ruler &quot;显示当前行set autoindent &quot;自动缩进set cindent &quot;C风格缩进set noeb &quot;禁止响铃set tabstop=4 &quot;设置tab缩进4个格&quot;colorscheme desert &quot;颜色方案&quot;GCC编译函数&quot; %表示当前文件名 %:p表示当前文件完整路径&quot; %:p:r表示当前文件名完整路径并去除后缀名&quot; %&lt; 表示当前文件名func! CompileGcc() exec &quot;w&quot; let compilecmd=&quot;!gcc &quot; let compileflag=&quot;-g -Wall -o %:r&quot; if search(&quot;mpi\.h&quot;) != 0 let compilecmd = &quot;!mpicc &quot; endif if search(&quot;glut\.h&quot;) != 0 let compileflag .= &quot; -lglut -lGLU -lGL &quot; endif if search(&quot;cv\.h&quot;) != 0 let compileflag .= &quot; -lcv -lhighgui -lcvaux &quot; endif if search(&quot;omp\.h&quot;) != 0 let compileflag .= &quot; -fopenmp &quot; endif if search(&quot;math\.h&quot;) != 0 let compileflag .= &quot; -lm &quot; endif exec compilecmd.&quot; % &quot;.compileflagendfunc&quot;G++编译函数func! CompileGpp() exec &quot;w&quot; let compilecmd=&quot;!g++ &quot; let compileflag=&quot;-g -Wall -std=gnu++11 -o %:r &quot; if search(&quot;mpi\.h&quot;) != 0 let compilecmd = &quot;!mpic++ &quot; endif if search(&quot;glut\.h&quot;) != 0 let compileflag .= &quot; -lglut -lGLU -lGL &quot; endif if search(&quot;cv\.h&quot;) != 0 let compileflag .= &quot; -lcv -lhighgui -lcvaux &quot; endif if search(&quot;omp\.h&quot;) != 0 let compileflag .= &quot; -fopenmp &quot; endif if search(&quot;math\.h&quot;) != 0 let compileflag .= &quot; -lm &quot; endif exec compilecmd. &quot; % &quot;.compileflagendfuncfunc! RunPython() exec &quot;!python %&quot;endfuncfunc! CompileJava() exec &quot;!javac %&quot;endfuncfunc! CompileCode() exec &quot;w&quot; if &amp;filetype == &quot;cpp&quot; exec &quot;call CompileGpp()&quot; elseif &amp;filetype == &quot;c&quot; exec &quot;call CompileGcc()&quot; elseif &amp;filetype == &quot;python&quot; exec &quot;call RunPython()&quot; elseif &amp;filetype == &quot;java&quot; exec &quot;call CompileJava()&quot; endifendfuncfunc! RunResult() exec &quot;w&quot; if search(&quot;mpi\.h&quot;) != 0 exec &quot;!mpirun -np 4 ./%&lt;&quot; elseif &amp;filetype == &quot;cpp&quot; exec &quot;! ./%:r&quot; elseif &amp;filetype == &quot;c&quot; exec &quot;! ./%:r&quot; elseif &amp;filetype == &quot;python&quot; exec &quot;call RunPython&quot; elseif &amp;filetype == &quot;java&quot; exec &quot;!java %:r&quot; endifendfuncfunc! DEBUG() exec &quot;!gdb %:r&quot;endfuncmap &lt;F5&gt; :call CompileCode()&lt;CR&gt;imap &lt;F5&gt; &lt;ESC&gt;:call CompileCode()&lt;CR&gt;vmap &lt;F5&gt; &lt;ESC&gt;:call CompileCode()&lt;CR&gt;map &lt;F6&gt; :call RunResult()&lt;CR&gt;map &lt;F7&gt; :call DEBUG()&lt;CR&gt;&quot;将键盘上的F8功能键映射为添加作者信息的快捷键map &lt;F8&gt; ms:call AddAuthor()&lt;cr&gt;&apos;sfunction AddAuthor() let n=1 while n &lt; 5 let line = getline(n) if line =~&apos;^\s*\*\s*\S*Last\s*modified\s*:\s*\S*.*$&apos; call UpdateTitle() return endif let n = n + 1 endwhile call AddTitle()endfunction function UpdateTitle() normal m&apos; execute &apos;/* Last modified\s*:/s@:.*$@\=strftime(&quot;: %Y-%m-%d %H:%M&quot;)@&apos; normal &quot; normal mk execute &apos;/* Filename\s*:/s@:.*$@\=&quot;: &quot;.expand(&quot;%:t&quot;)@&apos; execute &quot;noh&quot; normal &apos;k echohl WarningMsg | echo &quot;Successful in updating the copy right.&quot; | echohl Noneendfunction function AddTitle() call append(0,&quot;/**********************************************************&quot;) call append(1,&quot; * Author : xie keyi&quot;) call append(2,&quot; * Email : xiekeyi98@snnu.edu.cn&quot;) call append(3,&quot; * Last modified : &quot;.strftime(&quot;%Y-%m-%d %H:%M&quot;)) call append(4,&quot; * Filename : &quot;.expand(&quot;%:t&quot;)) call append(5,&quot; * Description : &quot;) call append(6,&quot; * *******************************************************/&quot;) echohl WarningMsg | echo &quot;Successful in adding the copyright.&quot; | echohl Noneendfunction&quot;将插件文件分开，如果存在可读的.vimrc.bundles文件，把这个文件(插件文件)加载到下面if filereadable(expand(&quot;~/.vimrc.bundles&quot;)) source ~/.vimrc.bundlesendif vimrc.bundle12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061set nocompatible &quot; 去除VI一致性,必须要添加filetype off &quot; 必须要添加&quot; 设置包括vundle和初始化相关的runtime pathcall plug#begin() &quot;插件安装位置，默认是./.vim，括号内可传入字符串表示位置&quot; 以下范例用来支持不同格式的插件安装.&quot; 请将安装插件的命令放在plug#begin和plug#end之间.&quot; Github上的插件&quot; 格式为 Plugin &apos;用户名/插件仓库名&apos;Plug &apos;octol/vim-cpp-enhanced-highlight&apos; &quot;一个C++额外代码高亮插件&quot; 来自 http://vim-scripts.org/vim/scripts.html 的插件&quot; Plugin &apos;插件名称&apos; 实际上是 Plugin &apos;vim-scripts/插件仓库名&apos; 只是此处的用户名可以省略Plug &apos;wakatime/vim-wakatime&apos; &quot;记录工作时间插件 Plug &apos;vim-airline/vim-airline&apos; &quot;状态栏插件Plug &apos;vim-airline/vim-airline-themes&apos; &quot;状态栏皮肤Plug &apos;flazz/vim-colorschemes&apos; &quot; 配色合集Plug &apos;luochen1990/rainbow&apos; &quot; 彩虹括号Plug &apos;rhysd/vim-clang-format&apos; &quot; 代码格式化工具&quot; 由Git支持但不再github上的插件仓库 Plugin &apos;git clone 后面的地址&apos;&quot; 本地的Git仓库(例如自己的插件) Plugin &apos;file:///+本地插件仓库绝对路径&apos;&quot; 插件在仓库的子目录中.&quot; 正确指定路径用以设置runtimepath. 以下范例插件在sparkup/vim目录下&quot; 安装L9，如果已经安装过这个插件，可利用以下格式避免命名冲突&quot; 你的所有插件需要在下面这行之前call plug#end() &quot; 必须&quot; 忽视插件改变缩进,可以使用以下替代:&quot;filetype plugin onfiletype plugin indent on &quot; 必须 加载vim自带和插件相应的语法和文件类型相关脚本&quot;&quot; 常用的命令&quot; :PluginList - 列出所有已配置的插件&quot; :PluginInstall - 安装插件,追加 `!` 用以更新或使用 :PluginUpdate&quot; :PluginSearch foo - 搜索 foo ; 追加 `!` 清除本地缓存&quot; :PluginClean - 清除未使用插件,需要确认; 追加 `!` 自动批准移除未使用插件&quot;&quot; 查阅 :h vundle 获取更多细节和wiki以及FAQ&quot; 将你自己对非插件片段放在这行之后&quot;let c_no_curly_error=1 &quot;修复代码高亮的某个buglet g:airline#extensions#ale#enabled = 1 &quot;使用airline(状态栏)插件扩展ale(静态查错)&quot;使ale只在保存的时候才会检查错误let g:ale_lint_on_text_changed = &apos;never&apos;let g:ale_lint_on_enter = 0&quot; 开关彩虹括号let g:rainbow_active = 1 &quot;0 if you want to enable it later via :RainbowToggle]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[普通莫队学习]]></title>
    <url>%2Ff2a41e6f.html</url>
    <content type="text"><![CDATA[莫涛队长算法学习笔记(之前一直以为莫队是一种(莫氏)队列233) 简介 号称可以解决一切区间类问题的莫队算法。可以在\(O(n \sqrt{n})\)的复杂度内解决离线区间查询类问题。 其比线段树等数据结构的优越性在于可以处理一些不满足区间可加性的问题，如:区间众数等问题。 算法思路与实现 给出一个有n( n &lt; 30000 )个数的数列，每个数小于1e6。给出q次询问( q &lt; 200000 )，每次询问l到r有多少个不同的数？ (题目链接：SPOJ - D-query) 暴力O(n^2) 暴力做法很显然，即就是对于每一次查询，循环遍历整个区间，数一数数。 暴力代码12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;using namespace std ;const int maxn = 1000000 + 10 ;int a[maxn]; int main()&#123; int n ; cin &gt;&gt; n ; for( int i = 1 ; i &lt;= n ; i++) cin &gt;&gt; a[i]; int q; cin &gt;&gt; q ; while(q--) &#123; int l , r ; cin &gt;&gt; l &gt;&gt; r ; int cnt[maxn]; int ans = 0 ; memset( cnt , 0 , sizeof( cnt ) ) ; for( int i = l ; i &lt;= r ; i++) &#123; cnt[ a[i] ]++; if( cnt[ a[i] ] == 1 ) ans++; &#125; cout &lt;&lt; ans &lt;&lt; endl ; &#125; return 0 ;&#125; 换种方式的暴力 我们把暴力方法进行修改，就是换种写法。但是我们上面的做法是每次都是从L循环到R，这一次我们尝试着的是从上一次的查询位置，调整到这一次的查询位置。 也就是说，如果上一次查询是[1,5]，这一次的查询范围是[2,4]。下一次我们将尝试从[1,5]的答案，调整转移到[2,4]的答案。如何转移呢？也就是说我们先考虑左端点，我们把左端点要从1移动到2，那么就要删除1这个元素。右端点我们要从5调整到4，也就是要删除第5个元素。 我们就是这样不断调整到这一次的查询上。 当然，我们会发现这种方法和上一种方法相比，没有什么更优(除了一些常数差异) 换种暴力12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;using namespace std ;const int maxn = 1000000 + 10 ;int a[maxn];int cnt[maxn];int ans = 0 ; void add( int pos ) &#123; cnt[ a[pos] ]++; if( cnt[ a[pos] ] == 1 ) ans++;&#125; void remov( int pos )&#123; cnt[ a[pos] ]--; if( cnt[ a[pos] ] == 0 ) ans--;&#125; int main()&#123; int n ; cin &gt;&gt; n ; for( int i = 1 ; i &lt;= n ; i++) cin &gt;&gt; a[i]; int q; cin &gt;&gt; q ; int l = 0 , r = 0 ; while(q--) &#123; int ll , rr ; cin &gt;&gt; ll &gt;&gt; rr ; while( l &lt; ll ) remov(l++); while( l &gt; ll ) add(--l); while( r &lt; rr ) add(++r); while( r &gt; rr ) remov(r--); cout &lt;&lt; ans &lt;&lt; endl ; &#125; return 0 ;&#125; 莫涛队长算法 莫队算法相比我们换种方式的暴力，仅仅是调整了每一次查询的顺序(离线处理)。我们现在有q个查询，将把查询进行一些调整后再处理。 具体的调整是： 我们将给定的数组的n个元素进行分块，分成\(\sqrt{n}\)块，每一块内有元素\(\sqrt{n}\)块。 显然左右端点都会落入某一块中，我们考察左端点所在的块号，按照块号从小到大进行排序(第一关键字)。 在每一块内，我们按照r端点从左到右进行排序(第二关键字)。 如此，我们便完成了莫涛队长算法。核心仅仅在于调整了查询的顺序，变成了优雅地暴力。 ACcode12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;bits/stdc++.h&gt;using namespace std ;const int maxn = 300000 + 100 ;const int maxm = 1000000 + 10 ;int a[maxn];int cnt[maxm];int ans = 0 ; int BLOCK = 0 ; inline void add( int pos ) &#123; cnt[ a[pos] ]++; if( cnt[ a[pos] ] == 1 ) ans++;&#125; inline void remov( int pos )&#123; cnt[ a[pos] ]--; if( cnt[ a[pos] ] == 0 ) ans--;&#125; struct QUERY&#123; int l , r , num ;&#125;Q[maxn]; int ANS[maxn];inline bool cmp( const QUERY &amp;a , const QUERY &amp;b )&#123; if( a.l / BLOCK != b.l / BLOCK ) return a.l / BLOCK &lt; b.l / BLOCK ; else return a.r &lt; b.r ;&#125; int main()&#123; int n ; cin &gt;&gt; n ; for( int i = 1 ; i &lt;= n ; i++) scanf("%d",&amp;a[i]); int q; scanf("%d",&amp;q); for( int i = 1 ; i &lt;= q ; i++) &#123; int l , r ; scanf("%d%d",&amp;l,&amp;r); Q[i].l = l , Q[i].r = r , Q[i].num = i ; &#125; BLOCK = sqrt(n); sort( Q + 1 , Q + 1 + q , cmp ) ; int l = 0 , r = 0 ; for( int i = 1 ; i &lt;= q ; i++) &#123; int ll = Q[i].l , rr = Q[i].r; while( l &lt; ll ) remov(l++); while( l &gt; ll ) add(--l); while( r &lt; rr ) add(++r); while( r &gt; rr ) remov(r--); ANS[Q[i].num] = ans ; &#125; for( int i = 1 ; i &lt;= q ; i++) printf("%d\n",ANS[i]); return 0 ;&#125; 时间复杂度的证明 我们先考虑左指针如何移动。对于每个块，所有查询都落在同一个块内，每次查询，左指针都会在块内进行移动，移动范围不超过\(\sqrt{N}\)。Q次询问，则复杂度为\(O( Q * \sqrt{N})\) 我们在考虑右指针如何移动。对于每个块内，右端点递增排序，右指针最多移动N次(可能从上一个块查询到整个数列的最末端再移动到当前块的最前端，但这依然不过是2N次)，一共有\(\sqrt{N}\)个块，所以复杂度最多为\(O( N * \sqrt{N} )\)次 总复杂度: \[ O( Q * \sqrt{N} + N * \sqrt{N} ) = O( N * \sqrt{N} ) \] 总结 莫队算法可以解决的是由[l,r]区间的答案可以很方便的转移到[l+1,r] , [l-1,r],[l,r+1],[l,r-1]等范围的答案(通常上是O(1)转移，也可O(logn)转移，此时复杂度多一个logn)。 之所以博客叫普通莫队，是因为莫队还有带修改莫队，树上莫队等等... 据说有通过合理调整分块大小，可以解决n和m不同的情况。 &gt; 莫队复杂度为\(O(n\sqrt{n} + n\sqrt{m})\)，不过在这情况下，分块需要调整为$ $ 参考资料 MO’s Algorithm (Query square root decomposition) 知乎 - 莫队时间分块复杂度到底怎么算？ 知乎 - 传说中能解决一切区间处理问题的莫队算法是什么？ 第一个参考资料非常好，可惜是英文的qwq.]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU6319-Ascending Rating]]></title>
    <url>%2Fc7f5271b.html</url>
    <content type="text"><![CDATA[题意：对于一个数列(7e7)，求出所有长度为m的区间中，区间最大值和i的异或和以及区间内递增序列(最大值变换次数)的值的异或和。 做法 单调队列处理区间最大值 单调队列。对于各种区间内的最大值，可以很容易的使用单调队列得到,或者说，这是利用单调队列实现一种滑动窗口的思想。(一直感觉单调队列就像是一种尺取(双指针扫描)的感觉) 比较简单，看一眼基本就会操作了。等于时时刻刻维持着这个队列内存放的数字都是单调递减的样子。 123456789101112131415161718192021222324//取得对于所有n个数字，区间范围为m的，所有区间的最大值void getmax( int n , int m )&#123; //q一开始写的是deque。 q.clear(); for( int i = 1 ; i &lt;= n ; i++) &#123; // 如果当前进来的数字比队尾存在的数字大， // 那么就把队尾元素弹出，循环操作，直到不满足条件。 while( !q.empty() &amp;&amp; a[q.back()] &lt;= a[i] ) q.pop_back(); // 插入当前元素 q.push_back(i); // 队列中没有m个数字的时候，继续执行，保证得到的是 // 包含完整的一个区间的情况 if( i &lt; m ) continue ; // 如果当前的队首过期，即就是窗口滑动出去，队首已经不在当前区间了，pop while( q.front() &lt; i - m + 1 ) q.pop_front(); // 队首即为当前区间的最大值 maxnum.push_back(a[q.front()]); &#125;&#125; 单调队列处理区间内递增序列 这个感觉还是挺花的操作的。 但是其实思想还是用到了我之前说的：单调队列是维护了一个内部单调递减的队列。所以我们发现，我们只要倒着跑，就可以实现单调队列内当前存在的元素个数，就是我们的单调递增序列长度。 12345678910111213141516void getcount( int n , int m )&#123; q.clear(); for( int i = n ; i &gt;= 1 ; i--) &#123; while( !q.empty() &amp;&amp; a[q.back()] &lt;= a[i] ) q.pop_back(); q.push_back(i); if( i &gt; n - m + 1 ) continue ; while( q.front() &gt; i + m - 1 ) q.pop_front(); maxcount.push_back( q.size() ) ; &#125;&#125; 基本思想和刚才很像，只是反着(从n到1跑了一次)。但是我在这里卡了很久，不太明白为什么要倒着跑？不倒着跑行不行？ 当我用铅笔在纸上来来回回之后，发现确实是酱紫才行呢。 首先我们来看倒着跑：倒着跑的正确性是显然的。我们之前正着来的时候，就会发现队首一直是最大值。我们也只用到了这个性质。但是我们再进一步观察队列内的元素，会发现队列内的元素其实就是从当前的队首开始到下一个比队首大的值之前的最长单调递减序列(话有点绕)。因此，我们倒着跑，就恰好保证了是从最大值开始的反向最长递减序列，也就是我们最长的递增序列到最大值，也就是答案所要求的。 其次，我们再考虑为什么要倒着跑？那是因为我们观察发现，优先队列只能处理队首是一个最值、队列内的元素个数就是从这个最值到下一个最值之间的最长单调序列。 所以，如果我们假设队首存的是最小值，那么只能得到该最小值开始的最长递增序列。反之只能得到从最大值开始的最长递减序列。 因此不行。 所以我们要注意这种反着跑的方法和思路 注:部分地方存在「极小值」和「最小值」，「极大值」和「最大值」混用的情况。 据说这道题卡常挺严重的，看到很多题解都用scanf``printf和手写队列，不用STL等方法卡常。 我一开始也以为自己被卡常了，所以一开始的deque改成了queue，为了不改那么多，于是写了个class来保证接口(o(╯□╰)o) 最后发现竟然只是mod次数太多了！我不应该在生成数列的时候，每一项都mod，改了就A了。队友写的cin``cout等，也能A。 完整AC代码： ACcode123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include&lt;bits/stdc++.h&gt;using namespace std ;using ll = long long ;const int maxn = 70000000 + 100 ;ll a[maxn];vector&lt;ll&gt; maxnum;vector&lt;ll&gt; maxcount;class que&#123; public: int aa[maxn]; int tail = 0 , head = 0 ; bool empty() &#123; return tail &lt;= head ; &#125;; void pop_back()&#123; --tail; &#125;; int back()&#123; return aa[tail - 1 ] ; &#125; ; int front()&#123; return aa[head]; &#125;; void push_back(int i )&#123; aa[tail++] = i ;&#125;; void pop_front()&#123; ++head; &#125;; void clear()&#123; tail = 0 , head = 0 ;&#125; ; int size()&#123; return tail - head ; &#125;;&#125;q;void getmax( int n , int m )&#123; q.clear(); for( int i = 1 ; i &lt;= n ; i++) &#123; while( !q.empty() &amp;&amp; a[q.back()] &lt;= a[i] ) q.pop_back(); q.push_back(i); if( i &lt; m ) continue ; while( q.front() &lt; i - m + 1 ) q.pop_front(); maxnum.push_back(a[q.front()]); &#125;&#125;void getcount( int n , int m )&#123; q.clear(); for( int i = n ; i &gt;= 1 ; i--) &#123; while( !q.empty() &amp;&amp; a[q.back()] &lt;= a[i] ) q.pop_back(); q.push_back(i); if( i &gt; n - m + 1 ) continue ; while( q.front() &gt; i + m - 1 ) q.pop_front(); maxcount.push_back( q.size() ) ; &#125;&#125;int main()&#123;// ios::sync_with_stdio(false);// cin.tie(0); int t ; scanf("%d",&amp;t); //cin &gt;&gt; t ; while(t--) &#123; maxnum.clear(); maxcount.clear(); ll n,m,k,p,q,r,MOD; scanf("%lld%lld%lld%lld%lld%lld%lld",&amp;n,&amp;m,&amp;k,&amp;p,&amp;q,&amp;r,&amp;MOD); //cin &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; p &gt;&gt; q &gt;&gt; r &gt;&gt; MOD; for( int i = 1 ; i &lt;= k ; i++) scanf("%lld",&amp;a[i]); //cin &gt;&gt; a[i]; for( int i = k + 1 ; i &lt;= n ; i++) a[i] = (p* a[i-1]+q*i+r) % MOD; getmax(n,m); getcount(n,m); reverse(maxcount.begin() , maxcount.end() ) ; long long ansa = 0 , ansb = 0 ; for( int i = 0 ; i &lt; n - m + 1 ; i++) &#123; ansa += maxnum[i] ^(i+1); ansb += maxcount[i] ^ ( i+1) ; &#125; printf("%lld %lld\n" , ansa , ansb ) ; //cout &lt;&lt; ansa &lt;&lt; ' ' &lt;&lt; ansb &lt;&lt; endl ; &#125; return 0 ;&#125; 参考资料 HDU 6319 Ascending Rating（单调队列）]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[归并排序及求逆序对]]></title>
    <url>%2F131f1863.html</url>
    <content type="text"><![CDATA[归并排序O(nlogn)及归并排序求逆序对数 归并排序及求逆序对 归并排序是一个以O(nlogn)时间复杂度进行排序的高级排序算法(相比较O(n^2)的低级排序来说)。以前只知道归并排序是一个可以并发的，可以用来进行外排序的算法，也知道它可以用来求逆序对。但是因为ACM中感觉平时使用快速排序就够了，求逆序对也可以使用权值线段树来做，所以对这个算法没有太在意。 今天看到了一道题，权值线段树开起来内存不够，也很代码量也有点大，于是今天学习了一下归并排序。看到代码发现非常好理解啊(当然我一次没写对233) 归并排序，简单的来说就是利用分治法，不断的把数组分到最小情况，然后再逐步向上合并。这里看起来有一点点像线段树的意思。 具体的看代码注释吧。 至于求逆序对，在归并排序的合并过程中，很容易发现每当我们将一个数字加入到临时数组中，都可以知道这个数字前面有多少个比它大的数字。这是因为我们合并的是两个相邻的数组，且这两个被合并的数组都是有序的。那么如果两个相邻的数组中，后面的数组的某个数字加入到了临时数组中，且前面的那个数组当前的数比被加入的这个数字大，那么可以知道前面的数组当前的数及其后面的所有数字都比被加入的这个数字大。 那么这时候我可以记录更新逆序对数。 code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;bits/stdc++.h&gt;using namespace std ;const int maxn = 10;int a[maxn]; // 排序数组int t[maxn]; // 排序过程中所需要临时数组void merge( int l ,int m , int r )&#123; // i是左半部分指针，j是右半部分指针，k是临时数组指针 // k可以是0的，这里是l只是方便后来的将t数组移动到a数组中不需要转换下标 int i = l , j = m+1, k = l ; //进行合并操作，全部合并到临时数组t里面 while( i &lt;= m &amp;&amp; j &lt;= r ) &#123; if( a[i] &gt; a[j] ) &#123; t[k++] = a[j++]; // ans += m - i + 1 ; // 这里选择了后面的数组(即就是[m+1,r]部分，由j指向) // 那么可以知道[i,m]都是比a[j]大的。 // 且[i,m]的下标都比j小 // 所以a[i...m]和a[j]都是逆序对 &#125; else &#123; t[k++] = a[i++] ; &#125; &#125; //将剩下没有合并的数组直接扔到末尾 while( i &lt;= m ) t[k++] = a[i++]; while( j &lt;= r ) t[k++] = a[j++]; // 放回原数组 for( int i = l ; i &lt;= r ; i++) a[i] = t[i];&#125;void merge_sort( int l , int r )&#123; if( l &lt; r ) &#123; int m = ( l + r ) / 2 ; // 先递归下去再进行合并 merge_sort( l , m ) ; merge_sort( m + 1 , r ); merge( l , m , r ) ; &#125;&#125;int main()&#123; for( int i = 1 ; i &lt;= 10 ; i++) a[i] = i ; for( int i = 1 ; i &lt;= 10 ; i++) cout &lt;&lt; a[i] ; cout &lt;&lt; endl ; merge_sort( 1 , 10 ) ; for( int i = 1 ; i &lt;= 10 ; i++) cout &lt;&lt; a[i] ; cout &lt;&lt; endl ;&#125; 参考资料： 归并排序-求逆序数算法]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>逆序对</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO-3.2.4-ratios]]></title>
    <url>%2Fe2a2174b.html</url>
    <content type="text"><![CDATA[题意：给出3个比例为x:y:z的原料，要求配出i:j:k的产品，问每个原料和产品最终所用之比是多少？ 枚举 直接枚举需要原料ijk就行了(因为题意中说了每个原料所用不超过100,所以100100100可以过)。 WA了好几次o(╥﹏╥)o 一开始WA是没注意到原料可能为0，有的没用。 第二次WA是我一开始“默认”给出的产品之比肯定是最简比，所以在枚举原料后，全部除以了最大公约数。结果发现数据中 有不是最简整数比的…… 第三次是我开局就把产品化成了最简整数比，但是在产品有0的时候，又出现了奇奇怪怪的情况。 代码越改越不知道自己写的是个什么东西了…… 最后看了下别人的做法，发现很巧妙的两行。(见代码注释) code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/*ID:xiekeyi1PROG:ratiosLANG:C++11*/#include&lt;bits/stdc++.h&gt;using namespace std ;const int inf = 0x7fffffff;int a[10][10];int gcd( int x , int y ) &#123; if( y == 0 ) return x ; else return gcd( y , x % y) ;&#125;int main()&#123; bool succ = false ; freopen("ratios.in","r",stdin); freopen("ratios.out","w",stdout); // a[1]表示三个产品，a[2..4]表示三个原料 for( int i = 1 ; i &lt;= 4 ; i++) cin &gt;&gt; a[i][1] &gt;&gt; a[i][2] &gt;&gt; a[i][3] ; int x , y , z ; int ans_total = inf , ans1 = inf , ans2 = inf , ans3 = inf , ans4 = inf ; for( int i = 0 ; i &lt;= 100 ; i++) &#123; for( int j = 0 ; j &lt;= 100 ; j++) &#123; for( int k = 0 ; k &lt;= 100 ; k++) &#123; x = a[2][1] * i + a[3][1] * j + a[4][1] * k; y = a[2][2] * i + a[3][2] * j + a[4][2] * k ; z = a[2][3] * i + a[3][3] * j + a[4][3] * k ; int temp_total = i+j+k ; int t = -1; // 这三个if很巧妙，避免了0的问题，也能很好的除出来t if( x != 0 &amp;&amp; a[1][1] != 0 ) t = x / a[1][1] ; else if( y != 0 &amp;&amp; a[1][2] != 0 ) t = y / a[1][2]; else if( z != 0 &amp;&amp; a[1][3] != 0 ) t = z / a[1][3] ; // if中用乘法判断，也是巧妙的避免了0的问题。 if( a[1][1] * t == x &amp;&amp; a[1][2] * t == y &amp;&amp; a[1][3] * t == z &amp;&amp; temp_total &lt;= ans_total ) &#123; ans1 = i , ans2 = j , ans3 = k , ans4 = t ; ans_total = temp_total; succ = true ; &#125; &#125; &#125; &#125; if( succ ) cout &lt;&lt; ans1 &lt;&lt; ' ' &lt;&lt; ans2 &lt;&lt; ' ' &lt;&lt; ans3 &lt;&lt; ' ' &lt;&lt; ans4 &lt;&lt; endl ; else cout &lt;&lt; "NONE" &lt;&lt; endl ; return 0 ;&#125; 克拉姆法则/高斯消元 QAQ不会高斯消元。。克拉姆法则明天起来再看看好了……]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>USACO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO-3.2.3-Spinning Wheels]]></title>
    <url>%2Fa0f3a879.html</url>
    <content type="text"><![CDATA[模拟 题意：给出5个轮子，每个轮组有w个缺口(\(1 \leq w \leq 5\)) 问多少分钟后会有一个缺口从头对到尾 一开始题意理解错了，以为给出的缺口是角度x到角度y，后来才知道是角度x到角度x加上角度y。 这道题本身没什么复杂的。 只要注意取模360，然后check的时候统计某个点被统计的次数，如果是5，即是答案。 感觉这道题难点在于时间复杂度。就像自己经常在考场上，想到了正解，觉得太简单了应该想错了吧导致不敢写。 以后不管怎么说，但是要敢写试试。大不了T了嘛。 code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/*ID:xiekeyi1PROG:spinLANG:C++11*/#include&lt;bits/stdc++.h&gt;using namespace std ;int speed[10];int a[10][400];int timing = -1 ;bool judge()&#123; int jj[400]; memset( jj , 0 , sizeof(jj) ) ; for( int i = 1 ; i &lt;= 5 ; i++) &#123; for( int j = 0 ; j &lt; 360 ; j++) &#123; //jj[i]表示对于当前秒，角度j被覆盖了jj[i]次 if( a[i][j] ) jj[ ( j + speed[i] * timing ) % 360 ]++; &#125; &#125; for( int i = 0 ; i &lt; 360 ; i++) &#123; if( jj[i] == 5 ) return true ; &#125; return false ;&#125;int main()&#123; freopen("spin.in","r" ,stdin); freopen("spin.out","w",stdout); for( int i = 1 ; i &lt;= 5 ; i++) &#123; int t ; cin &gt;&gt; speed[i] &gt;&gt; t ; for( int j = 1 ; j &lt;= t ; j++) &#123; int x , e ; cin &gt;&gt; x &gt;&gt; e ; //a[i][j]表示第i个轮子的角度j有缺口。 for( int k = x ; k &lt;= x + e ; k++) a[i][k % 360 ] = 1 ; &#125; &#125; while( ++timing &lt;= 1200) &#123; if( judge() ) &#123; cout &lt;&lt; timing &lt;&lt; endl ; return 0 ; &#125; else if( timing &gt;= 1000 ) &#123; cout &lt;&lt; "none" &lt;&lt; endl ; return 0 ; &#125; &#125; return 0 ;&#125; 时间复杂度的计算: 首先因为速度是1以上，所以每隔360个时间单位，肯定会出现每个人都最少出现了一个周期。 对于check一次的情况，需要的最坏情况是555*5(5个轮子，每个轮子5个缺口）。 所以复杂度上很显然是足够的。]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>USACO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[travis-ci与codecov测试和测试覆盖度工具的使用]]></title>
    <url>%2F5e7bc721.html</url>
    <content type="text"><![CDATA[travis-ci和codecov测试工具的使用。 (未完待续，视后续使用情况补充更新) 今年参加了thoughtworks的线下结对编程体验活动。说来找了好多个网站都没有找到这个活动的详细信息，只有一些通知、公告和颁奖新闻。 终于在google找到了thoughtworks结对编程体验的一篇文章，碰巧还是去年一等奖。参考了他的历程和项目代码后，发现他使用了maven做项目管理，使用travis-ci做单元测试。 说来也是在这个研究过程中才发现，原来configure和makefile是有很多自动生成工具的(qmake、autotools等)，我一直以为是要手写的。 发现这个travis-ci，就是我一直很好奇的部分项目的测试贴纸。加上自己需要，所以简单学习了一下。 travis-ci travis-ci 是一个支持多平台、集成、持续的测试工具，这类工具其实有很多，这个是市场份额占的最大的。 个人公开仓库免费(私人仓库等我不太了解)，貌似必须和github一起使用才可以。 使用起来非常简单，只要注册账号，和github关联，然后在自己对应的项目中打开就可以。 打开以后，只要在自己的项目中添加.travis.yml文件，即可在每次push的时候，自动进行测试。 网上很多关于这个文件如何写的，都是php、js等语言，少量java、python，对于C++几乎没有。索性读了下文档，发现简单使用还是很简单的。 踩到的坑: 官方样例中只要写language: C++即可运行，但是实际上，那样默认的构建命令是./configure &amp;&amp; make &amp;&amp; make test 这样的话，我还研究了半天如何写configure，但是实际上，只要人工修改构建命令即可 给一下我的简单范例: 1234sudo: true #是否使用sudo命令执行language: C++script: - make 只要这么几句，就可以在每次运行的时候，执行测试了。不过这个测试只是执行了make，有进一步需求的话，可以在scrpit里，加入一个写好的bash，bash中运行自己的单元测试。 之后每次push的时候，就会在travis-ci的网站中的profile和github里的commit里看到测试结果。 如果需要贴纸的话，只要在profile里点击那个图标，即可得到markdown信息，加到readme里即可。 codecov codecov这是一个用来表示测试覆盖的代码有百分之多少的工具。使用起来，一开始看到别的教程，以为只需要在travis-ci中添加几句就可以，实际使用起来发现挺麻烦的。 截止目前，我并没有成功使用这个工具。 使用这个工具，大概需要安装codecov环境，并且使用gcov生成覆盖率测试文件。 因为使用样例给的是使用qmake，我自己一直手写makefile，所以暂时还没有成功使用。 具体请看参考资料。 参考资料 Travis CI Docs codecov documentation GCOV的使用-测试代码覆盖率 Travis CI 系列：自动化部署博客 持续集成服务 Travis CI 教程 Github装逼指南——Travis CI 和 Codecov]]></content>
      <categories>
        <category>工程</category>
      </categories>
      <tags>
        <tag>工程</tag>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces #486(Div.3) CF988D Points and Powers of Two]]></title>
    <url>%2Ff4a229d0.html</url>
    <content type="text"><![CDATA[题意: 给出n个数字，找出这n个数字的一个子集，使得子集中任意两两(包括自己和自己)相减的数字，都是2的非负次幂。 题目链接:http://codeforces.com/contest/988/problem/D 错误想法 1234567for( 遍历元素 a[i] = a[1] to a[n] ) delta = 0 while( delta &lt;= MAXN ) if( 二分查找到( a[i] + delta ) ) 记录 a[i] + delta . dleta = ( delta == 0 ) ? 1 : delta * 2 维护最大值 时间复杂度: \(O(n* logMAXN * logn )\) WA在6上，一开始以为是MAXN开的不够大（第一次开了2e5），结果改到2e9后，反而WA1了。后来发现，这个思路根本不对，因为无法保证，任意两两相减的数字，都是2的非负次幂。 正确做法 有一个结论:这样的数组最多只会有3个 简单证明： 对于只有一个数字\(a\)的情况，显然成立。\(( a-a = 0 = 2^0 )\) 对于只有两个数字\(a，b\)的情况，只会有： \(( b - a = 2^x )\) 对于只有三个数字\(a,b,c,\)的情况: 则有 \(b - a = 2^x , c - b = 2^y\)，因为题目要求任意两两相减都要是2的非负次幂。所以显然应该有\(c - a = 2^z = 2^x + 2^y\) ，而只有\(x = y\)的时候，这个情况才成立 (考虑一下2的非负次幂的二进制表达，如果\(x!=y\)，那么二进制表达应该是有两位，就不能被表示成一个2的非负次幂的情况了，而是两个2的非负次幂相加) 所以三个数的情况，一定是\([a - x , a , a + x]\) 其中x是某个2的次幂。 那么对于四个数字\(a,b,c,d\)的情况，\(d - c\)是2的非负次幂，\(c - a\)也是2的非负次幂，那么\(d-a\)显然会是两个不同的二的次幂相加得到(假如对于这种情况，是两个相同的二的次幂，那么同样的情况，换几个选择，肯定又会是不同的二的次幂相加的情况。所以不能成立)。 对于数字大于4的情况，因为他包含了是任意两两相减都要满足情况，肯定包含了$ n 4$的情况，所以大于4都不行。 有了这个结论以后，我们只要稍微改动一下，当得到3个数字的结果就退出，对于1和2的情况，都分别处理一下即可。 ACcode12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;bits/stdc++.h&gt;using namespace std ;int n ;int cnt_ans = 0 ;vector&lt;long long &gt; a ;vector&lt;long long &gt; ans ; int main()&#123; cin &gt;&gt; n ; for( int i = 1 ; i &lt;= n ; i++) &#123; int t ; cin &gt;&gt; t ; a.push_back(t); &#125; sort( a.begin() , a.end()) ; long long delta = 1ll ; for( int i = 0 ; i &lt; n ; i++) &#123; delta = 1ll ; while( delta &lt;= 2000000000ll) &#123; int t = 1 ; vector&lt;long long &gt; tt ; tt.push_back(a[i]); if( binary_search( a.begin() , a.end(), a[i] + delta ) ) &#123; t++; tt.push_back( a[i] + delta ) ; &#125; if( binary_search( a.begin() , a.end(), a[i] - delta ) ) &#123; t++; tt.push_back(a[i]-delta); &#125; delta *= 2ll ; if( t &gt; cnt_ans ) &#123; cnt_ans = t ; ans = tt ; &#125; if( cnt_ans == 3 ) &#123; cout &lt;&lt; cnt_ans &lt;&lt; endl ; for( auto i : ans ) cout &lt;&lt; i &lt;&lt; ' ' ; cout &lt;&lt; endl ; return 0 ; &#125; &#125; &#125; cout &lt;&lt; cnt_ans &lt;&lt; endl ; for( auto i : ans ) cout &lt;&lt; i &lt;&lt; ' ' ; cout &lt;&lt; endl ; return 0 ;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>codeforces</tag>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 486 Div.3 CF988C Equal Sums]]></title>
    <url>%2F5aa8be3b.html</url>
    <content type="text"><![CDATA[题意: 给出k个数列，要求选出任意两个数列i和j，使得第i个数列减去第n个数的和，等于第j个数列减去第m个数的和。求i、j、nn、m。 题目链接:http://codeforces.com/contest/988/problem/C 错误想法 统计所有数列的和(a[i].value表示第i个数列的和是多少)，枚举两个数列(i、j)，枚举第i个数列的每个数字n。那么我们就确定了四个所求数中的三个，对于第四个数m进行二分即可。 \[ a[i].value - n == a[j].value - m \] 123456for( 数列 i = 1 to k ) for( 数列 j = 1 to i ) for( 元素 n = 1 to a[i].size() ) 二分查找a[j]中是否存在m( m == a[j].value - a[i],value + n ) 找到了输出YES.输出NO 算法复杂度: \(O(k^3*logn)\) 一开始考虑到这个肯定过不了，不过无意间看到保证所有数据元素加起来不超过\(2e5\)个，不知道怎么脑子抽了就写了。 但是实际上显然不能过的，只要每个数列一个数字，直接将近\(4e10\)，TLE是肯定的。 写了以后疯狂Wrong Answer.... TLE我也就接受了。应该是正常的，然而疯狂WA是怎么一回事。 查了两三天的错，主要的问题是: - 二分没有排序！ (这问题,orz) - 排序后，某下标错了…… WRONGANSWER1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;bits/stdc++.h&gt;using namespace std ;const int maxn = 2e5 + 10 ; // 一种HACK手法，用于将CODEFROCES大数据不能看全的时候，远程输出一些数据。//#define DEBUGstruct node&#123; vector&lt; pair&lt; long long , int &gt; &gt; e ; long long value = 0 ; int n = 0 ; int pos = 0 ; &#125;a[maxn];int main()&#123; ios::sync_with_stdio(false); cin.tie(0); int k ; cin &gt;&gt; k;#ifdef DEBUG int debug_1 , debug_2 ;#endif for( int i = 1 ; i &lt;= k ; i++) &#123; cin &gt;&gt; a[i].n; a[i].pos = i ; for( int j = 1 ; j &lt;= a[i].n ; j++) &#123; long long t ; cin &gt;&gt; t ; a[i].e.push_back(make_pair( t , j )); a[i].value += t ;#ifdef DEBUG if( i == 99 &amp;&amp; j == 418 ) debug_1 = t ; if( i == 128 &amp;&amp; j == 226 ) debug_2 = t ; #endif &#125; &#125; sort( a + 1 , a + 1 + k , [](const node &amp;a , const node &amp;b ) &#123; return a.value &lt; b.value ; &#125; ) ; // 二分需要排序！ for( int i = 1 ; i &lt;= k ; i++) sort( a[i].e.begin() , a[i].e.end() ) ; for( int i = 2 ; i &lt;= k ; i++) &#123; for( int j = 1 ; j &lt; i ; j++) &#123; for( int kk = 0 ; kk &lt; a[i].e.size() ; kk++) &#123; // 这个pair类型，这样查找不确定是否合适 auto iter = lower_bound( a[j].e.begin() , a[j].e.end() , make_pair(a[j].value - a[i].value + a[i].e[kk].first,1) ) ; if( iter == a[j].e.end() ) continue; else if( a[i].value - a[i].e[kk].first == a[j].value - iter-&gt;first ) &#123; cout &lt;&lt; "YES" &lt;&lt; endl ; cout &lt;&lt; a[i].pos &lt;&lt; ' ' &lt;&lt; a[i].e[kk].second &lt;&lt; endl ; cout &lt;&lt; a[j].pos &lt;&lt; ' ' &lt;&lt; iter-&gt;second &lt;&lt; endl ;#ifdef DEBUG if( k == 400 ) &#123; cout &lt;&lt; a[i].value &lt;&lt; ' ' &lt;&lt; a[j].value &lt;&lt; endl ; cout &lt;&lt; a[i].e[kk].first &lt;&lt; ' ' &lt;&lt; a[i].e[kk].second &lt;&lt; endl; cout &lt;&lt; iter-&gt;first &lt;&lt; ' ' &lt;&lt; iter-&gt;second &lt;&lt; endl ; cout &lt;&lt; debug_1 &lt;&lt; ' ' &lt;&lt; debug_2 &lt;&lt; endl ; &#125;#endif return 0 ; &#125; &#125; &#125; &#125; cout &lt;&lt; "NO" &lt;&lt; endl ; return 0 ;&#125; 和空气斗智斗勇 感觉自己问题出在，想到了一个简单的不行的结论，就以为get到了这道题的trick，然后就非常兴奋的撞了上去越陷越深。 正确做法 123map&lt; 去掉一个数后的和 , pair&lt;第一次出现这个和的时候的数列，第一次出现这个和的时候的数列元素位置 &gt; &gt; 只要遍历每一个数字，当这个数字在map中没有出现过的时候，放入这样一个map中，当这个数字在map中出现了的时候，输出map中记录的第一次出现的位置和当前位置即可。 时间复杂度:\(O(k*logn)\) ACcode1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;using namespace std ;const int maxn = 2e5 + 10 ; map&lt; int , pair&lt;int , int &gt; &gt; mp ;struct node&#123; vector&lt;int &gt; e ; int value = 0 ; int n = 0 ; &#125;a[maxn];int main()&#123; int k; cin&gt;&gt; k ; for( int i = 1 ; i &lt;= k ; i++) &#123; cin &gt;&gt; a[i].n; for( int j = 1 ; j &lt;= a[i].n ; j++) &#123; int t; cin &gt;&gt; t ; a[i].e.push_back(t); a[i].value += t ; &#125; &#125; for( int i = 1 ; i &lt;= k ; i++) &#123; for( int j = 0 ; j &lt; a[i].e.size() ; j++) &#123; if( mp[ a[i].value - a[i].e[j] ].first == 0 ) &#123; mp[ a[i].value - a[i].e[j] ] = make_pair( i , j + 1 ) ; &#125; else if( mp[ a[i].value - a[i].e[j] ].first != i ) &#123; cout &lt;&lt; "YES" &lt;&lt; endl ; cout &lt;&lt; mp[a[i].value - a[i].e[j] ].first &lt;&lt; ' ' &lt;&lt; mp[a[i].value - a[i].e[j] ].second &lt;&lt; endl ; cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; j + 1 &lt;&lt; endl ; return 0 ; &#125; &#125; &#125; cout &lt;&lt; "NO" &lt;&lt; endl ; return 0 ;&#125; 总结 以后对于这种出现两次，要找一对的情况之类的，可以考虑先存一下第一次出现的时候的情况，然后第二次出现的时候直接输出。]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>codeforces</tag>
        <tag>思维</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces edu.44 985C Liebig's Barrels]]></title>
    <url>%2Ff70cdf0b.html</url>
    <content type="text"><![CDATA[题目链接: http://codeforces.com/contest/985/problem/C 题目大意：给出n,k,l。接下来给出n*k块木板。k块木板可以做成一个木桶，一共要做n个木桶。木桶体积为最短的木板长度。最大的木桶的体积和最小的木桶体积不能超过l。求所能做成的木桶最大的面积之和。不能做出n个木桶则输出0. 场上想法 赛场上觉得，排序后看最小值+l所在的位置是否大于等于n，是则输出前n个之和，否则输出0即可。 结果发现这样太蠢了。因为这样显然不会是最大的。后来赛场上又在想，是否是前面的都是尽可能相邻k个一拼，最后相邻k个且满足减去l小于等于a[1]的，找这样的尽可能大的加起来就可以。 这也是错的！ 补题想法 感觉能摸到一点边了，但是还是想了好久才明白。 先排序，我们要分三种情况讨论(记数字a[1] + l范围内的最大值的位置为pos，pos可用upper_bound得到) : 如果pos \(\le\)n ，显然不满足条件。(无论怎么选，都会使a[1]+l的限制条件被破坏) 如果pos \(\geq\)n , 并且pos - k \(\geq\) n - 1 ，即就是选取了相邻的k个数(这是最好的局部策略，因为以这k个数中最小的数字为代价，把其他k-1个数字都控制住了)，且剩下的数字依然满足最坏条件(即剩下的数字每个都属于剩下不同的木桶)。 如果pos \(\geq\)n，并且不满足\(pos-k \geq n-1\)，则剩下的每个数字都要组成不同的木桶。将他们加起来即可。 这就是做法。 今天对第三个条件想了很久，因为我一开始认为有可能出现: n=3 k=3 l=2 1 1 1 2 2 2 2 3 4 pos↑ 这种情况，我一开始以为会出现前面都匹配好了，剩下的pos指在这里导致会加上3而不是2(因为看同学代码有倒序查找，见参考资料)，后来发现这种情况不会发生，要不然就会全部都满足条件二。 这三种情况理解了，题目也就很好做了。 AC代码 code1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;using namespace std ;const int maxn = 1e5 + 10 ;int a[maxn];int main()&#123; int n ,k , l ; cin &gt;&gt; n &gt;&gt; k &gt;&gt; l ; for( int i = 1; i &lt;= n * k ; i++) cin &gt;&gt; a[i]; sort( a + 1 , a + 1 + n*k ) ; int pos = upper_bound( a + 1 , a + 1 + n * k , a[1] + l ) - a ; pos--; if( pos &lt; n ) // 错写成小于等于，要注意这里。 &#123; cout &lt;&lt; 0 &lt;&lt; endl ; return 0; &#125; long long ans = 0 ; int p = 1 ; for( int i = 1 ; i &lt;= n ; i++) &#123; ans += a[p]; p++; for( int j = 1 ; j &lt;= k - 1 ; j++) &#123; if( pos - p + 1 &gt; n - i ) // 错写成小于等于，要注意这里是没选的情况 p++; else break ; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl ; return 0 ; &#125; 参考资料 Educational Codeforces Round 44 Editorial By PikMike(官方题解) codeforces 985C Liebig's Barrels —— 上紫 同学代码 感觉自己贪心好弱，思维好僵硬啊qwq。]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>codeforces</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Edu.44 CF985A Chess Placing]]></title>
    <url>%2F9fede59d.html</url>
    <content type="text"><![CDATA[题目链接：http://codeforces.com/contest/985/problem/A 题目大意：给出一个\([1,n]\)的范围，给出\(n/2\)个数，每次可以对任意一个数进行加一减一操作(数字之间不能穿过)。要求把所有数都变成奇数或偶数且各不相同。 错误做法 一开始他说数字之间不能穿过，我以为和蚂蚁(POJ1852)很像，就是不用考虑数字之间穿过的情况。 于是直接模拟了一下，对于某个数标记一下是否这个位置被占用。然后先模拟把所有偶数变成奇数，再反过来模拟，取最小值。模拟思路就是对于第i个数，去寻找第一个满足条件的 a[i] + j 或 a[i] - j ,然后把数字填上去。 一开始我还考虑了，会不会出现我先考虑左边后考虑右边，如果左边满足条件就填进去，而不去考虑右边的话，情况不会最优？ 后来觉得排序可破。于是大胆写了，过了Pretest。 结果就被人hack了。 hack的数据是: 12105 6 7 8 9 这组数据会出现,7可能放到了10的位置，9又要往左走放到左边的位置这样的情况(9放到10才是最优的)。 想了想觉得或许加一些特判，或者从左往右再从右往左搞一搞可破。但是觉得这么写下去，越写越不像是个正解的样子。 遂作罢。 ErrorCode1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;bits/stdc++.h&gt;using namespace std ;const int maxn = 110; int a[maxn];int n ;int solve( int c[] , int flag )&#123; int a[maxn] ; for( int i = 1 ; i &lt;= n/2 ; i++) a[i] = c[i]; bool chess[maxn]; memset( chess, false , sizeof(chess) ) ; for( int i = 1 ; i &lt;= n/2 ; i++) chess[a[i]] = true ; int ans = 0 ; if( flag == 1 ) &#123; for(int i = 1 ; i &lt;= n/2 ; i++) &#123; if( a[i] % 2 == 0 ) &#123; for( int j = 1 ; j + a[i] &lt;= n || a[i] - j &gt;= 1 ; j++) &#123; if( ( (a[i] - j) % 2 == 1 || (a[i] + j) % 2 == 1 ) &amp;&amp; ( !chess[ a[i] - j ] || !chess[ a[i] + j ] ) ) &#123; if( a[i]-j &gt;= 1 &amp;&amp; (a[i] - j) % 2 == 1 &amp;&amp; !chess[ a[i] - j ] ) &#123; chess[a[i]] = false , chess[a[i]-j] = true,ans += j ; break; &#125; else if( a[i]+j &lt;= n &amp;&amp; (a[i] + j) % 2 == 1 &amp;&amp; !chess[a[i]+j] ) &#123; chess[a[i]] = false , chess[a[i]+j] = true,ans += j ; break; &#125; &#125; &#125; &#125; &#125; &#125; else if( flag == 2 ) &#123; for(int i = 1 ; i &lt;= n/2 ; i++) &#123; if( a[i] % 2 == 1 ) &#123; for( int j = 1 ; j + a[i] &lt;= n || a[i] - j &gt;= 1 ; j++) &#123; if( ( (a[i] - j) % 2 == 0 || (a[i] + j) % 2 == 0 ) &amp;&amp; ( !chess[ a[i] - j ] || !chess[ a[i] + j ] ) ) &#123; if( a[i] - j &gt;= 1 &amp;&amp; (a[i] - j) % 2 == 0 &amp;&amp; !chess[ a[i] - j ] ) &#123; chess[a[i]] = false , chess[a[i]-j] = true,ans += j ; break; &#125; else if( a[i] + j &lt;= n &amp;&amp; (a[i] + j) % 2 == 0 &amp;&amp; !chess[a[i]+j] ) &#123; chess[a[i]] = false , chess[a[i]+j] = true,ans += j ; break; &#125; &#125; &#125; &#125; &#125; &#125; return ans ;&#125;int main()&#123; cin &gt;&gt; n ; for( int i = 1 ; i &lt;= n/2 ; i++) cin &gt;&gt; a[i]; sort( a + 1 , a + 1 + n/2 ) ; int ans = min( solve( a , 1 ) , solve(a , 2 ) ); cout &lt;&lt; ans &lt;&lt; endl ; return 0 ; &#125; 正确做法 这道题其实被我想复杂了。考虑到n个位置，一共只给了n/2个数，那么也就是说，每个偶数位或者奇数位肯定是可以被放满的，不会出现要做选择，有些放满有些没有的情况。 所以我们只需要对于第i个数字，考虑他和第i个偶数(奇数)位之间的关系，然后加起来取最小值就可以了。 ACcode123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;using namespace std ;const int maxn = 110 ;int a[maxn];int main()&#123; int n ; cin &gt;&gt; n ; for( int i = 1 ; i &lt;= n / 2; i++) cin &gt;&gt; a[i] ; sort( a + 1 , a + 1 + n / 2 ) ; int ans = 0x3f3f3f3f ; int t = 0 ; int p = 1 ; for( int i = 1 ; i &lt;= n ; i += 2 ) &#123; t+= abs( a[p++] - i ); &#125; ans = min( t , ans ) ; p = 1 ; t = 0 ; for( int i = 2 ; i &lt;= n ; i += 2 ) &#123; t+= abs( a[p++] - i ); &#125; ans = min( t , ans ) ; cout &lt;&lt; ans &lt;&lt; endl ; return 0 ;&#125; 感觉自己真是越来越菜了，哎qwq.]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>codeforces</tag>
        <tag>水题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO-Chapter3-Section3-1]]></title>
    <url>%2Fd339aa5c.html</url>
    <content type="text"><![CDATA[不知道是自己变强了还是题目没有那么繁琐了，感觉这一节比前面的反而简单。 1Agrinet code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768 /*ID:xiekeyi1PROG:agrinetLANG:C++11*/#include&lt;bits/stdc++.h&gt;using namespace std ;const int maxn = 110 ;int graph[maxn][maxn];int father[maxn];struct node&#123; int u , v , value ; node( int uu , int vv , int va ) &#123; u = uu , v = vv , value = va; &#125; ; &#125;;vector&lt; node &gt; a ; int find( int x )&#123; if( x == father[x] ) return x ; else return x = find(father[x]) ;&#125;void uni( int x , int y )&#123; int xx = find(x) ; int yy = find(y) ; if( xx != yy ) &#123; father[xx] = yy ; &#125; return ;&#125;int main()&#123; freopen("agrinet.in","r",stdin); freopen("agrinet.out","w",stdout); for( int i = 0 ; i &lt; maxn ; i++) father[i] = i ; int n ; cin &gt;&gt; n ; for( int i = 1 ; i &lt;= n ; i++) for( int j = 1 ; j &lt;= n ; j++) cin &gt;&gt; graph[i][j] ; for( int i = 1 ; i &lt;= n ; i++) for( int j = i + 1 ; j &lt;= n ; j++) a.push_back( node( i , j , graph[i][j] ) ) ; sort( a.begin() , a.end() , [](node a , node b )&#123; return a.value &lt; b.value ; &#125; ) ; int ans = 0; for( auto iter = a.begin() ; iter != a.end() ; ++iter) &#123; if( find( iter-&gt;u ) != find( iter-&gt;v ) ) &#123; uni( iter-&gt;u , iter-&gt;v ) ; ans += iter-&gt;value ; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl ; return 0 ;&#125; 2inflate code1234567891011121314151617181920212223242526272829303132333435363738 /*ID:xiekeyi1PROG:inflateLANG:C++11*/#include&lt;bits/stdc++.h&gt;using namespace std ;const int maxn = 10010 ;int dp[maxn];struct node&#123; int value ; int time ;&#125;a[maxn];int main()&#123; freopen("inflate.in","r",stdin); freopen("inflate.out","w",stdout); int n , m ; cin &gt;&gt; n &gt;&gt; m ; for( int i = 1 ; i &lt;= m ; i++) cin &gt;&gt; a[i].value &gt;&gt; a[i].time ; for( int i = 1 ; i &lt;= m ; i++) &#123; for( int j = a[i].time ; j &lt;= n ; j++) &#123; dp[j] = max( dp[j] , dp[j-a[i].time] + a[i].value ) ; &#125; &#125; cout &lt;&lt; dp[n] &lt;&lt; endl ; return 0 ;&#125; 3humble 丑数进阶版，之前uva做过，用优先队列就搞定了。 这个貌似只能dp，趁机学了下。 code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 /*ID:xiekeyi1PROG:humbleLANG:C++11*/#include&lt;bits/stdc++.h&gt;using namespace std ;const int maxn = 110;int s[maxn];int indexs[maxn];long long humble_number[100000 + 10];int main()&#123; freopen("humble.in","r",stdin); freopen("humble.out","w",stdout); int n,m; cin &gt;&gt; n &gt;&gt; m ; for( int i = 1 ; i &lt;= n ; i++) &#123; cin &gt;&gt; s[i]; &#125; for( int i = 1 ; i &lt;= n ; i++) indexs[i] = 1 ; int cnt = 1 ; humble_number[1] = 1 ; while( cnt &lt;= m + 2 ) &#123; long long t = 0x7fffffffff; for( int i = 1 ; i&lt;= n ; i++) &#123; t = min( t , humble_number[ indexs[i] ] * s[i] ) ; &#125; for( int i = 1 ; i &lt;= n ; i++) &#123; if( t == humble_number[ indexs[i] ] * s[i] ) &#123; indexs[i]++; &#125; &#125; humble_number[++cnt] = t ; &#125; cout &lt;&lt; humble_number[m+1] &lt;&lt; endl ; return 0 ;&#125; 4contact code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110 /*ID:xiekeyi1PROG:contactLANG:C++11*/#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100100; map&lt;string,int&gt; mp ;string s ; struct node&#123; string s ; int num ;&#125;ans[maxn];bool operator&lt; (const string &amp;a , const string &amp;b )&#123; if( a.size() &lt; b.size() ) return true ; else if( a.size() == b.size() ) return ( strcmp( a.c_str() , b.c_str()) &lt; 0 ? true : false ) ; return false ; &#125;bool cmp( const node &amp;a , const node &amp;b )&#123; if( a.num &gt; b.num ) return true ; else if( a.num == b.num ) &#123; return a.s &lt; b.s ; &#125; else return false ;&#125;int main()&#123; freopen("contact.in","r" , stdin); freopen("contact.out","w" , stdout); int a ,b , n ; cin &gt;&gt; a &gt;&gt; b &gt;&gt; n ; string t ; while( getline( cin , t) ) s += t ; for( int i = a ; i &lt;= b ; i++) &#123; for( int j = 0 ; j + i &lt;= s. size() ; j++) &#123; mp[s.substr(j,i)] += 1 ; &#125; &#125; int p = 1 ; for( auto i = mp.begin() ; i != mp.end() ; ++i) &#123; ans[p].s = i-&gt;first , ans[p].num = i -&gt; second ; p++; &#125; p--; sort( ans + 1 , ans + 1 + p , cmp ) ; int cntt = 0 ; bool flag = false ; for( int i = 1 ; i &lt;= p ; i++) &#123; if( cntt == n ) break ; cout &lt;&lt; ans[i].num &lt;&lt; endl ; cntt++; int cnt = 0 ; flag = false ; for( int j = i ; j &lt;= p ; j++) &#123; if( ans[j].num == ans[i].num ) &#123; if( cnt == 0 ) &#123; cout &lt;&lt; ans[j].s ; cnt++; &#125; else &#123; cout &lt;&lt; ' ' &lt;&lt; ans[j].s ; cnt++; &#125; if( cnt % 6 == 0 ) &#123; cnt = 0 ; cout &lt;&lt; endl ; &#125; &#125; else &#123; i = j - 1 ; if( cnt % 6 != 0 ) cout &lt;&lt; endl ; flag = true ; break ; &#125; &#125; &#125; if( !flag ) cout &lt;&lt; endl ; return 0 ;&#125; 5stamps 一开始想着用set，然后枚举set里的元素加上coin，最后遍历set求连续的数最大值就可以了。 结果MLE一发TLE一发。 然后想了想改了dp。 顺便发现，map和数组访问差距还是有点大的。一开始我以为多一个log，顶多是常数差距，问题不大。结果没想到:map 1.7s TLE,数组0.05s AC code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263 /*ID:xiekeyi1PROG:stampsLANG:C++11*/#include&lt;bits/stdc++.h&gt;using namespace std ;int coin[55];int dp[2000010];int main()&#123; freopen("stamps.in","r",stdin); freopen("stamps.out","w",stdout); int k , n ; cin &gt;&gt; k &gt;&gt; n ; int maxn = 0 ; for( int i = 1 ; i &lt;= n ; i++) &#123; cin &gt;&gt; coin[i] ; maxn = max( coin[i] , maxn ) ; dp[ coin[i] ] = 1 ; &#125; maxn = maxn * k + 100; for( int i = 1 ; i &lt;= maxn; i++) &#123; for( int j = 1 ; j &lt;= n ; j++) &#123; if( i - coin[j] &gt; 0 &amp;&amp; dp[ i - coin[j] ] != 0 &amp;&amp; dp[i-coin[j]] + 1 &lt;= k ) &#123; if( dp[i] == 0 ) dp[i] = dp[ i - coin[j]] + 1 ; else dp[i] = min( dp[i] , dp[i-coin[j]] + 1 ) ; &#125; &#125; &#125; int ans = 0 ; for( int i = 1 ; i &lt;= maxn; i++) &#123; if( dp[i] != 0 ) &#123; for( int j = i + 1 ; j &lt;= maxn; j++ ) &#123; if( dp[j] != 0 &amp;&amp; dp[j-1] != 0 ) continue ; else &#123; ans = max( ans , j - i ); i = j - 1 ; break ; &#125; &#125; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl ; return 0 ; &#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>USACO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串哈希——解决KMP等问题]]></title>
    <url>%2Fd9000e89.html</url>
    <content type="text"><![CDATA[字符串哈希邪教(不保证正确性)，解决一些奇怪的字符串哈希问题 字符串哈希 一开始以为这个是一个比较难的东西，最近学了下，发现是个挺傻屌的东西的。很好理解。 所谓\(hash\)，就是希望有这么一个函数value hash( const string &amp;s ) 对于给定的每一个字符串，都能返回给我一个值。我们利用这个值，可以把长度为\(n\)的串，本来需要\(O(n)\)的去比较一次，现在用这个值可以只进行一次比较得出结果。 其实我们可以把这个映射，看成是\(BASE\)进制下的一种操作。对于一个字符串长度为\(n\)的话，我们就要用\(n\)位\(BASE\)进制去表示这个值。这个很好表示： \[ BASE^{n} * s[n] + BASE^{n-1} * s[n-1] + ... + BASE^{1} * s[1] \] 注意，字符串哈希尽可能避免其中有\(0\)的出现，如果将\(a\)映射为\(0\)，那么\(ab\)和\(b\)可能会出现一样的结果 我们很难有那么多位去表示一个串，如果高精度的话，那么和直接去比较也没什么区别了。所以我们可以取模一个数，看成是\(mod\ P\)意义下的映射表示。 具体的\(hash\)函数: 1234567ull hashh( char s2[] , int n )&#123; ull ans = 0 ; for( int i = 1 ; i &lt;= n ; i++) ans = ans * BASE + s2[i] ; return ans ;&#125; 这样，我们就可以给出一个字符串进去，然后出来一个\(hash\)值了。 如果是需要涉及子串的问题，我们可以这样： 1234567void hashh( ull ans[] , char s1[] , int n )&#123; for( int i = 1 ; i &lt;= n ; i++) &#123; ans[i] = ans[i-1] * BASE + s1[i] ; &#125;&#125; 维护一个像前缀和一样的东西就就可以了。 这里是需要取余的，我这里没有，是利用了unsigned类型的数字，溢出会自动取余的性质和unsigned long long 刚好是一个素数的性质 如果不用素数取余，错误概率将大大提高。为了减少冲突概率，还可以使用双取余等各种其他方法（详情见参考资料）。如果自己手写处理\(hash\)冲突，那么其实这种做法就没有什么优点了。 对于这个，子串如何去使用呢？ 一开始我以为，我只需要简单的对于截取子串\(l...r\)的哈希值，使用ans[r] - ans[l] 就可以了。结果实际使用中发现崩了。 想了想才明白，我们应该将他看成是\(r\)位和\(l\)位的\(BASE\)进制下的数，我现在想截取前\(l\)位（想一下，每一位对应于第几位)。 所以，我们需要进行一个简单的变形: \[ ans[r] - ans[l] * BASE^{r-l+1} \] 我当时这里卡了一下。可以类比于我有\(12345\)和\(123\)， 需要把\(45\)提出，是不是需要乘上一些进制，把\(123\)变成\(12300\)？ 我一开始以为\(hash\)出来的值，最高位存的是\(s[n]\)，后来想了下构建过程，构建是从\(1...n\)，然后又不断的乘\(BASE\)，其实是把最低位给送到了\(hash\)出来的值的最高位。 遇到的问题： - 如何证明\(hash\)冲突的概率是多大？ 相关题目 HDU 1686 题意： 给出串\(T\)和串\(S\)，询问串\(T\)在串\(S\)中出现了几次(允许有重叠部分，具体参考样例) code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;using namespace std ;typedef unsigned long long ull;const int maxn = 1000000 + 10 ; const ull BASE = 1e9 + 7 ;char s1[maxn] , s2[maxn];ull hashs1[maxn];void hashh( ull ans[] , char s1[] , int n )&#123; for( int i = 1 ; i &lt;= n ; i++) &#123; ans[i] = ans[i-1] * BASE + s1[i] ; &#125;&#125;ull hashh( char s2[] , int n )&#123; ull ans = 0 ; for( int i = 1 ; i &lt;= n ; i++) ans = ans * BASE + s2[i] ; return ans ;&#125;int main()&#123; int t ; scanf("%d",&amp;t); while(t--) &#123; scanf("%s",s2+1); scanf("%s",s1+1); int s1_size = strlen(s1+1) , s2_size = strlen(s2+1) ; hashh( hashs1 , s1 , s1_size) ; ull hashs2 = hashh( s2 , s2_size ) ; ull coefficient = 1 ; for( int i = 1 ; i &lt;= s2_size ; i++) coefficient *= BASE ; int ans = 0 ; for( int i = 1 ; i + s2_size - 1 &lt;= s1_size &amp;&amp; i &lt;= s1_size ; i++) &#123; ull t1 = hashs1[i + s2_size - 1 ]; ull t2 = hashs1[i-1]; t2 *= coefficient; if( t1 - t2 == hashs2 ) ans++; &#125; printf("%d\n",ans); &#125; return 0 ; &#125; HDU 1711 题意：给出数列\(S\)和数列\(T\)，求\(T\)在数列\(S\)中第一次出现的位置。 code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include&lt;bits/stdc++.h&gt;using namespace std ;const int maxn = 1000000 + 10 ;typedef unsigned long long ull ; ull a[maxn] , b[maxn] ; ull hashs1[maxn] ;const ull BASE = 1e9 + 7 ;void hashh( ull ans[] , ull a[] , int n )&#123; for( int i = 1 ; i &lt;= n ; i++) &#123; ans[i] = ans[i-1] * BASE + a[i]; &#125;&#125;ull hashh( ull a[] , int n )&#123; ull ans = 0 ; for( int i = 1 ; i &lt;= n ; i++) &#123; ans = ans * BASE + a[i]; &#125; return ans ;&#125;int main()&#123; int t ; scanf("%d",&amp;t); while(t--) &#123; memset( a , 0 , sizeof(a) ) ; memset( b , 0 , sizeof(b) ) ; memset( hashs1 , 0 , sizeof( hashs1 ) ) ; int n , m ; scanf("%d%d",&amp;n , &amp;m ); for( int i = 1 ; i &lt;= n ; i++) &#123; int t ; scanf("%d",&amp;t); a[i] = t + maxn ; &#125; for( int i = 1 ; i &lt;= m ; i++) &#123; int t ; scanf("%d",&amp;t); b[i] = t + maxn ; &#125; hashh( hashs1 , a , n ) ; ull s2 = hashh( b , m ) ; int ans = -1 ; ull t = 1 ; for( int i = 1 ; i &lt;= m ; i++) t *= BASE ; for( int i = 1 ; i + m - 1 &lt;= n &amp;&amp; i &lt;= n ; i++) &#123; ull h1 = hashs1[ i + m - 1 ] ; ull h2 = hashs1[i-1]; h2 *= t ; if( h1 - h2 == s2 ) &#123; ans = i ; break ; &#125; &#125; printf("%d\n",ans); &#125; return 0 ; &#125; HDU 2097 题意： 给出串\(s\)和串\(t\)，求串\(t\)在串\(s\)中出现了几次（无重叠） code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;bits/stdc++.h&gt;using namespace std ;typedef unsigned long long ull ; const int maxn = 1010 ;char s1[maxn],s2[maxn];ull hashs1[maxn];const int BASE = 1e9 + 7 ;const ull mod = 19260817 ; void hashh( ull ans[] , char s[] , int n )&#123; for( int i = 1 ; i &lt;= n ; i++) ans[i] = ( ans[i-1] * BASE + s[i] ) % mod ;&#125;ull hashh( char s[] , int n )&#123; ull ans = 0 ; for( int i = 1 ; i &lt;= n ; i++) ans = ( ans * BASE + s[i] ) % mod ; return ans % mod ; &#125;int main()&#123; while( scanf("%s" , s1 + 1 ) != EOF ) &#123; if( s1[1] == '#' ) break ; scanf("%s" , s2 + 1 ) ; int s1_size = strlen(s1+1) , s2_size = strlen(s2+1) ; hashh( hashs1 , s1 , s1_size ) ; ull hashs2 = hashh( s2 , s2_size ) ; ull coeffcient = 1 ; for( int i = 1 ; i &lt;= s2_size ; i++) coeffcient *= BASE ; coeffcient %= mod ; int ans = 0 ; for( int i = 1 ; i + s2_size - 1 &lt;= s1_size &amp;&amp; i &lt;= s1_size ; i++) &#123; ull h1 = hashs1[ i + s2_size - 1 ] ; ull h2 = hashs1[ i - 1 ]; h2 *= coeffcient ; h1 %= mod , h2 %= mod ; if( h1 - h2 == hashs2 ) &#123; ans++; i = i + s2_size - 1 ; continue ; &#125; &#125; printf("%d\n",ans); &#125; return 0 ;&#125; HDU 5510 题意：找出一个串，这个串前面的至少\(1\)个串不是该串的子串，且该串给出的顺序最靠后，求该串是第几个给出的串？ 这道题时间复杂度挺高的，我第一眼以为是\(AC\)自动机。但是加上剪枝的话，时间复杂度上界没变，下界小很多，想卡这种做法似乎很难(听说剪枝后暴力都可过)。 这是\(ACM-ICPC 2015\)沈阳的题，我在想现场赛遇到这种题，敢不敢写，该怎么写啊？ code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include&lt;bits/stdc++.h&gt;typedef unsigned long long ull ;const int maxn = 2020 ;const ull BASE = 1e9 + 7 ;char s[550][maxn];bool vis[maxn];ull hashall[550];ull hashevery[550][maxn];ull coe[550];int len[550];ull hashh( char s[] , int n )&#123; ull ans = 0 ; for( int i = 1 ; i &lt;= n ; i++) ans = ans * BASE + s[i] ; return ans ;&#125;int main()&#123; int t ; scanf("%d",&amp;t); int KASE = 0 ; while( t-- ) &#123; memset(vis, false ,sizeof(vis)); memset( len , 0 , sizeof(len) ) ; int n ; scanf("%d",&amp;n); for( int i = 1 ; i &lt;= n ; i++) coe[i] = 1 ; for( int i = 1 ; i &lt;= n ; i++) &#123; scanf("%s", &amp;s[i][1] ); len[i] = strlen( &amp;s[i][1] ) ; for( int j = 1 ; j &lt;= len[i] ; j++) coe[i] *= BASE ; &#125; for( int i = 1 ; i &lt;= n ; i++) hashall[i] = hashh( s[i], len[i] ) ; for( int i = 1 ; i &lt;= n ; i++) &#123; for( int j = 1 ; j &lt;= len[i] ; j++) hashevery[i][j] = hashevery[i][j-1] * BASE + s[i][j] ; &#125; int ans = -1 ; for( int i = 2 ; i &lt;= n ; i++) &#123; for( int j = 1 ; j &lt; i ; j++) &#123; if( !vis[j] ) &#123; bool succ = false ; for( int k = 1 ; k + len[j] - 1 &lt;= len[i] ; k++) &#123; ull h1 = hashevery[i][k+len[j]-1]; ull h2 = hashevery[i][k-1]; h2 *= coe[j] ; if( h1 - h2 == hashall[j] ) &#123; succ = true ; vis[j] = true ; break ; &#125; &#125; if( !succ ) ans = i ; &#125; &#125; &#125; printf("Case #%d: %d\n", ++KASE, ans ) ; &#125; return 0 ;&#125; 参考资料 字符串Hash总结 cdoj1092-韩爷的梦 （字符串hash）【hash】 OI 字符串 常用哈希方法]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>hash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XDU2018校赛-Xieldy And His Password]]></title>
    <url>%2Ff2b85b98.html</url>
    <content type="text"><![CDATA[简单DP. 题意：一个长度小于\(1e6\)的01字符串，求所有子串有能在十进制下被三整除的的方案数。（允许有前导零，不同子段视为不同） 题目链接：Xieldy And His Password 比赛的时候，感觉是\(dp\)，曾列过一个方程。当时现场赛上的思路是，考虑设\(dp[i][0/1]\)表示对于当前以\(s[i]\)为结尾的字符串是否能被\(3\)整除。然后又以为被\(3\)整除的数可能会有一些性质（如我知道十进制下能被三整除的数充要条件是各个位数之和能被三整除）。推了一下性质，发现情况很多，而且就算推出来了以后，会发现对于长度为\(1\)到\(i\)之间的串不好处理。 赛后和同学交流，告诉我是模\(3\)意义下的\(dp\)，当时听到这个名词还觉得挺难的。回来看了题解，发现其实是很简单的一个东西→_→。 我们设dp[i][j] ( 0 &lt;= j &lt;= 2 )表示以s[i]为结尾的，所有被\(3\)除余\(j\)的方案数。 那么，分情况讨论： 1. 对于s[i] == 0的情况，可以看做是长度为\(i-1\)的串乘\(2\)得到： - dp[i][0] = dp[i-1][0] + 1 ( 考虑单独一个0的情况 , $3k * 2 ≡ 0 ( mod 3 ) $ ) - dp[i][1] = dp[i-1][2] ( $ ( 3k + 2 ) * 2 ≡ 1 ( mod 3 ) $ ) - dp[i][2] = dp[i-1][1] ( $ ( 3k + 1 ) * 2 ≡ 2 ( mod 3 ) $ ) 2. 对于s[i] == 1的情况，可以看做是长度为\(i-1\)的串乘\(2\)再加\(1\)得到: - dp[i][0] = dp[i-1][1] ( $ ( 3k + 1 ) * 2 + 1 ≡ 0 ( mod 3 ) $ ) - dp[i][1] = dp[i-1][0] + 1( 考虑单独一个1的情况， $ 3k * 2 + 1 ≡ 1 ( mod 3 ) $ ) - dp[i][2] = dp[i-1][1] ( $ ( 3k + 2 ) * 2 + 1 ≡ 0 ( mod 3 ) $ ) 那么，很容易的写出\(dp\)方程。 最终会答案为\(\sum_{1}^{n}dp[i][0]\) 代码如下: code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;using namespace std ;typedef long long ll ;const int maxn = 1e6 + 10 ;ll dp[maxn][3];string s ;int main()&#123; while(cin &gt;&gt; s ) &#123; memset( dp , 0 , sizeof(dp) ) ; // if( s[0] == '0' ) // &#123; // dp[0][0] = 1 ; // &#125; // if( s[0] == '1' ) // &#123; // dp[0][1] = 0 ; // &#125; s.insert( s.begin() , '#' ); for( int i = 1 ; i &lt; s.size() ; i++) &#123; if( s[i] == '0' ) &#123; dp[i][0] = dp[i-1][0] + 1 ; dp[i][1] = dp[i-1][2] ; dp[i][2] = dp[i-1][1] ; &#125; else if( s[i] == '1' ) &#123; dp[i][0] = dp[i-1][1] ; dp[i][1] = dp[i-1][0] + 1 ; dp[i][2] = dp[i-1][2] ; &#125; &#125; ll ans = 0 ; for( int i = 1 ; i &lt; s.size() ; i++) &#123; ans += dp[i][0]; &#125; cout &lt;&lt; ans &lt;&lt; endl ; &#125; return 0 ;&#125; 遇到的问题： - 注意开$long long $ 。一开始以为不会有那么多的情况，后来想了下，如果全是\(0\)的时候，答案最大，是\(\sum_{i=1}^{1e6}i\)]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO-Chapter2-Section2.4]]></title>
    <url>%2F12192b48.html</url>
    <content type="text"><![CDATA[USACO-Chapter2-Section2.4 Shortest Path 感觉虽然题目说是最短路，实际上很多不能算最短路吧。题目也不难，最难也就是裸的dijkstra。不过自己搜索从一开始的很丑陋很暴力的，越写越优雅了倒是真的。 2.4.1 ttwo code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118/*ID:xiekeyi1PROG:ttwoLANG:C++11 */#include&lt;bits/stdc++.h&gt;using namespace std ;const int maxn =15 ;char graph[maxn][maxn];pair&lt; pair&lt; int , int &gt; , int &gt; cow , farm;int ans = 0 ; bool succ = true ; bool judge()&#123; if( cow.first == farm.first ) &#123; succ = true ; return false ; &#125; else if( ans &gt;= 10000 ) &#123; succ = false ; return false ; &#125; return true ;&#125;void rolate( pair&lt; pair&lt;int,int&gt; , int &gt; &amp;a ) &#123; a.second = ( a.second + 1 ) % 4 ; return ; &#125;void go_away( pair&lt; pair&lt; int , int &gt; , int &gt; &amp;a )&#123; if( a.second == 0 ) &#123; if( graph[ a.first.first-1][a.first.second] != '*' &amp;&amp; a.first.first-1 &gt;= 1 ) a.first.first -= 1 ; else rolate(a); &#125; else if( a.second == 1 ) &#123; if( graph[ a.first.first][a.first.second+1] != '*' &amp;&amp; a.first.second+1 &lt;= 10 ) a.first.second+= 1 ; else rolate(a); &#125; else if( a.second == 2 ) &#123; if( graph[ a.first.first+1][a.first.second] != '*' &amp;&amp; a.first.first + 1 &lt;= 10 ) a.first.first+= 1 ; else rolate(a); &#125; else if( a. second == 3 ) &#123; if( graph[ a.first.first][a.first.second-1] != '*' &amp;&amp; a.first.second -1 &gt;= 1 ) a.first.second -= 1 ; else rolate(a); &#125; return ;&#125;void func() &#123; go_away(cow); go_away(farm); ans++; return ; &#125;int main()&#123; freopen("ttwo.in","r",stdin); freopen("ttwo.out","w",stdout); for( int i = 1 ; i &lt;= 10 ; i++) scanf("%s",graph[i]+1); for( int i = 1 ; i &lt;= 10 ; i++) &#123; for( int j = 1 ; j &lt;= 10 ; j++) &#123; if( graph[i][j] == 'F' ) farm.first.first = i , farm.first.second = j , farm.second = 0 ; if( graph[i][j] == 'C' ) cow.first.first = i , cow.first.second = j , cow.second = 0 ; &#125; &#125; while( judge() ) &#123; func(); &#125; if( succ ) cout &lt;&lt; ans &lt;&lt; endl ; else cout &lt;&lt; 0 &lt;&lt; endl ; return 0 ; &#125; 2.4.2 overfencing code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173/*ID:xiekeyi1PROG:maze1LANG:C++11 */ #include&lt;bits/stdc++.h&gt;using namespace std ;const int maxn = 210 ; const int dx[] = &#123; 0 , 1 , -1 , 0 &#125;;const int dy[] = &#123; 1 , 0 , 0 , -1 &#125;;char graph[maxn][maxn];int W , H ; int dis[maxn][maxn];int dis2[maxn][maxn];bool isAns( pair&lt; int , int &gt; pp )&#123; if( pp.first == 1 || pp.first == 2 * H + 1 || pp.second == 1 || pp.second == 2 * W + 1 ) &#123; if( graph[pp.first][pp.second] == ' ' ) return true ; &#125; return false ; &#125;bool isLegal( int x , int y )&#123; if( x &gt;= 1 &amp;&amp; x &lt;= 2 * H + 1 &amp;&amp; y &gt;= 1 &amp;&amp; y &lt;= 2 * W + 1 ) &#123; if( graph[x][y] == ' ' &amp;&amp; dis[x][y] == 0 ) return true ; &#125; return false ;&#125;void BFS( int x , int y )&#123; queue&lt; pair&lt;int , int &gt; &gt; q ; q.push( make_pair( x , y ) ) ; while( !q.empty() ) &#123; pair&lt;int , int &gt; top ; top = q.front() ; q.pop() ; // if( isAns( top ) ) // return dis[top.first][top.second] + 1 ; for( int i = 0 ; i &lt; 4 ; i++) &#123; if( isLegal( top.first + dx[i] , top.second + dy[i] ) ) &#123; q.push( make_pair( top.first + dx[i] , top.second + dy[i] ) ) ; dis[top.first + dx[i] ][ top.second + dy[i] ] = dis[top.first][top.second] + 1 ; &#125; &#125; &#125;; return ; &#125;int main()&#123; freopen("maze1.in","r",stdin); freopen("maze1.out","w",stdout); scanf("%d%d",&amp;W,&amp;H);/* //getchar() ;getchar() ; fflush(stdin); for( int i = 1 ; i &lt;= 2 * H + 1 ; i ++) &#123; scanf("%[^\n]" , graph[i] + 1 ) ; fflush(stdin); &#125;*/ string t ; for( int i = 1 ; i &lt;= 2 * H + 1 ; i++) &#123; do getline(cin,t); while( t.size() &lt;= 0 ) ; for( int j = 0 ; j &lt; 2 * W + 1 ; j++) &#123; graph[i][j+1] = t[j] ; &#125; &#125; int startx = 0 , starty = 0 ; for( int i = 1 ; i &lt;= 2 * H + 1 ; i++) &#123; for( int j = 1 ; j &lt;= 2 * W + 1 ; j++) &#123; if( isAns( make_pair( i , j ) ) ) &#123; startx = i , starty = j ; dis[startx][starty] = 1 ; break ; &#125; &#125; if( startx != 0 &amp;&amp; starty != 0 ) break ; &#125; int ans = 0; for( int i = 1 ; i &lt;= 2 * H + 1 ; i++) &#123; for( int j = 1 ; j &lt;= 2 * W + 1 ; j++) &#123; BFS( startx , starty ) ; &#125; &#125; // for( int i = 1 ; i &lt;= 2 * H + 1 ; i++ ) // &#123; // for( int j = 1 ; j &lt;= 2 * W + 1 ; j++) // &#123; // ans = max( ans , dis[i][j] ) ; // &#125; // &#125; for( int i = 1 ; i &lt;= 2 * H + 1 ; i++) &#123; for( int j = 1 ; j &lt;= 2 * W + 1 ; j++) &#123; dis2[i][j] = dis[i][j] ; &#125; &#125; memset( dis, 0 , sizeof( dis) ) ; int startx2 = 0 ,starty2 = 0 ; for( int i = 1 ; i &lt;= 2 * H + 1 ; i++) &#123; for( int j = 1 ; j &lt;= 2 * W + 1 ; j++) &#123; if( ( i != startx || j != starty ) &amp;&amp; isAns( make_pair( i , j ) ) ) &#123; startx2 = i , starty2 = j ; dis[startx2][starty2] = 1 ; break ; &#125; &#125; if( startx2 != 0 &amp;&amp; starty2 != 0 ) break ; &#125; for( int i = 1 ; i &lt;= 2 * H + 1 ; i++) &#123; for( int j = 1 ; j &lt;= 2 * W + 1 ; j++) &#123; BFS( startx2 , starty2 ) ; &#125; &#125;/* printf(" startx : %d , starty : %d , startx2 : %d , starty2 : %d \n " , startx , starty , startx2 , starty2 ) ; printf(" graph[%d][%d] = %c \n " , startx , starty , graph[startx][starty] ) ;*/ for( int i = 1 ; i &lt;= 2 * H + 1 ; i++ ) &#123; for( int j = 1 ; j &lt;= 2 * W + 1 ; j++) &#123; // printf(" dis[%d][%d] = %d , dis2[%d][%d] = %d , ans = %d \n" ,i,j, dis[i][j] ,i,j, dis2[i][j], ans); ans = max( ans , min( dis[i][j],dis2[i][j] ) ) ; &#125; &#125; printf("%d\n",ans/2); return 0 ;&#125; 2.4.3 cowtour code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103/*ID:xiekeyi1PROG:cowtourLANG:C++11 */#include&lt;bits/stdc++.h&gt;using namespace std ;const int maxn = 150 ;int graph[maxn][maxn];double minpath[maxn][maxn];double maxdis[maxn];pair&lt; int , int &gt; coo[maxn] ;double calcdis( pair&lt;int , int &gt; &amp;a , pair&lt; int , int &gt; &amp;b ) &#123; return sqrt( ( a.first - b.first + 0.0 ) * ( a.first - b.first) + (a.second - b.second ) * ( a.second - b.second) ) ;&#125;int main()&#123; freopen("cowtour.in","r",stdin); freopen("cowtour.out","w",stdout); int n ; cin &gt;&gt; n ; for( int i = 1 ; i &lt;= n ; i++) &#123; int x , y ; cin &gt;&gt; x &gt;&gt; y ; coo[i] = make_pair( x , y ) ; &#125; for( int i = 1 ; i &lt;= n ; i++) &#123; string s ; cin &gt;&gt; s ; for( int j = 1 ; j &lt;= n ; j++) &#123; graph[i][j] = s[j-1] - '0' ; &#125; &#125; for( int i = 1 ; i &lt;= n ; i++) &#123; for( int j = 1 ; j &lt;= n ; j++) &#123; if( graph[i][j] == 1 ) &#123; minpath[i][j] = calcdis( coo[i] , coo[j] ) ; &#125; else &#123; minpath[i][j] = 1e10 ; &#125; &#125; &#125; for( int k = 1 ; k &lt;= n ; k++) &#123; for( int i = 1 ; i &lt;= n ; i++) &#123; for( int j = 1 ; j &lt;= n ; j++) &#123; if( i != j ) minpath[i][j] = min( minpath[i][j] , minpath[i][k] + minpath[k][j] ); &#125; &#125; &#125; for( int i = 1 ; i &lt;= n ; i++ ) &#123; for( int j = 1 ; j &lt;= n ; j++) &#123; if( i != j &amp;&amp; minpath[i][j] &lt; 1e9 ) maxdis[i] = max( maxdis[i] , minpath[i][j] ) ; &#125; &#125; double r1 = 0 , r2 = 1e10; for( int i = 1 ; i &lt;= n ; i++) &#123; r1 = max( r1 , maxdis[i] ); for( int j = 1 ; j &lt;= n ; j++) &#123; if( i != j &amp;&amp; minpath[i][j] &gt; 1e8 ) r2 = min( r2 , maxdis[i] + maxdis[j] + calcdis( coo[i] , coo[j] ) ) ; &#125; &#125; double ans ; if( r2 &lt; 1e8 ) ans = max( r1 , r2 ) ; else &#123; ans = r1 ; &#125; printf("%.6f\n",ans); return 0 ;&#125; 2.4.4 comehome 这道题一开始我想的是反向BFS的，后来发现这个图，直接BFS不一定最先出来的是最短边，可能还是要遍历整张图。于是用了dijkstra。 dijkstra用裸的，什么优化都没有的就可以跑。一开始我还在觉得用字母好难处理，后来发现用字母太妙了。 一开始看到一万条边，把我吓得不行，后来想了想，用字母表示点，最多也就五十多个点，等于有很多重边和自环，easy~ dijkstra反向跑一下就行了，难点在hash一下字母和数字对应关系。 有的人是dijkstra松弛到大写字母最短边就return了，因为我不太会这种写法，所以我跑完了全部的dijkstra然后再去找。 code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101/*ID:xiekeyi1PROG:comehomeLANG:C++11*/#include&lt;bits/stdc++.h&gt;#include&lt;unordered_map&gt;using namespace std ;const int MAXN = 55 ;int graph[MAXN][MAXN];int n ;inline int index( char ch )&#123; if( ch &gt;= 'a' &amp;&amp; ch &lt;= 'z' ) &#123; return ch - 'a' ; &#125; else if( ch &gt;= 'A' &amp;&amp; ch &lt;= 'Z' ) &#123; return ch - 'A' + 26 ; &#125;&#125;void dijkstra( pair&lt; char , int &gt; &amp;ans )&#123; bool vis[MAXN]; memset( vis , false ,sizeof( vis ) ) ; int dis[MAXN]; for( int i = 0 ; i &lt; MAXN ; i++) dis[i] = 0x3f3f3f3f ; dis[ index( 'Z' ) ] = 0 ; for( int i = 0 ; i &lt; MAXN ; i++) &#123; // find the nearest point . int node = -1 , len = 0x3f3f3f3f ; for( int j = 0 ; j &lt; MAXN ; j++) &#123; if( !vis[j] &amp;&amp; dis[j] &lt; len ) node = j , len = dis[j] ; &#125; if( node != -1 ) &#123; vis[node] = true ; for( int j = 0 ; j &lt; MAXN ; j++) &#123; if( !vis[j] &amp;&amp; dis[node] + graph[node][j] &lt; dis[j] ) dis[j] = dis[node] + graph[node][j] ; &#125; &#125; &#125; int t1 = 0 , t2 = 0x3f3f3f3f ; for( int i = 26 ; i &lt;= 50 ; i++) &#123; if( dis[i] &lt; t2 ) &#123; t2 = dis[i] ; t1 = i ; &#125; &#125; ans = make_pair( t1 - 26 + 'A' , t2 ) ;&#125;int main()&#123; freopen("comehome.in","r",stdin); freopen("comehome.out","w",stdout); cin &gt;&gt; n ; for( int i = 0 ; i &lt; MAXN ; i++) &#123; for( int j = 0 ; j &lt; MAXN ; j++) &#123; graph[i][j] = 0x3f3f3f3f ; &#125; &#125; for( int i = 1 ; i &lt;= n ; i++) &#123; string u , v ; int value ; cin &gt;&gt; u &gt;&gt; v &gt;&gt; value ; graph[ index( u[0] ) ][ index( v[0] ) ] = min( graph[ index( u[0] ) ][ index( v[0] ) ] , value ) ; graph[ index( v[0] ) ][ index( u[0] ) ] = min( graph[ index( v[0] ) ][ index( u[0] ) ] , value ) ; &#125; pair&lt; char , int &gt; ans ; dijkstra( ans ) ; cout &lt;&lt; ans.first &lt;&lt; ' ' &lt;&lt; ans.second &lt;&lt; endl ; return 0 ;&#125; 2.4.5 fracdec 直接模拟就好了。遇到了的几个问题： 1. 一开始判断是否出现过这个情况，我没用set&lt; pair &gt;来处理，而是用了两个set，一个记录商，一个记录余数。结果会发现可能，商是出现过的，余数也是出现过的，然而这两个不是同时出现的，导致出现错误(样例就是这种情况)。 2. 对整除的\(1.0\)这种情况，容易变成\(1.(0)\)。可以通过判断余数是否是0来判断整除与否。 code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/*ID:xiekeyi1PROG:fracdecLANG:C++11 */#include&lt;bits/stdc++.h&gt;using namespace std ;set&lt; pair&lt; int , int &gt; &gt; st ; map&lt; pair&lt; int , int &gt; , int &gt; mp ; int main()&#123; freopen("fracdec.in","r",stdin); freopen("fracdec.out","w",stdout); int n ,d ; cin &gt;&gt; n &gt;&gt; d ; string a; a+= to_string( n / d ) ; int ans = n - n / d * d ; ans *= 10 ; a += "." ; int i = 0 ; int pos = a.size() ; while( true ) &#123; if( st.count( make_pair( ans / d , ans - ans / d * d ) )) &#123; pos += mp[ make_pair( ans / d , ans - ans / d * d ) ] ; break ; &#125; int s = ans / d ; a += to_string( s) ; //shang.insert( s ); // ans 是余数 ans = ans - s * d ; //yushu.insert(ans); st.insert( make_pair( s , ans ) ) ; if( mp[ make_pair( s , ans ) ] == 0 ) mp[ make_pair( s , ans ) ] = i ; ans *= 10 ; i++; // 判断整除 if( ans == 0 ) break ; &#125; if( ans != 0 ) &#123; a.insert( pos , "(" ) ; a += ")" ; &#125; for( int i = 0 ; i &lt; a.size() ; i++) &#123; cout &lt;&lt; a[i] ; if( ( i + 1 ) % 76 == 0 ) &#123; cout &lt;&lt; endl ; &#125; &#125; if( a.size() % 76 != 0 ) &#123; cout &lt;&lt; endl ; &#125; return 0 ;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>USACO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Manacher-最大回文串匹配线性算法]]></title>
    <url>%2Ff89d3c0b.html</url>
    <content type="text"><![CDATA[线性求最大回文串匹配算法。 以往我是不太爱学算法的，尤其是这种适用面很狭窄的算法，因为总感觉算法这东西学了也不一定考，考了也不一定能A。不过最近刷题的时候发现，自己经常遇到的一些题，虽然和我学过的算法没什么关系，但是代码技巧和思维技巧，明明就是我学XX算法的时候的思路嘛。再加上我最近的代码能力有所增强，看新算法、学新算法的时间我感觉明显缩短，理解力up↑up↑。于是开始喜欢看新算法了。 据说这个算法赛场上很难有机会用到，因为适用面狭窄。 关于最大回文串的匹配，常见的算法有两种： 1. 用\(O(n^2)\)的时间复杂度，暴力枚举每一个子串。再对于每一个子串，用\(O(n)\)的复杂度去判断他是否是一个回文串。总时间复杂度为\(O(n^3)\)。 2. 用\(O(n)\)的时间复杂度去枚举中轴，对于每一个中轴，用\(O(n)\)的时间复杂度去向两边扩展。总时间复杂度为\(O(n^2)\)。(注意，这种方法对于偶数中轴和奇数中轴会有一些不一样的情况需要考虑。) Manacher（马拉车）算法 这种算法可以看做是上面第二种算法的一个改进(成电视频中认为这是一个剪枝)。 对于第二种算法，如果当前匹配GG了，那么下一次匹配，依然要从\(1\)(或\(0\))开始重新去检查回文串。 然而，回文串里面有大量相似和冗余的信息，我们希望能用回文串本身的一些性质和所包含的信息，去避免每次都要从头开始匹配的问题。 首先，我们需要对串本身进行一些改进，以避免第二种算法对于奇数和偶数需要分开判断的情况。我们在串的每个字母前后都加入特殊字符#，如对于aaa来说，改变后串为#a#a#a。 接下来我们约定四个变量表示： 1234Ma[i] // Ma表示改进后串，Ma[i]表示第i个字符Mp[i] // 表示从第i个字符开始向两边延伸，最多可以延伸Mp[i]位（他们都是回文串）。Mx // 表示之前延伸过的所有回文串，所到达过的最右端。Id // 表示Mx所对应的回文串的中心。 首先我们初始化：$Mx = 0 , Id = 0 $ 接下来我们和第二种算法所做的基本一样，枚举中轴： 12// 为缩减代码，这里使用strlen函数，实际使用中请务必注意。for( int i = 0 ; i &lt; strlen(Ma) ; i++ ) 分类讨论 情况1 Mx &gt; i 那么如果我们枚举中发现\(Mx &gt; i\)，便可以说明，之前肯定有某一个串，曾经更新覆盖过\(i\)，我们能否利用对称的性质，使\(i\)能有一个比较大的初始值，然后再进行常规操作。 由\(Mx &gt; i\) ，我们可以知道显然有\(Mx &gt; i &gt; id\)，那么既然\(Mx\)和\(Mx&#39;\)对称，中轴\(id\)知道，那么\(i\)和\(i&#39;\)也一定会对称。 这是这个算法的核心。 \(i&#39;\)的坐标是多少呢？就是\(2 * id - i\) 由 \(id - ( i - id )\)得到 。 情况(1) i和i'都在Mx与Mx'内 那么我们是不是可以直接使用 \(Mp[i] = Mp[ 2 * id - i ]\)呢？ 在\(i\)和\(i&#39;\)都在\(Mx\)和\(Mx&#39;\)内时，这是正确无误的。 但是还有另外一种情况。 情况(2) i'在Mx'外 当\(i&#39;\)很长，延伸到了\(Mx&#39;\)外时，我们并不能保证\(i\)也能一如既往的延伸到\(Mx\)以外。这时候我们只能保证\(i\)在\(Mx\)以内的时候，是对称的。 所以这时候 \[Mp[i] = Mx - i\] 情况(1)和情况(2) 我们并不关心具体是什么情况，因为这对时间复杂度没有影响。所以我们只要Mp[i] = min( Mp[2*id-i] , Mx - i ) 就足够了。 情况2 Mx &lt;= i 遇到这种情况我们怎么办呢？老老实实的去扩展吧。但是在这里我们可以一边扩展，一边去更新Mp[i]的值。 1while( Ma[ i + Mp[i] ] == Ma[ i - Mp[i] ] ) Mp[i]++; 这样即就是一遍扩展，一遍更新了。 Manacher完整实现 最后，我们把上面这几部分组合一下，并注意更新\(Mx\)和\(Id\)的值，就可以了。 code1234567891011121314151617for( int i = 0 ; i &lt; size ; i++)&#123; if( Mx &gt; i ) &#123; Mp[i] = min( Mp[ 2 * Id - i ] , Mx - i ) ; &#125; else Mp[i] = 1 ; while( Ma[i + Mp[i] ] == Ma[i - Mp[i]] ) Mp[i]++; if( i + Mp[i] &gt; Mx ) &#123; Mx = i + Mp[i] ; Id = i ; &#125; ans = max( ans , Mp[i] ) ;&#125; 最终第i个字符的回文串长度为\(Mp[i] - 1\) ## 时间复杂度 这个时间复杂度不是特别好算，我们可以使用摊还分析。具体可以参考一下其他量化分析文章，会很详细。简单的理解可以是： 发现\(Mx\)每次最少往右移动\(1\)，并且除此之外其他的不会对复杂度有贡献。 遇到的一些问题 理解为何\(Mp\)数组只是记录了向其中一边延伸的问题，却可以做最终答案： 因为#号的存在，使得两边的#号必然相等，那么，一边就可以看做是两边了。 需要正确理解为什么第i个字符的回文串长度需要\(-1\)： 同样因为#的存在，当以#为中心，需要去除中心的#，当以非#为中心，需要去除相邻的一个#。 边界等问题。(有些地方会把开头加一些其他的特殊字符以避免边界问题。目前这类问题我还没有遇到) 参考资料 电子科技大学-字符串算法选讲 (昨天很多博客没看清楚，看了这个半个小时就会了) 有什么浅显易懂的Manacher Algorithm详解 - 知乎 (和第一个一起使用） O(n)回文子串(Manacher)算法 如何证明Manacher算法的时间复杂度是O(n)]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>算法</tag>
        <tag>Manacher</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT-CCCC-L2-008-最长对称子串]]></title>
    <url>%2Ffb32b34c.html</url>
    <content type="text"><![CDATA[最长回文子串问题 题目链接：https://www.patest.cn/contests/gplt/L2-008 枚举子串 超时一个点 复杂度O(n^3) code12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;using namespace std ;string s ;bool issymm( int l , int r )&#123; for( int i = l ; i &lt;= r ; i++) &#123; if( s[i] != s[r-i+l] ) return false ; &#125; return true ;&#125;int main()&#123; getline(cin,s); int ans = 0 ; for( int i = 0 ; i &lt; s.size() ; i++) &#123; for( int j = 0 ; j &lt; s.size() ; j++) &#123; if( issymm( i , j ) ) &#123; ans = max( ans , j - i + 1 ) ; &#125; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl ;&#125; 枚举中轴 这个方法就是枚举轴，然后从轴向两边扩展。 复杂度O(n^2) 需要注意的是，轴有两种情况: 1. 以中间一个数字为轴 2. 以中间两个数字为轴 code1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;using namespace std ;string s ;int solve( string &amp;s )&#123; int ans = 0 ; for( int i = 0 ; i &lt; s.size() ; i++) &#123; int temp = 1 ; for( int j = 1 ; j &lt; s.size() ; j++) // 以中间一个数字为轴的情况 &#123; if( i - j &lt; 0 || i + j &gt;= s.size() || s[i-j] != s[i+j] ) break; temp += 2; &#125; ans = max( temp , ans ) ; temp = 0 ; for( int j = 1 ; j &lt; s.size() ; j++) // 以中间两个数字为轴的情况 &#123; // 注意这里i-j+1的情况，这是因为需要两个数字之间比较，不相等为0，这里WA了一次。 if( i - j + 1 &lt; 0 || i + j &gt;= s.size() || s[i-j+1] != s[i+j] ) break ; temp+=2; &#125; ans = max( ans , temp ) ; &#125; return ans ;&#125;int main()&#123; getline(cin,s); int ans = 0 ; ans = solve( s ) ; cout &lt;&lt; ans &lt;&lt; endl ;&#125; Manacher 复杂度:O(n) 这个算法看了两天才看明白。 具体这个算法可以看我的下一篇博客： code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;using namespace std ;const int maxn = 3000;char Ma[maxn] ;int Mp[maxn];int Mx = 0 , Id = 0 ; int main()&#123; string s ; getline( cin ,s ) ; Ma[0] = '#' ; for( int i = 1 , cnt = 0 ; cnt &lt; s.size() ; i++) &#123; if( i % 2 == 1 ) &#123; Ma[i] = '#'; &#125; else &#123; Ma[i] = s[cnt++]; &#125; &#125; int size = strlen(Ma); Ma[size++] = '#' ; int ans = 0 ; for( int i = 0 ; i &lt; size ; i++) &#123; if( Mx &gt; i ) &#123; Mp[i] = min( Mp[ 2 * Id - i ] , Mx - i ) ; &#125; else Mp[i] = 1 ; while( Ma[i + Mp[i] ] == Ma[i - Mp[i]] ) Mp[i]++; if( i + Mp[i] &gt; Mx ) &#123; Mx = i + Mp[i] ; Id = i ; &#125; ans = max( ans , Mp[i] ) ; &#125; cout &lt;&lt; ans - 1 &lt;&lt; endl ; return 0 ;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>Manacher</tag>
        <tag>字符串</tag>
        <tag>CCCC</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Boost.test单元测试 第一次使用]]></title>
    <url>%2F4fb81a46.html</url>
    <content type="text"><![CDATA[第一次学习单元测试 之前在申请GSoC的Boost库相关项目，要求我实现一个线段树类。在实现后要求我去做单元测试。一开始是一直不愿意去做这个单元测试的，因为查了一下发现资料很少，时间很紧，感觉英文文档太长，使用起来感觉有点抵触，觉得会很困难。 最后硬着头皮上了。 单元测试其实比我想象的简单，就是把我一直都在使用的人肉测试自动化了而已。 ** 单元测试是面向接口的，和面向对象的程序设计思想重合** 。 我使用的系统是Ubuntu 16.04 ，首先安装 sudo apt-get install libboost-dev （如果找不到相关的可以使用sudo apt-cache search boost 来查找关于boost的全部信息。如果找不到的话，尝试sudo apt-get update 进行更新。 一开始我以为boost库会很大，实际下载下来也就几百MB，很少。 下载完成后，我照着官方文档的tutorials做了一些简单的测试，发现使用起来很方便。 这个文档中的代码基本上上拿来就可以使用了，唯一需要注意的是要在最上面加上这一句宏#define BOOST_TEST_DYN_LINK ，这一句宏是为了开启动态链接的。** 这个宏必须必须放在最开头！** 我之前放在第二行，结果总是提示找不到main函数，最后鬼使神差的调整了一下位置解决了这个问题。 编译命令需要加上-lboost_unit_test_framework 进行链接。 编译后运行即可。 boost.test库里还有很多更强大的东西，但是因为这次我只需要做一些简单的测试，所以并没有进一步学习。希望以后有机会可以学到如何使用大文件大数据(像模拟一个本地OJ一样)。 code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495代码如下：```c++#define BOOST_TEST_DYN_LINK#define BOOST_TEST_MODULE TEST_SEGMENT_TREE #include &lt;boost/test/unit_test.hpp&gt;#include "segment_tree.hpp"#include&lt;vector&gt;#include&lt;iostream&gt;using namespace std ;using namespace st ; // segment_tree ;using namespace boost ;// g++ -std=gnu++11 unit_test.cpp -lboost_unit_test_frameworkBOOST_AUTO_TEST_CASE( MAX )&#123; vector&lt;int&gt; a; for( int i = 0 ; i &lt; 10 ; i++) &#123; a.push_back(i); &#125; segment_tree&lt; int , Max&lt;int&gt; &gt; *st = new segment_tree&lt; int , Max&lt;int&gt; &gt; ; st-&gt;build( a , 0 , 9 ) ; BOOST_CHECK_MESSAGE( st-&gt;query( 0,0 ) == 0 , "st.query(..) result: " &lt;&lt; st-&gt;query(0,0) ); // check border zero BOOST_CHECK_MESSAGE( st-&gt;query( 0,9 ) == 9 , "st.query(..) result: " &lt;&lt; st-&gt;query(0,9) ); // check all segment ; BOOST_CHECK_MESSAGE( st-&gt;query(1,5) == 5 , "st.query(..) result: " &lt;&lt; st-&gt;query(1,5) ); // check a segment ; st-&gt;modify1(1,5,100); // add [1,5] to 100 ; BOOST_CHECK_MESSAGE( st-&gt;query(1,5) == 105 , "st.query(..) result: " &lt;&lt; st-&gt;query(1,5) ); // check the modify correct; BOOST_CHECK_MESSAGE( st-&gt;query(8,8) == 8, "st.query(..) result: " &lt;&lt; st-&gt;query(8,8) ); // check the not modify node ; BOOST_CHECK_MESSAGE( st-&gt;query(6,9) == 9, "st.query(..) result: " &lt;&lt; st-&gt;query(6,9) ); // check the not modify segment ; st-&gt;modify1(1,5,-100); // add [[1,5] to -100 ; BOOST_CHECK_MESSAGE( st-&gt;query(0,9) == 9, "st.query(..) result: " &lt;&lt; st-&gt;query(0,9) ); //; check the modify ; delete st;&#125;BOOST_AUTO_TEST_CASE( MIN )&#123; vector&lt;int&gt; a; for( int i = 0 ; i &lt; 10 ; i++) &#123; a.push_back(i); &#125; segment_tree&lt; int , Min&lt;int&gt; &gt; *st = new segment_tree&lt; int , Min&lt;int&gt; &gt; ; st-&gt;build( a , 0 , 9 ) ; BOOST_CHECK_MESSAGE( st-&gt;query( 0,0 ) == 0 , "st.query(..) result: " &lt;&lt; st-&gt;query(0,0) ); // check border zero BOOST_CHECK_MESSAGE( st-&gt;query( 0,9 ) == 0 , "st.query(..) result: " &lt;&lt; st-&gt;query(0,9) ); // check all segment ; BOOST_CHECK_MESSAGE( st-&gt;query(1,5) == 1 , "st.query(..) result: " &lt;&lt; st-&gt;query(1,5) ); // check a segment ; st-&gt;modify1(1,5,100); // add [1,5] to 100 ; BOOST_CHECK_MESSAGE( st-&gt;query(1,5) == 101, "st.query(..) result: " &lt;&lt; st-&gt;query(1,5) ); // check the modify correct; BOOST_CHECK_MESSAGE( st-&gt;query(8,8) == 8, "st.query(..) result: " &lt;&lt; st-&gt;query(8,8) ); // check the not modify node ; BOOST_CHECK_MESSAGE( st-&gt;query(6,9) == 6, "st.query(..) result: " &lt;&lt; st-&gt;query(6,9) ); // check the not modify segment ; st-&gt;modify1(1,5,-200); // add [[1,5] to -100 ; BOOST_CHECK_MESSAGE( st-&gt;query(0,9) == -99, "st.query(..) result: " &lt;&lt; st-&gt;query(0,9) ); //; check the modify ; delete st;&#125;BOOST_AUTO_TEST_CASE( PLUS )&#123; vector&lt;int&gt; a; for( int i = 0 ; i &lt; 10 ; i++) &#123; a.push_back(i); &#125; segment_tree&lt; int , Plus&lt;int&gt; &gt; *st = new segment_tree&lt; int , Plus&lt;int&gt; &gt; ; st-&gt;build( a , 0 , 9 ) ; BOOST_CHECK_MESSAGE( st-&gt;query( 0,0 ) == 0 , "st.query(..) result: " &lt;&lt; st-&gt;query(0,0) ); // check border zero BOOST_CHECK_MESSAGE( st-&gt;query( 0,9 ) == 45 , "st.query(..) result: " &lt;&lt; st-&gt;query(0,9) ); // check all segment ; BOOST_CHECK_MESSAGE( st-&gt;query(1,5) == 15 , "st.query(..) result: " &lt;&lt; st-&gt;query(1,5) ); // check a segment ; st-&gt;modify1(1,5,100); // add [1,5] to 100 ; BOOST_CHECK_MESSAGE( st-&gt;query(1,5) == 515, "st.query(..) result: " &lt;&lt; st-&gt;query(1,5) ); // check the modify correct; BOOST_CHECK_MESSAGE( st-&gt;query(8,8) == 8, "st.query(..) result: " &lt;&lt; st-&gt;query(8,8) ); // check the not modify node ; BOOST_CHECK_MESSAGE( st-&gt;query(6,9) == 30 , "st.query(..) result: " &lt;&lt; st-&gt;query(6,9) ); // check the not modify segment ; st-&gt;modify1(1,5,-100); // add [[1,5] to -100 ; BOOST_CHECK_MESSAGE( st-&gt;query(0,9) == 45, "st.query(..) result: " &lt;&lt; st-&gt;query(0,9) ); //; check the modify ; delete st;&#125; 运行结果：]]></content>
      <categories>
        <category>工程</category>
      </categories>
      <tags>
        <tag>工程</tag>
        <tag>测试</tag>
        <tag>Boost</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT-CCCC-L2.002紧急救援]]></title>
    <url>%2F777eca84.html</url>
    <content type="text"><![CDATA[题目链接：https://www.patest.cn/contests/gplt/L2-001 有点小瞧了这道题的难度。从L1一路高歌猛进过来，以为L2一开始不会太难，只是一个简单的最短路。 想了一会后发现，主要问题是： 1. 边权和最小的情况下（就是普通最短路），点权和最大。 2. 输出路径。（一个pre数组记录，栈输出或者递归输出，基本操作）。 3. 求所有最短路的个数。（之前没有接触过）。 要点权和最大，就类似于多关键字排序一样，再加一层松弛判断就可以。 求最短路个数，就是如果松弛了i，pathnum[i] = 1 ， 如果是在距离一样的情况下松弛了，那么就pathnum[i] += pathnum[node]（node是链接过来的点）即可。 这道题卡了我很久的两个地方： 1. 点权和最大的判断自己写蠢了好几次。明明模仿边权和判断的问题就可以了，然而还是蠢了不少。 2. 这道题一开始我以为有重边。处理很久不清楚在邻接矩阵的情况下怎么处理，一开始考虑要不要用邻接链表的时候，找了个别人A的测了下，发现它也没处理重边，于是重边问题没有解决。 遗留问题： 1. ** 如何在邻接矩阵的情况下处理重边? 2. 为什么很多人的迪杰斯特拉，都要源点先在循环外松弛一圈，我尝试了一下，放在循环内松弛也是可以的。所以这个有什么问题吗？** code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include&lt;bits/stdc++.h&gt;using namespace std ;const int maxn = 550 ;const int inf = 0x3f3f3f3f ;int graph[maxn][maxn];int dis[maxn];int pathnum[maxn] ;int sum[maxn];int num[maxn];bool vis[maxn];int pre[maxn];int main()&#123; for( int i = 0 ; i &lt; maxn ; i++) for(int j = 0 ; j &lt; maxn ; j++) graph[i][j] = inf; fill( dis , dis + maxn , inf ) ; memset(pathnum,0,sizeof(pathnum)); memset(sum,0,sizeof(sum)); memset(num,0,sizeof(num)); memset(vis,false,sizeof(vis)); memset(pre,0,sizeof(pre)); int N , M , S , D; cin &gt;&gt; N &gt;&gt; M &gt;&gt; S &gt;&gt; D ; pre[S] = S ; for( int i = 0 ; i &lt; N ; i++) &#123; cin &gt;&gt; num[i]; sum[i] = num[i]; &#125; for( int i = 0 ; i &lt; M ; i++) &#123; int u , v , diss ; cin &gt;&gt; u &gt;&gt; v &gt;&gt; diss; graph[u][v] = min( graph[u][v] , diss ) , graph[v][u] = min( graph[v][u] , diss ) ; &#125; graph[S][S] = 0 ; dis[S] = 0 ; pathnum[S] = 1 ; for( int i = 0 ; i &lt; N ; i++) &#123; int node = -1 , minn = inf , summ = 0 ; for( int j = 0 ; j &lt; N ; j++) &#123; if( !vis[j] &amp;&amp; minn &gt; dis[j] ) node = j , minn = dis[j] , summ = num[j] ; else if( ! vis[j] &amp;&amp; minn == dis[j] ) if( summ &lt; num[j] ) node = j , minn = dis[j] , summ = num[j] ; &#125; vis[node] = true ; for( int j = 0 ; j &lt; N ; j++) &#123; if( !vis[j] &amp;&amp; graph[node][j] + minn &lt; dis[j] ) &#123; pathnum[j] = pathnum[node]; dis[j] = graph[node][j] + minn ; sum[j] = sum[node] + num[j] ; pre[j] = node ; &#125; else if ( !vis[j] &amp;&amp; graph[node][j] + minn == dis[j] ) &#123; pathnum[j] += pathnum[node]; if( sum[j] &lt; sum[node] + num[j]) &#123; dis[j] = graph[node][j] + minn ; sum[j] = sum[node] + num[j] ; pre[j] = node ; &#125; &#125; &#125; &#125; int node = D ; stack&lt;int&gt; path ; while( pre[node] != node ) &#123; path.push(node); node = pre[node]; &#125; path.push(S); cout &lt;&lt; pathnum[D] &lt;&lt; ' ' &lt;&lt; sum[D] &lt;&lt; endl ; bool flag = false ; while( !path.empty() ) &#123; if( !flag ) &#123; cout &lt;&lt; path.top() ; flag = true ; &#125; else &#123; cout &lt;&lt; ' ' &lt;&lt; path.top() ; &#125; path.pop(); &#125; cout &lt;&lt; endl ;&#125; 错了这么多次终于A了，真的是爽到。]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>dijkstra</tag>
        <tag>CCCC</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO-Chapter2-Section2.3]]></title>
    <url>%2F8c7dbeeb.html</url>
    <content type="text"><![CDATA[快期末考试了，可能ECL FINAL结束后，会停止训练一个月左右去准备期末考试了。 这一章，刷的时间有点久啊。 1Prefix code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384 /*ID:xiekeyi1PROG:prefixLANG:C++ */#include&lt;bits/stdc++.h&gt;using namespace std ;//vector&lt;string&gt; a;//string s ; char a[210][15];int num_string = 0 ; int s_size = 0 ; char s[200100];bool vis[200100];int dfs( int n )&#123; if( vis[n] ) return 0; else vis[n] = 1 ; int ans = 0; if( n &gt;= s_size ) return s_size; for( int i = 0 ; i &lt; num_string ; i++) &#123; bool flag = true; int tt = strlen(a[i]) ; for( int j = 0 ; j &lt; tt ; j++ ) &#123; if( s[n + j ] != a[i][j] ) &#123; flag = false ; break ; &#125; &#125; if( flag ) &#123; ans = max( ans , dfs( n + tt ) ) ; &#125; &#125; return ( ans != 0 ) ? ans : n ;&#125;int main()&#123; freopen("prefix.in","r",stdin); freopen("prefix.out","w",stdout); char ch ; while( scanf("%s" , a[ num_string++]) ) if( strcmp( a[num_string - 1 ] , "." ) == 0 ) break ; num_string--;// string t ;// while( cin &gt;&gt; t &amp;&amp; t != "." )// a.push_back(t);// while( cin &gt;&gt; t )// s += t ; while( ( ch = getchar() ) != EOF ) &#123; if( ch == EOF ) break ; if( ch == ' ' || ch == '\n' ) continue ; s[ s_size++ ] = ch ; &#125; cout &lt;&lt; dfs(0) &lt;&lt; endl ;&#125; 2nocows 爆搜(TLE) code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263 /*ID:xiekeyi1PROG:nocowsLANG:C++ */#include&lt;bits/stdc++.h&gt;using namespace std ;int n , k ; int dfs( int remain_points , int now_floor , int floor )&#123; remain_points-- ; if( now_floor &gt;= floor || remain_points &lt;= 0 ) &#123; if( remain_points == 0 &amp;&amp; now_floor == floor ) return 1 ; else return 0 ; &#125; int ans = 0 ; for( int i = 0 ; i &lt;= remain_points ; i++) &#123; if( i &gt; 0 &amp;&amp; remain_points - i &gt; 0 ) &#123; int t1 = 0 ; int t2 = 0 ; t1 += dfs( i , now_floor + 1 , floor ) ; for( int j = now_floor + 1 ; j &lt;= floor - 1 ; j++) &#123; t2 += dfs( remain_points - i , now_floor + 1 , j ) ; &#125; ans += t1 * t2 ; t1 = 0 ; t2 = 0 ; t2 += dfs( remain_points - i , now_floor + 1 , floor ) ; for( int j = now_floor + 1 ; j &lt;= floor - 1 ; j++) &#123; t1 += dfs( i , now_floor + 1 , j ) ; &#125; ans += t1 * t2 ; ans += dfs( i , now_floor + 1 , floor ) * dfs( remain_points - i , now_floor + 1 , floor ) ; &#125; &#125; return ans ; &#125;int main()&#123; freopen("nocows.in","r",stdin); freopen("nocows.out","w",stdout); cin &gt;&gt; n &gt;&gt; k ; cout &lt;&lt; dfs( n , 1 , k ) % 9901 &lt;&lt; endl ;&#125; 压状态爆搜(TLE) code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778 /*ID:xiekeyi1PROG:nocowsLANG:C++ */#include&lt;bits/stdc++.h&gt;using namespace std ;int n , k ;int dfs( int remain_points , int now_floor , bool flag )&#123; remain_points-- ; if( now_floor &gt;= k || remain_points &lt;= 0 ) &#123; if( flag ) &#123; if( remain_points == 0 &amp;&amp; now_floor == k ) return 1 ; else return 0 ; &#125; else &#123; if( remain_points == 0 &amp;&amp; now_floor &lt; k ) return 1 ; else return 0 ; &#125; &#125; int ans = 0 ; for( int i = 0 ; i &lt;= remain_points ; i++) &#123; if( i &gt; 0 &amp;&amp; remain_points - i &gt; 0 ) &#123; if( flag ) &#123; int t1 = 0 ; int t2 = 0 ; t1 += dfs( i , now_floor + 1 , true ) ; t2 += dfs( remain_points - i , now_floor + 1 , false ) ; ans += t1 * t2 ; t1 = 0 ; t2 = 0 ; t2 += dfs( remain_points - i , now_floor + 1 , true ) ; t1 += dfs( i , now_floor + 1 , false ) ; ans += t1 * t2 ; ans += dfs( i , now_floor + 1 , true ) * dfs( remain_points - i , now_floor + 1 , true ) ; &#125; else &#123; ans += dfs( i , now_floor + 1 , false ) * dfs( remain_points - i , now_floor + 1 , false ) ; &#125; &#125; &#125; //printf(" dfs( %d , %d , %d ) : %d \n " , remain_points , now_floor , floor , ans ) ; return ans ; &#125;int main()&#123; freopen("nocows.in","r",stdin); freopen("nocows.out","w",stdout); cin &gt;&gt; n &gt;&gt; k ; cout &lt;&lt; dfs( n , 1 , true ) &lt;&lt; endl ; return 0 ; &#125; 压状态记忆化搜索 code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384 /*ID:xiekeyi1PROG:nocowsLANG:C++ */#include&lt;bits/stdc++.h&gt;using namespace std ;int n , k ;int dp[200][200][2];int dfs( int remain_points , int now_floor , bool flag )&#123; if( dp[remain_points][now_floor][flag] != - 1) return dp[remain_points][now_floor][flag] ; remain_points-- ; if( now_floor &gt;= k || remain_points &lt;= 0 ) &#123; if( flag ) &#123; if( remain_points == 0 &amp;&amp; now_floor == k ) return dp[remain_points + 1 ][ now_floor][flag] = 1 ; else return dp[remain_points + 1 ][now_floor][flag] = 0 ; &#125; else &#123; if( remain_points == 0 &amp;&amp; now_floor &lt; k ) return dp[remain_points+1][now_floor][flag] = 1 ; else return dp[remain_points+1][now_floor][flag] = 0 ; &#125; &#125; int ans = 0 ; for( int i = 0 ; i &lt;= remain_points ; i++) &#123; if( i &gt; 0 &amp;&amp; remain_points - i &gt; 0 ) &#123; if( flag ) &#123; int t1 = 0 ; int t2 = 0 ; t1 += dfs( i , now_floor + 1 , true ) ; t2 += dfs( remain_points - i , now_floor + 1 , false ) ; ans += ( t1 % 9901 * t2 % 9901 ) % 9901 ; t1 = 0 ; t2 = 0 ; t2 += dfs( remain_points - i , now_floor + 1 , true ) ; t1 += dfs( i , now_floor + 1 , false ) ; ans += ( t1 %9901 * t2 % 9901 ) % 9901 ; ans += dfs( i , now_floor + 1 , true ) % 9901 * dfs( remain_points - i , now_floor + 1 , true ) %9901 ; &#125; else &#123; ans += dfs( i , now_floor + 1 , false ) % 9901 * dfs( remain_points - i , now_floor + 1 , false ) % 9901 ; &#125; &#125; &#125; //printf(" dfs( %d , %d , %d ) : %d \n " , remain_points , now_floor , floor , ans ) ; return dp[remain_points+1][now_floor][flag] = ans % 9901 ; &#125;int main()&#123; freopen("nocows.in","r",stdin); freopen("nocows.out","w",stdout); memset( dp , -1 , sizeof(dp ) ) ; cin &gt;&gt; n &gt;&gt; k ; cout &lt;&lt; dfs( n , 1 , true ) % 9901 &lt;&lt; endl ; return 0 ; &#125; 四次方DP code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061 /*ID:xiekeyi1PROG:nocowsLANG:C++ */#include&lt;bits/stdc++.h&gt;using namespace std ;const int maxn = 200 + 10 , maxk = 100 + 10 ;const int modp = 9901 ;int n , k ;int dp[maxn][maxk]; // dp[i][j] means the number of schemes with points i in floor j ;int main()&#123; freopen("nocows.in","r",stdin); freopen("nocows.out","w",stdout); cin &gt;&gt; n &gt;&gt; k ; dp[1][1] = 1 ; for( int now_floor = 1 ; now_floor &lt;= k ; now_floor++) &#123; for( int now_point = 1 ; now_point &lt;= n ; now_point++ ) &#123; for( int enum_point = 1 ; enum_point &lt;= now_point - 1 ; enum_point++) &#123; int less_than_nowfloor = 0 ; for( int enum_floor = 1 ; enum_floor &lt;= now_floor - 2 ; enum_floor++ ) less_than_nowfloor += dp[ now_point - 1 - enum_point ][ enum_floor ] % modp ; less_than_nowfloor %= modp ; dp[now_point][now_floor] += dp[ enum_point ][ now_floor - 1 ] % modp * less_than_nowfloor % modp ; dp[now_point][now_floor] %= modp ; less_than_nowfloor = 0 ; for( int enum_floor = 1 ; enum_floor &lt;= now_floor - 2 ; enum_floor++ ) less_than_nowfloor += dp[enum_point][enum_floor] % modp ; less_than_nowfloor %= modp ; dp[now_point][now_floor] += less_than_nowfloor % modp * dp[ now_point - 1 - enum_point][now_floor-1] % modp ; dp[now_point][now_floor] %= modp ; dp[now_point][now_floor] += dp[ enum_point][now_floor-1] % modp * dp[ now_point - 1 - enum_point][now_floor-1] % modp ; dp[now_point][now_floor] %= modp ; &#125; &#125; &#125; cout &lt;&lt; dp[n][k] % modp &lt;&lt; endl ;&#125; 三次方DP code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354 /*ID:xiekeyi1PROG:nocowsLANG:C++ */#include&lt;bits/stdc++.h&gt;using namespace std ;const int maxn = 200 + 10 , maxk = 100 + 10 ;const int modp = 9901 ;int n , k ;int dp[maxn][maxk]; // dp[i][j] means the number of schemes with points i in floor j ;int sum[maxn][maxk]; // sum[i][j] means the number of schemes with points i less floor j ; int main()&#123; freopen("nocows.in","r",stdin); freopen("nocows.out","w",stdout); cin &gt;&gt; n &gt;&gt; k ; dp[1][1] = 1 ; for( int i = 1 ; i &lt;= k ; i++) sum[1][i] = 1 ; for( int now_floor = 1 ; now_floor &lt;= k ; now_floor++) &#123; for( int now_point = 1 ; now_point &lt;= n ; now_point++ ) &#123; for( int enum_point = 1 ; enum_point &lt;= now_point - 1 ; enum_point++) &#123; dp[now_point][now_floor] += dp[enum_point][now_floor-1] * sum[now_point - enum_point - 1 ][ now_floor-2]; dp[now_point][now_floor] += dp[now_point-enum_point-1][now_floor-1] * sum[enum_point][ now_floor-2]; dp[now_point][now_floor] += dp[now_point-enum_point-1][now_floor-1] * dp[enum_point][now_floor-1]; dp[now_point][now_floor] %= modp ; &#125; for( int j = 1 ; j &lt;= now_floor ; j++) sum[now_point][j] = ( sum[now_point][j-1] + dp[now_point][j] ) % modp ; &#125; &#125; cout &lt;&lt; dp[n][k] % modp &lt;&lt; endl ;&#125; 3zerosum code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152 /*ID:xiekeyi1PROG: zerosum LANG: C++11 */#include&lt;bits/stdc++.h&gt;using namespace std ;string s ; int n ;vector&lt;string&gt; a ; void dfs( int pos , string sss )&#123; //if( sss == "1-2 3+4+5+6+7" ) // cout &lt;&lt; sss &lt;&lt; endl ; if( pos &gt;= n - 1 ) &#123; int ans = 0 ; bool flag = true ; for( int i = 0 ; i &lt; sss.size() ; i++) &#123; if( i == 0 &amp;&amp; flag ) &#123; flag = false ; int num = 0 ; for( int j = i ; j &lt; sss.size() ; j++) &#123; if( sss[j] == '+' ) &#123; i = j - 1 ; break ; &#125; else if( sss[j] == '-' ) &#123; i = j - 1 ; break ; &#125; else if( sss[j] == ' ' ) num *= 10 ; else num += sss[j] - '0' ; &#125; ans = num ; &#125; else if( sss[i] == '+' || sss[i] == '-' ) &#123; char ch ; if( sss[i] == '+' ) &#123; ch = '+' ;&#125; if( sss[i] == '-' ) &#123; ch = '-' ;&#125; int num = 0 ; for( int j = i + 1 ; j &lt; sss.size() ; j++) &#123; if( sss[j] == '+' ) &#123; i = j - 1 ; break ; &#125; else if( sss[j] == '-' ) &#123; i = j - 1 ; break ; &#125; else if( sss[j] == ' ' ) num *= 10 ; else num += sss[j] - '0' ; &#125; ans = ( ( ch == '+' ) ? ( ans + num ) : ( ans - num ) ) ; &#125; &#125; if( ans == 0 ) &#123; sss.push_back('\n' ) ; a.push_back(sss); &#125; &#125; else &#123; string t ; t = sss; t.insert( t.begin() + pos + 1 , ' ' ); dfs( pos + 2 , t ) ; t = sss ; t.insert( t.begin() + pos + 1 , '+' ) ; dfs( pos + 2 , t ) ; t = sss; t.insert( t.begin() + pos + 1 , '-' ); dfs( pos + 2 , t ) ; &#125; return ;&#125;const bool cmp( const string &amp;s1 , const string &amp;s2 )&#123; for( int i = 0 ; i &lt; s1.size() ; i++) &#123; if( s1[i] == s2[i] ) continue; else &#123; if( s1[i] == ' ' ) return true ; else if( s1[i] == '+' ) &#123; if( s2[i] == '-' || s2[i] == ' ' ) return false ; else return true ; &#125; else if( s1[i] == '-' ) &#123; if( s2[i] == '+' || s2[i] == ' ' ) return false ; else return true ; &#125; &#125; &#125; return false ; &#125;int main()&#123; freopen("zerosum.in","r",stdin); freopen("zerosum.out","w",stdout); cin &gt;&gt; n ; string ss ; for( int i = 1 ; i &lt;= n ; i++) s += i + '0' ; n += n - 1 ; ss = s ; dfs( 0 , ss ) ; sort( a.begin() , a.end() , cmp ) ; for( auto i : a ) cout &lt;&lt; i ; return 0 ;&#125; 4money 记忆化搜索 code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748 /*ID:xiekey1PROG:moneyLANG:C++*/#include&lt;bits/stdc++.h&gt;using namespace std;const int maxv = 30 , maxn = 10010 ; int v , n ;int a[maxv] ;long long dp[maxn][maxv];long long dfs( int n , int i )&#123; if( dp[n][i] != - 1 ) return dp[n][i] ; if( n == 0 ) return dp[n][i] = 1 ; if( i &gt; v ) return dp[n][i] = 0 ; long long ans = 0; for( int j = 0 ; j * a[i] &lt;= n ; j++) &#123; ans += dfs( n - j * a[i] , i + 1 ) ; &#125; return dp[n][i] = ans ; &#125;int main()&#123; freopen("money.in","r",stdin); freopen("money.out","w",stdout); memset( dp , -1 , sizeof( dp ) ) ; cin &gt;&gt; v &gt;&gt; n ; for( int i = 1 ; i &lt;= v ; i++) cin &gt;&gt; a[i] ; cout &lt;&lt; dfs( n , 1 ) &lt;&lt; endl ;&#125; 多重背包 code123456789101112131415161718192021222324252627282930313233343536373839404142 /*ID:xiekey1PROG:moneyLANG:C++*/#include&lt;bits/stdc++.h&gt;using namespace std ;const int maxv = 30 , maxn = 10010 ; int v , n ;int a[maxv] ;long long dp[maxv][maxn];int main()&#123; freopen("money.in","r",stdin); freopen("money.out","w",stdout); cin &gt;&gt; v &gt;&gt; n ; for( int i = 1 ; i &lt;= v ; i++) cin &gt;&gt; a[i] ; memset(dp,0,sizeof(dp)); dp[0][0] = 1 ; for( int i = 1 ; i &lt;= v ; i++) &#123; for( int j = 0 ; j &lt;= n ; j++) &#123; for( int k = 0 ; k * a[i] &lt;= j ; k++) &#123; dp[i][j] += dp[i-1][j-k*a[i]] ; &#125; &#125; &#125; cout &lt;&lt; dp[v][n] &lt;&lt; endl ; return 0 ;&#125; 完全背包 code1234567891011121314151617181920212223242526272829303132333435363738394041424344 /*ID:xiekey1PROG:moneyLANG:C++*/#include&lt;bits/stdc++.h&gt;using namespace std;const int maxv = 30 , maxn = 10010 ;int v , n ;long long dp[maxv][maxn];int a[maxv];int main()&#123; freopen("money.in","r",stdin); freopen("money.out","w",stdout); cin &gt;&gt; v &gt;&gt; n ; for( int i = 1 ; i &lt;= v ; i++) cin &gt;&gt; a[i]; memset( dp , 0 , sizeof(dp) ) ; dp[0][0] = 1 ; for( int i = 1 ; i &lt;= v ; i++) &#123; for( int j = 0; j &lt;= n ; j++) &#123; if( j &gt;= a[i] ) dp[i][j] = dp[i-1][j] + dp[i][ j - a[i] ] ; else dp[i][j] = dp[i-1][j] ; &#125; &#125; cout &lt;&lt; dp[v][n] &lt;&lt; endl ; return 0 ;&#125; 5Controlling Companies code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768 /*ID:xiekeyi1PROG:concomLANG:C++11*/#include&lt;bits/stdc++.h&gt;using namespace std ;const int maxn = 100 + 10 ;int graph[maxn][maxn];int max_num = 0 ; int own[maxn] ; bool vis[maxn]; void dfs( int n )&#123; for( int i = 1 ; i &lt;= max_num ; i++) &#123; own[i] += graph[n][i] ; if( i != n &amp;&amp; !vis[i] &amp;&amp; own[i] &gt;= 50 ) &#123; vis[i] = true ; dfs( i ); &#125; &#125; return ; &#125;int main()&#123; freopen("concom.in","r",stdin); freopen("concom.out","w",stdout); int n ; cin &gt;&gt; n ; for( int i = 1 ; i &lt;= n ; i++) &#123; int x , y ; cin &gt;&gt; x &gt;&gt; y ; cin &gt;&gt; graph[x][y] ; max_num = max( &#123; max_num , x , y &#125; ) ; &#125; string ans ; for( int i = 1 ; i &lt;= max_num ; i++) &#123; memset(own,0,sizeof(own)); memset(vis,0,sizeof(vis)); dfs(i); for( int j = 1 ; j &lt;= max_num ; j++) &#123; if( i != j &amp;&amp; own[j] &gt;= 50 ) &#123; cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; j &lt;&lt; endl ; &#125; &#125; &#125; return 0 ; &#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>USACO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO-2.2.2-Nocows-DP]]></title>
    <url>%2Fd94f5e84.html</url>
    <content type="text"><![CDATA[给定\(N\)、\(K\)，求由\(N\)个节点、构造出的\(K\)层完全二叉树的方案数。 题意: 题目描述 农民约翰准备购买一群新奶牛。 在这个新的奶牛群中, 每一个母亲奶牛都生两个小奶牛。这些奶牛间的关系可以用二叉树来表示。这些二叉树总共有\(N\)个节点($ 3 N &lt; 200 $)。这些二叉树有如下性质: 每一个节点的度是\(0\)或\(2\)。度是这个节点的孩子的数目。 树的高度等于\(K\)(\(1 &lt; K &lt; 100\))。高度是从根到最远的那个叶子所需要经过的结点数; 叶子是指没有孩子的节点。 有多少不同的家谱结构? 如果一个家谱的树结构不同于另一个的, 那么这两个家谱就是不同的。输出可能的家谱数的个数除以\(9901\)的余数。 输入格式： 两个空格分开的整数, N和K。 输出格式： 一个整数，表示可能的家谱树的个数除以9901的余数。 输入输出样例 输入样例#1： 5 3 输出样例#1： 2 说明 翻译来自NOCOW USACO 2.3 做法： 暴搜(TLE) 对于已知\(1到i\)层二叉树的方案数，想要在此之上构建出第\(i+1\)层的方案数。我们的方法有： 1. 左子树是\(i\)层，右子树是\(1到i-1\)层。(在这种情况下，上面加一个根节点) 2. 左子树是\(1到i-1\)层，右子树是\(i\)层。(在这种情况下，上面加一个根节点) 3. 左右子树都是\(i\)层。(在这种情况下，上面加一个根节点) 按照这个方法，可以递归去生成这么一颗树。但是我们并不知道左右子树的节点个数，所以我们还要枚举节点个数。 因此，我们可以定义函数dfs( remain_points , now_floor , floor ) 表示使用remain_points个节点，构建floor的方案数。按照上面的方法去生成即可。 代码： code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960 /*ID:xiekeyi1PROG:nocowsLANG:C++*/#include&lt;bits/stdc++.h&gt;using namespace std ;int n , k ; int dfs( int remain_points , int now_floor , int floor )&#123; remain_points-- ; // 减去当前的根节点。 if( now_floor &gt;= floor || remain_points &lt;= 0 ) // 超过当前要求的层数或剩余节点小于0即退出。 &#123; if( remain_points == 0 &amp;&amp; now_floor == floor ) // 当当前层数和剩余节点都满足时为合格方案数。 return 1 ; else return 0 ; &#125; int ans = 0 ; // 枚举，i表示对左子树分配的节点，对右子树分配 remian_points - i个节点。 for( int i = 0 ; i &lt;= remain_points ; i++) &#123; if( i &gt; 0 &amp;&amp; remain_points - i &gt; 0 ) // 因为对度数有0或者2的要求，所以左右子树都要大于0. &#123; // 第一种情况，左子树是i层，右子树是 1 到 i - 1 层。 int t1 = 0 ; int t2 = 0 ; t1 += dfs( i , now_floor + 1 , floor ) ; for( int j = now_floor + 1 ; j &lt;= floor - 1 ; j++) &#123; t2 += dfs( remain_points - i , now_floor + 1 , j ) ; &#125; ans += t1 * t2 ; // 第二种情况， 左子树是1到i-1层，右子树是i层。 t1 = 0 ; t2 = 0 ; t2 += dfs( remain_points - i , now_floor + 1 , floor ) ; for( int j = now_floor + 1 ; j &lt;= floor - 1 ; j++) &#123; t1 += dfs( i , now_floor + 1 , j ) ; &#125; ans += t1 * t2 ; // 第三种情况，左右两个子树都是i层。 ans += dfs( i , now_floor + 1 , floor ) * dfs( remain_points - i , now_floor + 1 , floor ) ; &#125; &#125; return ans ; &#125;int main()&#123; freopen("nocows.in","r",stdin); freopen("nocows.out","w",stdout); cin &gt;&gt; n &gt;&gt; k ; cout &lt;&lt; dfs( n , 1 , k ) % 9901 &lt;&lt; endl ;&#125; 这样的代码毫无疑问是会T的。时间复杂度\(O( n * 2^k )\) 然后我想用我无往不利的将dfs改成记忆化搜索，我想那样的话就肯定可以过。 结果用和dfs参数类似的数组dp[maxn][maxk][maxk]改记忆化搜索后，\(MLE\)了(说来搞ACM，好久没遇到MLE了2333。感觉一直对空间限制都不是很严格。没想到USACO限制挺严格的。)。 压状态爆搜(TLE) 因为我们dp[maxn][maxk][maxk]爆空间了。毫无疑问是我们的状态太多了。因此，我们不得不去压缩一下状态。 考虑到对于floor这个参数来说，其实完全没有必要记录\(1到k\)每一个的状态。对于我们来说，只关心是等于k还是小于k即可。 所以我们修改dfs为dfs( remain_points , now_floor , flag )，用一个二维状态表示即可(不过这个修改，我还改了挺长时间的。改起来挺麻烦的)。 代码: code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182 /*ID:xiekeyi1PROG:nocowsLANG:C++ */#include&lt;bits/stdc++.h&gt;using namespace std ;int n , k ;int dfs( int remain_points , int now_floor , bool flag )&#123; remain_points-- ; if( now_floor &gt;= k || remain_points &lt;= 0 ) &#123; if( flag ) &#123; // 如果是要到达k层，那么只有到k层才能返回1. if( remain_points == 0 &amp;&amp; now_floor == k ) return 1 ; else return 0 ; &#125; else &#123; // 如果要求小于k层，则只有这种情况才能返回1. if( remain_points == 0 &amp;&amp; now_floor &lt; k ) return 1 ; else return 0 ; &#125; &#125; int ans = 0 ; for( int i = 0 ; i &lt;= remain_points ; i++) &#123; if( i &gt; 0 &amp;&amp; remain_points - i &gt; 0 ) &#123; if( flag ) &#123; // 当flag是true时，对应上文的三种情况。 //即就是，左边true右边false，右边true，左边false，两边true的情况。 int t1 = 0 ; int t2 = 0 ; t1 += dfs( i , now_floor + 1 , true ) ; t2 += dfs( remain_points - i , now_floor + 1 , false ) ; ans += t1 * t2 ; t1 = 0 ; t2 = 0 ; t2 += dfs( remain_points - i , now_floor + 1 , true ) ; t1 += dfs( i , now_floor + 1 , false ) ; ans += t1 * t2 ; ans += dfs( i , now_floor + 1 , true ) * dfs( remain_points - i , now_floor + 1 , true ) ; &#125; else &#123; // 否则只有一种情况，就是两边都是false的情况。 ans += dfs( i , now_floor + 1 , false ) * dfs( remain_points - i , now_floor + 1 , false ) ; &#125; &#125; &#125; //printf(" dfs( %d , %d , %d ) : %d \n " , remain_points , now_floor , floor , ans ) ; return ans ; &#125;int main()&#123; freopen("nocows.in","r",stdin); freopen("nocows.out","w",stdout); cin &gt;&gt; n &gt;&gt; k ; cout &lt;&lt; dfs( n , 1 , true ) &lt;&lt; endl ; return 0 ; &#125; 这个代码的时间复杂度和上面的方法没有本质的区别。因此毫无疑问，依然是一个\(TLE\)的代码。 所以需要加上记忆化搜索。 压状态记忆化搜索(AC) 我们用dp[maxn][maxk][flag] 表示一个状态，加上记忆化搜索后。 代码如下： code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384 /*ID:xiekeyi1PROG:nocowsLANG:C++ */#include&lt;bits/stdc++.h&gt;using namespace std ;int n , k ;int dp[200][200][2];int dfs( int remain_points , int now_floor , bool flag )&#123; if( dp[remain_points][now_floor][flag] != - 1) return dp[remain_points][now_floor][flag] ; remain_points-- ; if( now_floor &gt;= k || remain_points &lt;= 0 ) &#123; if( flag ) &#123; if( remain_points == 0 &amp;&amp; now_floor == k ) return dp[remain_points + 1 ][ now_floor][flag] = 1 ; else return dp[remain_points + 1 ][now_floor][flag] = 0 ; &#125; else &#123; if( remain_points == 0 &amp;&amp; now_floor &lt; k ) return dp[remain_points+1][now_floor][flag] = 1 ; else return dp[remain_points+1][now_floor][flag] = 0 ; &#125; &#125; int ans = 0 ; for( int i = 0 ; i &lt;= remain_points ; i++) &#123; if( i &gt; 0 &amp;&amp; remain_points - i &gt; 0 ) &#123; if( flag ) &#123; int t1 = 0 ; int t2 = 0 ; t1 += dfs( i , now_floor + 1 , true ) ; t2 += dfs( remain_points - i , now_floor + 1 , false ) ; ans += ( t1 % 9901 * t2 % 9901 ) % 9901 ; t1 = 0 ; t2 = 0 ; t2 += dfs( remain_points - i , now_floor + 1 , true ) ; t1 += dfs( i , now_floor + 1 , false ) ; ans += ( t1 %9901 * t2 % 9901 ) % 9901 ; ans += dfs( i , now_floor + 1 , true ) % 9901 * dfs( remain_points - i , now_floor + 1 , true ) %9901 ; &#125; else &#123; ans += dfs( i , now_floor + 1 , false ) % 9901 * dfs( remain_points - i , now_floor + 1 , false ) % 9901 ; &#125; &#125; &#125; //printf(" dfs( %d , %d , %d ) : %d \n " , remain_points , now_floor , floor , ans ) ; return dp[remain_points+1][now_floor][flag] = ans % 9901 ; &#125;int main()&#123; freopen("nocows.in","r",stdin); freopen("nocows.out","w",stdout); memset( dp , -1 , sizeof(dp ) ) ; cin &gt;&gt; n &gt;&gt; k ; cout &lt;&lt; dfs( n , 1 , true ) % 9901 &lt;&lt; endl ; return 0 ; &#125; 成功AC。 四次方DP(AC） 考虑改写成DP形式。 用dp[i][j]表示使用\(i\)个节点，恰好构成\(j\)层的方案数。 则dp的转移方程，和上文所说的三种情况一样。枚举两维，二维转移即可。 代码： code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162 /*ID:xiekeyi1PROG:nocowsLANG:C++ */#include&lt;bits/stdc++.h&gt;using namespace std ;const int maxn = 200 + 10 , maxk = 100 + 10 ;const int modp = 9901 ;int n , k ;int dp[maxn][maxk]; // dp[i][j] means the number of schemes with points i in floor j ;int main()&#123; freopen("nocows.in","r",stdin); freopen("nocows.out","w",stdout); cin &gt;&gt; n &gt;&gt; k ; dp[1][1] = 1 ; // 边界情况，1个节点构成1层是一个方案，其他都是0. //枚举每一层。 for( int now_floor = 1 ; now_floor &lt;= k ; now_floor++) &#123; //枚举对于第now_floor层来说，用1到n个节点构造的情况。 for( int now_point = 1 ; now_point &lt;= n ; now_point++ ) &#123; //枚举对于第now_floor层，用now_point节点构造。 // 用enum_point去构造左子树，用 now_point - 1 - enum_point构造右子树。 for( int enum_point = 1 ; enum_point &lt;= now_point - 1 ; enum_point++) &#123; int less_than_nowfloor = 0 ; // 统计左子树是i-1层，右子树从 1到i- 2层的情况(对应讨论1) for( int enum_floor = 1 ; enum_floor &lt;= now_floor - 2 ; enum_floor++ ) less_than_nowfloor += dp[ now_point - 1 - enum_point ][ enum_floor ] % modp ; less_than_nowfloor %= modp ; dp[now_point][now_floor] += dp[ enum_point ][ now_floor - 1 ] % modp * less_than_nowfloor % modp ; dp[now_point][now_floor] %= modp ; // 统计左子树是1到i - 2 层，右子树是i-1层的情况(对应讨论2) less_than_nowfloor = 0 ; for( int enum_floor = 1 ; enum_floor &lt;= now_floor - 2 ; enum_floor++ ) less_than_nowfloor += dp[enum_point][enum_floor] % modp ; less_than_nowfloor %= modp ; dp[now_point][now_floor] += less_than_nowfloor % modp * dp[ now_point - 1 - enum_point][now_floor-1] % modp ; dp[now_point][now_floor] %= modp ; // 统计当两边都是i-1层的情况(对应讨论3) dp[now_point][now_floor] += dp[ enum_point][now_floor-1] % modp * dp[ now_point - 1 - enum_point][now_floor-1] % modp ; dp[now_point][now_floor] %= modp ; &#125; &#125; &#125; cout &lt;&lt; dp[n][k] % modp &lt;&lt; endl ;&#125; 三次方DP(AC) 注意到四次方DP，每次都重复计算了\(1到i-2\)层的情况。因此我们考虑可以使用数组sum[i][j]表示使用\(i\)个节点，构成的少于\(j\)层的方案数。 代码： code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455 /*ID:xiekeyi1PROG:nocowsLANG:C++ */#include&lt;bits/stdc++.h&gt;using namespace std ;const int maxn = 200 + 10 , maxk = 100 + 10 ;const int modp = 9901 ;int n , k ;int dp[maxn][maxk]; // dp[i][j] means the number of schemes with points i in floor j ;int sum[maxn][maxk]; // sum[i][j] means the number of schemes with points i less floor j ; int main()&#123; freopen("nocows.in","r",stdin); freopen("nocows.out","w",stdout); cin &gt;&gt; n &gt;&gt; k ; dp[1][1] = 1 ; for( int i = 1 ; i &lt;= k ; i++) sum[1][i] = 1 ; //枚举每一层 for( int now_floor = 1 ; now_floor &lt;= k ; now_floor++) &#123; // 枚举对于第now_floor层，使用1到n个节点去构造。 for( int now_point = 1 ; now_point &lt;= n ; now_point++ ) &#123; //枚举左子树节点个数。 for( int enum_point = 1 ; enum_point &lt;= now_point - 1 ; enum_point++) &#123; // 对应讨论1 dp[now_point][now_floor] += dp[enum_point][now_floor-1] * sum[now_point - enum_point - 1 ][ now_floor-2]; // 对应讨论2 dp[now_point][now_floor] += dp[now_point-enum_point-1][now_floor-1] * sum[enum_point][ now_floor-2]; // 对应讨论3. dp[now_point][now_floor] += dp[now_point-enum_point-1][now_floor-1] * dp[enum_point][now_floor-1]; dp[now_point][now_floor] %= modp ; &#125; // 这个方法的核心。 // 维护sum数组。 for( int j = 1 ; j &lt;= now_floor ; j++) sum[now_point][j] = ( sum[now_point][j-1] + dp[now_point][j] ) % modp ; &#125; &#125; cout &lt;&lt; dp[n][k] % modp &lt;&lt; endl ;&#125; 这个sum数组用了前缀和的思想。一开始我把sum数组放到了第三层循环里面，变成了四次方的DP。结果答案是对的，但是\(TLE\)了。(上面那个四次方DP能过大概是因为枚举的状态少一些吧。每次不一定把循环跑满了。) 因为我们把dp方程写成加和的形式，会发现: \[sum[i][nowfloor-2]=\\sum_{j=1}^{nowfloor-2}{sum[i][j]}\] 也就是说，每次更新了dp[now_point][now_floor]数组后，sum数组显然需要一同更新。 因为每次更新的时候dp的时候，now_point都是新出现的，所以这一维不需要去变化。而层数因为sum[now_point][now_floor]表示的是小于now_floor的情况，所以所有大于等于now_floor等都应该遍历去更新。这里可以利用构造前缀和的思想去操作。 （关于转移而来的状态，由代码很容易看出都是已经被计算过的) 三次方DP(AC) 看到有题解使用的方法是，用dp[i][j]表示用i个节点，构造出的小于等于j个节点的情况。然后最终答案是dp[n][k] - dp[n-1][k]。 这个方法也很巧妙。代码量极少。我认为这个方法是把我上一个方法的dp数组和sum数组结合起来而产生的dp方法。 因为复杂度和我的代码区别不是很大，加上别人的这个想法我目前理解的不是很透彻，也并非我自己独立思考得来，这道题我也想了五六天了。所以这个方法暂时没有去花时间思考和实现。有机会可能会补上。 一些优化 这道题还有一些优化部分。 如 - 注意到每层字数分配的节点肯定都是奇数个，所以可以以2递增。 - 对于每层子树，很容易计算出最大节点数。借此剪枝。]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>USACO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO-2.3.4-MoneySystems-背包]]></title>
    <url>%2Ff7932c4a.html</url>
    <content type="text"><![CDATA[(记忆化搜索 完全背包 多重背包)求方案数。 题意： 题目描述 母牛们不但创建了它们自己的政府而且选择了建立了自己的货币系统。由于它们特殊的思考方式，它们对货币的数值感到好奇。 传统地，一个货币系统是由\(1,5,10,20\)或\(25,50,\)和\(100\)的单位面值组成的。 母牛想知道有多少种不同的方法来用货币系统中的货币来构造一个确定的数值。 举例来说, 使用一个货币系统 \({1,2,5,10,...}\)产生\(18\)单位面值的一些可能的方法是: $ 18x1, 9x2, 8x2+2x1, 3x5+2+1$ ,等等其它。 写一个程序来计算有多少种方法用给定的货币系统来构造一定数量的面值。保证总数将会适合long long (C/C++) 和 Int64 (Free Pascal)，即在\(0\)到\(2^{63}-1\)之间。 输入输出格式 输入格式： 货币系统中货币的种类数目是 V ($ 1 V 25 $)。要构造的数量钱是 N (\(1 \leq N \leq10,000\))。 第一行: 二个整数，V 和 N 。 第二行： 可用的货币的面值 。 输出格式: 单独的一行包含那个可能的用这v种硬币凑足n单位货币的方案数。 输入输出样例 输入样例#1： 3 10 1 2 5 输出样例#1： 10 说明 翻译来自NOCOW USACO 2.3 做法： 一开始考虑dfs。 本来考虑的是用dfs(i)表示，当前还剩下n块钱没有组成。用下面这种方法去解决。 1234for( int i = 1 ; i &lt;= v ; i++) if( n &gt;= a[i] ) dfs( n - a[i] ) ;// 退出条件是 n == 0 不过这种方法，后来发现有点蠢。因为我无法处理比如：先选\(1\)后选\(2\) 和 先选\(2\)后选\(1\)这样的重复情况。想了一下如何去重，发现去重的话，不同情况下不一样。应该是自己走远了。 之后又感觉有点像多重背包。不过自己胡乱操作了一番，用USACO-2-2-2-subset-01背包求方案数曾经自己总结过的，感觉不错的方法来做多重背包，发现遇到了很多问题。 因为曾经的方法的不足，感觉有很多变量很多余，或者不知道用来存什么记录什么，比如dp和cnt数组就不知道存什么。 曾经的不足即：只是求方案的话，完全没必要去开dp数组，只要一个cnt其实就可以了。我现在回过头来看，感觉dp数组里存的东西很奇怪，完全没必要啊。dp[i][j]难道表示的是前\(i\)个物品装到容量为\(j\)的背包里，最大价值吗？ 感觉完全没必要了。。 这也暴露了自己的一个问题： 1. 对于问题要勤思考，不能生搬硬套。否则就会发现很多东西很模糊不确定，又因为是曾经总结过的，所以又不太敢随意修改。这有点像郑人买履了。以后要尽可能的去思考，有自己的想法，并且敢于去修改和质疑模板的问题。 2. 就算曾经总结过的东西，以后也要反复总结、提炼，不能满足于以前总结的。因为即使曾经总结过的东西，过一段时间提高后再回头看，发现依然有很多不足和问题。所以要不断总结，哪怕之前总结过。 说的有点跑题了。 后来发现那种dfs行不通以后，我考虑用dfs(n,i)表示，当前还剩下\(n\)个钱没有被表示，目前是第\(i\)枚硬币。 这样写下来的代码为： code12345678910111213141516171819 long long dfs( int n , int i )&#123; if( dp[n][i] != - 1 ) return dp[n][i] ; if( n == 0 ) return dp[n][i] = 1 ; if( i &gt; v ) return dp[n][i] = 0 ; long long ans = 0; // 枚举对于当前第i枚硬币，可以用 0 ..到 j * a[i]枚。 for( int j = 0 ; j * a[i] &lt;= n ; j++) &#123; ans += dfs( n - j * a[i] , i + 1 ) ; &#125; return dp[n][i] = ans ; &#125; 成功AC。 看到这个dfs后，感觉就是多重背包的意思啊。所以又进一步想了下如何改成多重背包。 对于多重背包来讲，用dp[i][j]表示对于i个物品，放在容积为j的背包里的方案数(这里之前的博客里就是有点问题，表达的太啰嗦了)。那么边界条件就是dp[0][0] = 1 , dp[others][others] = 0 显然只有\(0\)个物品，放在\(0\)的背包里的方案数是\(1\)，除此之外其他都是\(0\)。 转移的话，只是再加一个维度，考虑对于当前的物品可以考虑放\(0\)到$ j * a[i] n$个情况。转移即可。 1234567891011dp[0][0] = 1 ;for( int i = 1 ; i &lt;= v ; i++)&#123; for( int j = 0 ; j &lt;= n ; j++) &#123; for( int k = 0 ; k * a[i] &lt;= j ; k++) &#123; dp[i][j] += dp[i-1][j-k*a[i]] ; &#125; &#125;&#125; PS： 多重背包正常是有优化的，可以用二进制拆分后看做是01背包。 之后，对背包学艺不精的我突然发现，这其实是完全背包！多重背包是对于物品使用次数是有限制的，这个没有限制，所以应该是完全背包。 完全背包的话，正常的滚动数组的写法其实就是和01背包顺序相反而已。因为对于01背包来说，决策的状态必须对于每个物品放或者不放决策一次，不能重复。而完全背包因为物品可以随便选，决策过的可以再决策再选择一次，所以可以从曾计算过的状态再决策得来。 因为初学，所以这些都还没有使用滚动数组。不过这也导致自己在写完全背包的时候遇到了一点困难。网上的都是滚动数组优化过的，当我想写一个不优化的方便理解的时候，发现找不到代码。 1234567891011dp[0][0] = 1 ;for( int i = 1 ; i &lt;= v ; i++)&#123; for( int j = 0; j &lt;= n ; j++) &#123; if( j &gt;= a[i] ) dp[i][j] = dp[i-1][j] + dp[i][ j - a[i] ] ; else dp[i][j] = dp[i-1][j] ; &#125;&#125; 这个一开始遇到的坑是，模仿别人的滚动数组的j = a[i] .. n ，然后答案总是差一点。后来发现问题是因为对于$ j &lt; a[i]$的时候，状态应该移动过来。不然的话计算出来的状态其实是有缺失的。滚动数组的写法省了这个问题，所以自己一直没注意到。 这个主要的决策问题就是dp[i][j] = dp[i-1][j] + dp[i][ j - a[i] ]; 。 对于01背包来说，只有选或者不选两种。应该都是从上一个物品的情况转移而来，这样对于当前物品来说，只会有不选当前物品，从dp[i-1][j]转移，和选了当前物品，从dp[i-1][j-a[i]]转移，这两种情况都是没有选当前物品的，转移过来的话，也只会是没选和选。不过出现选择多个的情况。 但是因为对于完全背包来说，已经选择过的物品可以再次选择，所以我们应该是从之前已经决策过拿还是没拿的物品转移而来。对于dp[i][j-a[i]]这个状态来说，可能之前已经拿过第i个物品，也可能没拿过，但是who cares? 因为我物品是没有限制的，所以只要直接这么决策过来就可以了。 对于目前的这些知识，自己还只是雏形，理解不是很透彻。在这个阶段本文是对自己的思路进行一下简单整理和总结，便于以后提高。有错误的话十分麻烦各位能花一点点时间指出出来。 最近对DP这类问题，发现自己总是爱用记忆化搜索的方法去写。总是先想搜索，然后才能转成递推。而网上的答案和代码等几乎都是清一色的递推的方法。一开始我以为只是因为递推常数小，所以写熟练了大家都是这样直接写递推的,对于这个问题只是我自己的思维差异，不需要太重视。 后来问了一下学长，学长表示：“这个问题还是挺需要注意的，很多时候DP用递推比用记忆化要好写很多。而且递推这种思维方法其实才是DP的本质。也就是先想状态再想转移最后想边界，状态和转移有了的话，很多时候就能写递推了。”学长建议我以后思考尽量用递推，代码会比较少，也比较好调试。而且这种思维方法挺需要注意的。]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>USACO</tag>
        <tag>背包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO-2.3.1-LongestPrefix-搜索DP]]></title>
    <url>%2F2a04174f.html</url>
    <content type="text"><![CDATA[感觉自己最近对时间复杂度的计算越来越吃力了。尤其是记忆化搜索的时间复杂度。 题意： 给出N个字符串，和一个字符串S。求能由这N个字符串随意组成(可重复使用)，组成的串和S的前缀最大匹配是多长？ 做法： 开始想的就是DFS。对于S中的第i个位置来来说，枚举所有的N个字符串，那么如果可以匹配，dfs转移到 i + 所匹配的串长度即可。 不过不停的TLE( 1.7s )，一开始我以为是因为我用的vector&lt;string&gt;之类的STL的原因。于是改成C语言风格，依然不行。 于是想了一下，一开始以为是贪心的去选取最大的可匹配的，或者最长的之类的策略。可是这样的话，会过不了比如：N个字符串是ab、aaaa 和aaa 匹配字符串S aaaab的话，就不行。 类似的反例很多。 想了一下，发现可以改成记忆化。对于第i个位置来说，如果能达到，就加个标记。之后搜索到这个位置，就return即可。 这样就有效避免了，对于S很长重复很多，N个字符串有很多很短。然后第i个位置可以由前面的串好多种方法组合得到，导致反复计算。 因为，第i个串只要有一种能达到即可，一种方法还是多种，对之后的决策和选择都没有影响。这样保证了前面的串只要能达到都会只计算一种能达到的情况，并且不会重复计算。 代码: code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586 /*ID:xiekeyi1PROG:prefixLANG:C++ */#include&lt;bits/stdc++.h&gt;using namespace std ;//vector&lt;string&gt; a;//string s ; char a[210][15]; //存放n个串int num_string = 0 ; // N个串的个数int s_size = 0 ; // S的长度char s[200100]; bool vis[200100];int dfs( int n )&#123; // 标记 if( vis[n] ) return 0; else vis[n] = 1 ; int ans = 0; if( n &gt;= s_size ) return s_size; //枚举n个串 for( int i = 0 ; i &lt; num_string ; i++) &#123; bool flag = true; int tt = strlen(a[i]) ; // 匹配，如果匹配失败则换下一个串. for( int j = 0 ; j &lt; tt ; j++ ) &#123; if( s[n + j ] != a[i][j] ) &#123; flag = false ; break ; &#125; &#125; if( flag ) &#123; ans = max( ans , dfs( n + tt ) ) ; &#125; &#125; return ( ans != 0 ) ? ans : n ; // 这里我处理其实不太好，DFS写的有点蠢了。&#125;int main()&#123; freopen("prefix.in","r",stdin); freopen("prefix.out","w",stdout); char ch ; while( scanf("%s" , a[ num_string++]) ) if( strcmp( a[num_string - 1 ] , "." ) == 0 ) break ; num_string--;// string t ;// while( cin &gt;&gt; t &amp;&amp; t != "." )// a.push_back(t);// while( cin &gt;&gt; t )// s += t ; while( ( ch = getchar() ) != EOF ) &#123; if( ch == EOF ) break ; if( ch == ' ' || ch == '\n' ) continue ; s[ s_size++ ] = ch ; &#125; cout &lt;&lt; dfs(0) &lt;&lt; endl ;&#125; 由此也可以改成递推的方式。 code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152 /*ID:xiekeyi1PROG:prefixLANG:C++ */#include&lt;bits/stdc++.h&gt;using namespace std ;string s ;vector&lt;string&gt; a ;bool vis[200100];int main()&#123; string t ; while( cin &gt;&gt; t &amp;&amp; t != "." ) a.push_back(t); while( cin &gt;&gt; t ) s += t ; int ans = 0 ; for( int i = 0 ; i &lt; s.size() ; i++) &#123; if( vis[i] || i == 0 ) &#123; for( int j = 0 ; j &lt; a.size() ; j++) &#123; bool flag = true ; for( int k = 0 ; k &lt; a[j].size() ; k++) &#123; if( i + k &gt; s.size() ) &#123; flag = false ; break ; &#125; if( s[ i + k ] != a[j][k] ) &#123; flag = false ; break ; &#125; &#125; if( flag ) &#123; vis[i + a[j].size() ] = true ; ans = max( ans , static_cast&lt;int&gt; ( i + a[j].size() ) ) ; &#125; &#125; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl ; return 0 ; &#125; 我是从访问过的向没访问过的转移,似乎有人是从没访问过的去找访问过的转移。]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>DP</tag>
        <tag>USACO</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO-Chapter2-Section2.2]]></title>
    <url>%2Ffb7a8e7d.html</url>
    <content type="text"><![CDATA[USACO-Chapter2-Section2.2 2.2.1 Preface Numbering code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151 /*ID:xiekeyi1PROG:prefaceLANG:C++*/#include&lt;bits/stdc++.h&gt;using namespace std ;string func( int n , int digit )&#123; if( digit == 1 ) &#123; if( n == 1 ) return "I" ; else if( n == 2 ) return "II" ; else if ( n == 3 ) return "III" ; else if( n == 4 ) return "IV" ; else if( n == 5 ) return "V" ; else if( n == 6 ) return "VI" ; else if( n == 7 ) return "VII" ; else if ( n == 8 ) return "VIII" ; else if( n == 9 ) return "IX" ; &#125; else if( digit == 2 ) &#123; if ( n == 1 ) return "X" ; else if( n == 2 ) return "XX"; else if( n == 3 ) return "XXX"; else if ( n == 4 ) return "XL"; else if( n == 5 ) return "L"; else if( n == 6 ) return "LX" ; else if( n == 7 ) return "LXX" ; else if( n == 8 ) return "LXXX" ; else if( n == 9 ) return "XC"; &#125; else if( digit == 3 ) &#123; if( n == 1 ) return "C" ; else if( n == 2 ) return "CC"; else if( n == 3 ) return "CCC" ; else if ( n == 4 ) return "CD"; else if( n == 5 ) return "D"; else if( n == 6 ) return "DC"; else if( n == 7 ) return "DCC"; else if( n == 8 ) return "DCCC"; else if( n == 9 ) return "CM"; &#125; else if( digit == 4 ) &#123; if( n == 1 ) return "M"; else if( n == 2 ) return "MM"; else if( n == 3 ) return "MMM"; &#125; return "" ;&#125;string r_s( int n )&#123; int d = 1 ; string ans ; while( n != 0 ) &#123; ans += func( n % 10 , d ) , n /= 10 , d++ ; &#125; return ans ; &#125;int main()&#123; freopen("preface.in","r",stdin); freopen("preface.out","w",stdout); int n ; cin &gt;&gt; n ; string ans ; for( int i = 1 ; i &lt;= n ; i++) &#123; ans += r_s( i ) ; &#125; int cnt_i = 0 , cnt_v = 0 , cnt_x = 0 , cnt_l = 0 , cnt_c = 0 , cnt_d = 0 , cnt_m = 0 ; for( int i = 0 ; i &lt; ans.size() ; i++) &#123; if( ans[i] == 'I' ) cnt_i++; if( ans[i] == 'V' ) cnt_v++; if( ans[i] == 'X' ) cnt_x++; if( ans[i] =='L' ) cnt_l++; if( ans[i] == 'C' ) cnt_c++; if( ans[i] == 'D' ) cnt_d++; if( ans[i] == 'M' ) cnt_m++; &#125; if( cnt_i != 0 ) cout &lt;&lt; "I" &lt;&lt; ' ' &lt;&lt; cnt_i &lt;&lt; endl ; if( cnt_v != 0 ) cout &lt;&lt; "V" &lt;&lt; ' ' &lt;&lt; cnt_v &lt;&lt; endl ; if( cnt_x != 0 ) cout &lt;&lt; "X" &lt;&lt; ' ' &lt;&lt; cnt_x &lt;&lt; endl ; if( cnt_l != 0 ) cout &lt;&lt; "L" &lt;&lt; ' ' &lt;&lt; cnt_l &lt;&lt; endl ; if( cnt_c != 0 ) cout &lt;&lt; "C" &lt;&lt; ' ' &lt;&lt; cnt_c &lt;&lt; endl ; if( cnt_d != 0 ) cout &lt;&lt; "D" &lt;&lt; ' ' &lt;&lt; cnt_d &lt;&lt; endl ; if( cnt_m != 0 ) cout &lt;&lt; "M" &lt;&lt; ' ' &lt;&lt; cnt_m &lt;&lt; endl ; return 0 ;&#125; 2.2.2 subset 暴力(TLE) code1234567891011121314151617181920212223242526272829303132333435363738394041424344 /*ID:xiekeyi1PROG:subsetLANG:C++*/#include&lt;bits/stdc++.h&gt;using namespace std ;int all_sum = 0 ; int dfs( int n , int now_num , int now_sum)&#123; int ans = 0 ; if( now_num &lt; 1 ) return 0 ; if( now_sum &gt; (all_sum / 2) ) return 0 ; if( now_sum == all_sum - now_sum ) return 1 ; ans += dfs( n , now_num - 1 , now_sum + now_num - 1 ) + dfs( n , now_num -1 , now_sum ) ; return ans ; &#125;int main()&#123; freopen("subset.in" , "r", stdin); freopen("subset.out","w",stdout); int n ; cin &gt;&gt; n ; for( int i = 1 ; i &lt;= n ; i++) all_sum += i ; cout &lt;&lt; dfs( n , n + 1 , 0 ) / 2 &lt;&lt; endl ;&#125; 01背包求方案数 code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667 /*ID:xiekeyi1PROG:subsetLANG:C++*/#include&lt;bits/stdc++.h&gt;using namespace std ;long long solve( int n ) &#123; int all_sum = 0 ; for( int i = 1 ; i &lt;= n ; i++) all_sum += i ; if( all_sum % 2 ) return 0; int capacity = all_sum / 2 ; int dp[n + 20 ][capacity + 50 ] ; long long cnt[n + 20][capacity + 50 ] ; for( int i = 0 ; i &lt;= n ; i++) for( int j = 0 ; j &lt;= capacity ; j++) dp[i][j] = -1000 , cnt[i][j] = 0 ; ; dp[0][0] = 0 ; cnt[0][0] = 1 ; for( int i = 1 ; i &lt;= n ; i++) &#123; for( int j = 0 ; j &lt;= capacity ; j++) &#123; if( j &gt;= i ) &#123; if( dp[i-1][j] &gt; dp[i-1][ j - i ] + i ) &#123; dp[i][j] = dp[i-1][j]; cnt[i][j] = cnt[i-1][j] ; &#125; else &#123; dp[i][j] = dp[i-1][j-i] + i ; cnt[i][j] = cnt[i-1][j-i] + cnt[i-1][j] ; &#125; &#125; else dp[i][j] = dp[i-1][j] , cnt[i][j] = cnt[i-1][j] ; &#125; &#125; return cnt[n][capacity];&#125;int main()&#123; freopen("subset.in","r",stdin); freopen("subset.out","w",stdout); int n ; cin &gt;&gt; n ; cout &lt;&lt; solve(n) / 2 &lt;&lt; endl ; return 0 ;&#125; 2.2.3 runround code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788 /*ID:xiekeyi1PROG:runroundLANG:C++*/#include&lt;bits/stdc++.h&gt;using namespace std ;typedef long long ll ; bool judge( ll n )&#123; int digit = 0 ; ll t = n ; while( t != 0 ) t /= 10 , digit++; vector&lt;ll&gt; a ; int d[10] = &#123;0&#125; ; for( int i = digit - 1 ; i &gt;= 0 ; i-- ) &#123; int t = static_cast&lt;int&gt; ( ( n / pow( 10 , i ) ) ) % 10 ; if( d[t] != 0 || t == 0 ) return false ; else &#123; d[t]++; a.push_back( t ) ; &#125; &#125; int tt = 0 ; int b[15] = &#123;0&#125; ; for( int i = 1 ; i &lt;= digit ; i++) &#123; tt = ( a[ ( tt - 1 &lt; 0 ) ? ( a.size() - 1 ) : ( tt - 1 ) ] + tt ) % digit ; b[a[tt]]++; &#125; for( int i = 0 ; i &lt; a.size() ; i ++ ) &#123; if( b[ a[i] ] != 1 ) return false ; &#125; return true ;&#125;// int b[15] = &#123;0&#125; ;// int c[10] = &#123;0&#125; ; // for( int i = 0 ; i &lt; a.size() ; i++)// &#123;// b[i] = ( a[ ( i - 1 &lt; 0 ) ? (a.size() - 1 ) : ( i - 1 ) ] + i ) % digit ; // if( b[i] == i )// return false ; // else if( c[b[i]] == 0 )// c[b[i]]++;// else// return false ; // &#125;//// return true ;//&#125;int main()&#123; freopen("runround.in","r",stdin); freopen("runround.out","w",stdout); ll m ; cin &gt;&gt; m ; m++; while( true ) &#123; if( judge( m ) ) &#123; cout &lt;&lt; m &lt;&lt; endl ; return 0 ; &#125; else m++; &#125; return 0; &#125; 2.2.4 lamps code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117 /*ID:xiekeyi1PROG:lampsLANG:C++ */#include&lt;bits/stdc++.h&gt;using namespace std ;const int maxn = 110 ; int n ;int c ;vector&lt;int&gt; bright , dark ; int lamp[maxn]; int button[5];set&lt;string&gt; sq ; vector&lt;string&gt; ans ; bool flag = false ; // 01翻转操作inline void overturn( int &amp;n )&#123; if( n == 1 ) n = 0 ; else n = 1 ; return ;&#125;void dfs( int m )&#123; // 开关每一位都确定后，模拟并检测。 if( m == 5 ) &#123; int a[n+5]; fill( a , a + n + 1 , 1 ) ; &#123; // 检测对于当前的按键，是否满足c的限制.(因为作用域问题，拿大括号括起来了) int t = 0 ; for( int i = 1 ; i &lt;= 4 ; i++) if( button[i] == 1 ) t++; if( t &gt; c || ( t % 2 != c % 2 ) ) return ; &#125; // 模拟部分 if( button[1] == 1 ) for( int i = 1 ; i &lt;= n ; i++) overturn(a[i]); if( button[2] == 1 ) for( int i = 1 ; i &lt;= n ; i+=2) overturn(a[i]); if( button[3] == 1 ) for( int i = 2 ; i &lt;= n ; i+=2) overturn(a[i]); if( button[4] == 1 ) for( int i = 1 ; i &lt;= n ; i+=3) overturn(a[i]); // 检测模拟后结果是否满足条件 for( int i = 1 ; i &lt;= n ; i++) if( lamp[i] != -1 &amp;&amp; a[i] != lamp[i] ) return ; // 记录答案 string t ; for( int i = 1 ; i &lt;= n ; i++) t += a[i] + '0' ; if( sq.count(t) &lt;= 0 ) ans.push_back(t) , flag = true ; sq.insert(t); return ; &#125; // 模拟每一个开关状态 button[m] = 1 ; dfs( m + 1 ) ; button[m] = 0 ; dfs( m + 1 ) ; return ;&#125;int main()&#123; freopen("lamps.in" , "r" , stdin) ; freopen("lamps.out", "w" , stdout) ; memset( lamp , -1 , sizeof(lamp) ) ; cin &gt;&gt; n ; cin &gt;&gt; c; int t ; while( ( cin &gt;&gt; t ) &amp;&amp; t != -1 ) bright.push_back(t); while( ( cin &gt;&gt; t ) &amp;&amp; t != - 1 ) dark.push_back(t); for( int i = 0 ; i &lt; bright.size() ; i++) lamp[bright[i]] = 1 ; for( int i = 0 ; i &lt; dark.size() ; i++) lamp[dark[i]] = 0 ; dfs(1); if(!flag) cout &lt;&lt; "IMPOSSIBLE" &lt;&lt; endl ; else &#123; sort( ans.begin() , ans.end() ); for( vector&lt;string&gt; :: iterator iter = ans.begin() ; iter != ans.end() ; ++iter) cout &lt;&lt; *iter &lt;&lt; endl ; &#125; return 0 ; &#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>USACO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO-2.2.4-PartyLamps-模拟搜索]]></title>
    <url>%2F3b4b621e.html</url>
    <content type="text"><![CDATA[模拟、DFS搜索、小结论。 感觉这一章不少题，考察的是时间复杂度的计算。 题意： 给定一个N，表示N盏灯( \(10 \leq N \leq 100\) ) 。 给定操作数C( $ 0 C 10000 $ )。 四种操作： 1. 按钮1：当按下此按钮，将改变所有的灯：本来亮着的灯就熄灭，本来是关着的灯被点亮。 2. 按钮2：当按下此按钮，将改变所有奇数号的灯。 3. 按钮3：当按下此按钮，将改变所有偶数号的灯。 4. 按钮4：当按下此按钮，将改变所有序号是$ 3*K+1 (K 0) $的灯。例如：1,4,7... 一开始所有的灯都是亮着的。 给定最后灯亮暗的结果* (有部分灯未给)*，求所有灯最后的可能情况。(按字典序输出，被这个WA了一下) 做法： 一开始想到朴素做法，就是枚举每一次操作，枚举C次。那么时间复杂度是(\(O(4^c)\)) , 显然不合要求。 考虑到，对于每一种操作，不按和两次是一样的，按一次和按三次是一样的。 因此，我们只需要枚举对应每个操作，是按了还是没按就可以了。时间复杂度是(\(O(2^4)\))，考虑到还要检测和模拟，时间复杂度应该在(\(O(2^4 * n )\) )这个水平。这样也就过了。 本来想自己写个实现set&lt;string&gt;功能的，用来处理去重，不过了解了一下，似乎要用到字符串hash。暂时还没学过，遂作罢。 代码： code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117 /*ID:xiekeyi1PROG:lampsLANG:C++ */#include&lt;bits/stdc++.h&gt;using namespace std ;const int maxn = 110 ; int n ;int c ;vector&lt;int&gt; bright , dark ; int lamp[maxn]; int button[5];set&lt;string&gt; sq ; vector&lt;string&gt; ans ; bool flag = false ; // 01翻转操作inline void overturn( int &amp;n )&#123; if( n == 1 ) n = 0 ; else n = 1 ; return ;&#125;void dfs( int m )&#123; // 开关每一位都确定后，模拟并检测。 if( m == 5 ) &#123; int a[n+5]; fill( a , a + n + 1 , 1 ) ; &#123; // 检测对于当前的按键，是否满足c的限制.(因为作用域问题，拿大括号括起来了) int t = 0 ; for( int i = 1 ; i &lt;= 4 ; i++) if( button[i] == 1 ) t++; if( t &gt; c || ( t % 2 != c % 2 ) ) return ; &#125; // 模拟部分 if( button[1] == 1 ) for( int i = 1 ; i &lt;= n ; i++) overturn(a[i]); if( button[2] == 1 ) for( int i = 1 ; i &lt;= n ; i+=2) overturn(a[i]); if( button[3] == 1 ) for( int i = 2 ; i &lt;= n ; i+=2) overturn(a[i]); if( button[4] == 1 ) for( int i = 1 ; i &lt;= n ; i+=3) overturn(a[i]); // 检测模拟后结果是否满足条件 for( int i = 1 ; i &lt;= n ; i++) if( lamp[i] != -1 &amp;&amp; a[i] != lamp[i] ) return ; // 记录答案 string t ; for( int i = 1 ; i &lt;= n ; i++) t += a[i] + '0' ; if( sq.count(t) &lt;= 0 ) ans.push_back(t) , flag = true ; sq.insert(t); return ; &#125; // 模拟每一个开关状态 button[m] = 1 ; dfs( m + 1 ) ; button[m] = 0 ; dfs( m + 1 ) ; return ;&#125;int main()&#123; freopen("lamps.in" , "r" , stdin) ; freopen("lamps.out", "w" , stdout) ; memset( lamp , -1 , sizeof(lamp) ) ; cin &gt;&gt; n ; cin &gt;&gt; c; int t ; while( ( cin &gt;&gt; t ) &amp;&amp; t != -1 ) bright.push_back(t); while( ( cin &gt;&gt; t ) &amp;&amp; t != - 1 ) dark.push_back(t); for( int i = 0 ; i &lt; bright.size() ; i++) lamp[bright[i]] = 1 ; for( int i = 0 ; i &lt; dark.size() ; i++) lamp[dark[i]] = 0 ; dfs(1); if(!flag) cout &lt;&lt; "IMPOSSIBLE" &lt;&lt; endl ; else &#123; sort( ans.begin() , ans.end() ); for( vector&lt;string&gt; :: iterator iter = ans.begin() ; iter != ans.end() ; ++iter) cout &lt;&lt; *iter &lt;&lt; endl ; &#125; return 0 ; &#125; 对于这道题，看dalao说第一次做，做到这个程度就可以了。这也是nocow的官方思路。不过对于这道题，深究下去还有一些优化。 如: 对于超过6盏灯的，其实只需要看前六个就可以了。因为1和7对应、2和8对应...... (如果自身六个都不能互相对应，肯定是IMPOSSIBLE) 在luogu的P1468题解看到了闪耀星空写的一个比较深入的想法。对自己有所启发，因此转了贴在下面。 深究： 这道题如果深究的话会变得非常简单， 但是提前声明，如果对这道题兴趣不大，或者是初学者，建议跳过， 刚才的分析已经足以过这道题。 我们现在记不按按钮，以及按下1，2，3，4按钮分别O，①，②，③，④， 那么，按下3，4，可以记为③④，以此类推， 我们发现一个问题，那就是①，②，③之间微妙的关系， ①②=③，而②③=①，①③=②（可以自己试试），于是我们知道，①②③也相当与不按，即相差3的倍数也可互相转换； 所以，所谓前四个的16种按法其实只有8种， 分别为：O,①，②，③，④，①④，②④，③④； 然后讨论c， 由于当c&gt;4时，均可化为当c&lt;=4的情况， 所以我们先讨论当c&lt;=4的情况， 当c=0时，只有一种O； 当c=1时，四种：①，②，③，④； 当c=2时，除了④均可（可以自己想想）； 当c=3时，由于3-1=2，所以c=1的情况都满足，而在c=2中，把所有有前三类的展开，如①④变为②③④， 可知满足c=2的同时满足c=3，所以c=3其实是c=2和c=1的并集，即所有按法均可。 当c=4时，由于4-1=3（①②③相当于不按），且4-2=2，由上，c=4也是所有按法均可。 当c&gt;4时，我先有一个引理：对于任意的正整数n&gt;1，均可写成n=2p+3q(p,q为非负整数）的形式， 证明如下：若n为偶数，必然成立，若n为奇数，必然大于2，则n-3必为非负偶数，得证。 由这个引理我们可以知道，任意c&gt;4均可写成，c=2p+3q+3(p,q为非负整数）的形式，而可知， 对于两个相同的按键，以及情况①②③（按键三次），均相当于不按，所以任意c&gt;4均可化归为c=3的情况， 即当c&gt;4时，所有按法均可。 综上所述， 当c=0时，只有一种O； 当c=1时，四种：①，②，③，④； 当c=2时，除了④均可； 当c&gt;2时，所有按法均可。 好了，这样一来就非常简单了， 只有四种情况，8种按法。]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>USACO</tag>
        <tag>模拟</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO-2-2-3-Runaround-模拟]]></title>
    <url>%2Fab5b75.html</url>
    <content type="text"><![CDATA[感觉到这里其实到自己的瓶颈了，每一道题都要想一段时间才能做出来。 这道题挺暴力的，让我比较意外。毕竟上面刚刚一道01背包求方案数233。 不过为什么暴力能过，我还是想了挺久的。 题意: 挺难描述的，这里贴洛谷的翻译(应该是nocow翻译过来的) &gt;循环数是那些不包括0且没有重复数字的整数(比如81362)并且还应同时具有一个有趣的性质, 就像这个例子: &gt;如果你从最左边的数字开始(在这个例子中是8)向右数最左边这个数(如果数到了最右边就回到最左边),你会停止在另一个新的数字(如果停在一个相同的数字上，这个数就不是循环数).就像: 8 1 3 6 2 从最左边接下去数8个数字: 1 3 6 2 8 1 3 6 所以下一个数字是6 &gt;重复这样做 (这次从“6”开始数6个数字) 并且你会停止在一个新的数字上: 2 8 1 3 6 2, 也就是2 &gt;再这样做 (这次数两个): 8 1 &gt;再一次 (这次一个): 3 &gt;又一次: 6 2 8 这时你回到了起点,在经过每个数字一次后回到起点的就是循环数。如果你经过每一个数字一次以后没有回到起点, 你的数字不是一个循环数。 &gt;给你一个数字 M (在1到9位之间), 找出第一个比 M大的循环数, 输出数据保证结果能用一个无符号长整型数（21亿）装下。 &gt;（追加提醒：循环数每个数位都必须要访问到） 一开始想了下暴力。 然后如何判断一开始觉得直接模拟太麻烦了，于是考虑了一下。 错误的以为，是对每位数都执行这样的操作，然后计算出来操作后得到的下标。只要下标互不重复，也就表示是循环数了。 于是进一步想过后得到，对于第\(i\)个数而言，只要$ ( i + a_{i-1} ) % n $ 各不相同(应该算是一个完全剩余系？)，就可以了。 于是只要注意( i - 1 &lt; 0 ) ? ( a.size() - 1 ) : ( i - 1 ) 就可以了。 虽然在当时很快想到了这个如何去检测一个数字是否是循环数的比较好写的写法，但是一直有一个问题困扰着我。 就是答案中暗示可能数据有\(2e9\)那么大，那么会不会出现连续\(1e9\)个数字里都找不到满足条件的数导致超时？ 想了很久，没什么头绪。 只是想的是，如果遍历\(1e5\)，大概有6位就会被遍历了，改变对于9位数来说也有不少了，那么会不会出现不了这种情况呢？ 因为不会证明。 于是就按这个想法交了一发。 发现WA了。 WA的数据是\(738192\). 如果按题目中要求，会是一个不停在7和1中循环的数列，无法遍历到其他数中。但是按照我的想法，却会是成立的。 于是最后还是得暴力模拟。 模拟主要方法就是，有多少位模拟多少次， 然后最后在统计一下有没有重复出现过的下标或者没出现过的下标即可。 提交后，竟然A了。 事后发现自己想多了。 这道题时间复杂度应该是 \(O(9!)\) ， 因为是各不相同且没有\(0\)的数字，所以应该去生成全排列。而不是逐一枚举。 逐一枚举的话，时间复杂度就是玄学了。 代码： code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071 /*ID:xiekeyi1PROG:runroundLANG:C++*/#include&lt;bits/stdc++.h&gt;using namespace std ;typedef long long ll ; bool judge( ll n )&#123; int digit = 0 ; ll t = n ; while( t != 0 ) t /= 10 , digit++; // 计算位数 vector&lt;ll&gt; a ; // 计算是否有重复和和0 int d[10] = &#123;0&#125; ; for( int i = digit - 1 ; i &gt;= 0 ; i-- ) &#123; int t = static_cast&lt;int&gt; ( ( n / pow( 10 , i ) ) ) % 10 ; if( d[t] != 0 || t == 0 ) return false ; else &#123; d[t]++; a.push_back( t ) ; &#125; &#125; // 模拟 int tt = 0 ; int b[15] = &#123;0&#125; ; for( int i = 1 ; i &lt;= digit ; i++) &#123; tt = ( a[ ( tt - 1 &lt; 0 ) ? ( a.size() - 1 ) : ( tt - 1 ) ] + tt ) % digit ; b[a[tt]]++; &#125; for( int i = 0 ; i &lt; a.size() ; i ++ ) &#123; if( b[ a[i] ] != 1 ) return false ; &#125; return true ;&#125;int main()&#123; freopen("runround.in","r",stdin); freopen("runround.out","w",stdout); ll m ; cin &gt;&gt; m ; m++; while( true ) &#123; if( judge( m ) ) &#123; cout &lt;&lt; m &lt;&lt; endl ; return 0 ; &#125; else m++; &#125; return 0; &#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO 2.2.2 subset 01背包求方案数]]></title>
    <url>%2F42aa9afc.html</url>
    <content type="text"><![CDATA[题意: 给定一个N( N \(\leq\) 39)，表示有 1 - n 个数。每个数只能选一次，要求你将这N个数分成和相等的两部分。问有多少种分法？ 做法： 一开始第一反应是DFS。 对于每一个数字有选和不选两种方案。然后DFS下去就可以了。 后来发现N是39。一开始考虑是不是要折半搜索，或者花式剪枝。 一开始写了一个花式剪枝，剪枝策略是： 对于总和是奇数的直接返回0(不可能拆成和相等的两部分)。 从大到小选取，当目前选取的和已经超过了总和的一半的时候，直接return 。 依然会T。于是就想折半搜索。想了一会没什么思绪。 在想如何去把这个DFS写成记忆化搜索的过程中，突然发现这不就是个背包嘛。(果然有人曾说的，DP写不好的时候，先想搜索，然后从搜索想如何写成记忆化搜索，在这过程中想出DP的状态转移，是很不错的方法。) 本质上来讲，这道题就是N个物品\(a\_{i}\) ， 每个物品的重量是i(即它本身)。问恰好能装满容积为\(\frac{\sum\_{i=1}^n{a\_i}}{2}\) 的背包的** 方案数**吗？* (注意这里答案应该是最终答案除以2，因为有重复计算的关系)* 朴素的01背包很简单 定义dp[i][j]表示一共有i个物品，背包最大容量为j，所能装的物品的最大价值。 12345678for( int i = 1 ; i &lt;= N ; i++) for( int j = 1 ; j &lt;= capacity ; j++) &#123; if( j &gt;= weight[i] ) dp[i][j] = max( dp[i-1][j] , dp[i-1][j - weight[i]] + value[i] ) ; else dp[i][j] = dp[i-1][j] ; &#125; 注意一下dp数组都初始化为0，以及很多教材中提到的都是第二个循环从 j == weight[i] 开始的。但是实际上之前的dp数组也要转移过来。 ** 另可用滚动数组优化，空间复杂度减去一维** 如果是要求，恰好装满背包的话，那么我们应该注意除了dp[0][0]初始化为0，其他都应该初始化为\(-inf\)。 我们可以通过搜索去考虑。如果是搜索的话，除了dp[0][0]是return 0 ，其他应该是没有装满都返回\(-inf\)。而在DP中，因为是要取max的，所以就初始化为-inf就可以了。 01背包求方案数 我主要是在这里卡了一段时间。 曾经在学习Dijkstra的过程中，遇到需要记录路径问题的时候。被人告知: ** dp的时候需要记录路径、决策之类的，直接再开一个和dp数组结构基本一样的数组去记录就可以了。** 这个思想对我帮助很大。记录这些信息，本质上其实就是记录决策。决策的记录方式，映射下来，不就是和dp数组结构一样吗？ 于是这道题我开了cnt[n][capacity] 这样一个数组去记录。(有的人选择在DP数组中再加一个维度去记录，本质上是一样的) 也就是定义cnt[i][j] 表示i个物品，(恰好)放在容量为j的背包中的方案数。 不过在实际写的过程中，发现还有一些小问题要处理。 就是在转移的过程中，这个cnt数组，如何转移？ 我们观察到dp数组的转移主要是 1234if( dp[i-1][j] &gt; dp[i-1][ j - weight[i] ] + value[i] ) dp[i][j] = dp[i-1][j] ;else dp[i][j] = dp[i-1][j - weight[i] ] + value[i] ; cnt数组显然要在dp转移的过程中转移。 12345if( dp[i-1][j] &gt; dp[i-1][ j - weight[i] ] + value[i] ) dp[i][j] = dp[i-1][j] , cnt[i][j] = cnt[i-1][j] ;else dp[i][j] = dp[i-1][j - weight[i] ] + value[i] , cnt[i][j] = cnt[i-1][j - weight[i] ] + cnt[i-1][j]; 转移过程大概如上。 对于dp[i][j]由dp[i-1][j] 转移而来的时候，显然dp[i][j]对应的方案数没有变化，可以直接继承cnt[i-1][j]过来。 对于dp[i][j]由dp[i-1][j - weight[i] ] + value[i] 转移时。 一开始我想的是等于cnt[i-1][j-weight[i]] + 1 后来发现计算出来的远远小于答案。 毕竟这是组合问题，直接加1的话，差的太远了。 然后网上查了一下，发现别人的转移如上所示。 一开始我以为是指i个物品放入容量为j的背包的方案数，可以 由i-1个物品放入j的背包里的方案数和i-1个物品放入j-i的方案数相加而来。然后怎么想都觉得怪怪的，如何按这个想法的话，不应该是由i-1个物品放入i的背包里的方案数和j-i的方案数相加而来才可以吗？ 于是私自改了一下这个地方。但是改了后也还是不能理解，因为这样如何避免重复计算呢？ 因此卡了一段时间。 卡了一段时间后，想明白了，这不就是组合数递推的公式吗: \[ C\_n^m = C\_{n-1}^m + C\_{n-1}^{m-1} \] 这个公式的理解是，对于n个物品取m个，可以由n-1个物品直接取m个得来(也就是新加的物品不取)，也可以由n-1个物品取m-1个物品，然后加上新增的这个物品得来。 那么，这个cnt[i][j]的转移方法，不就可以看做是由前i-1个物品直接取了j个容量的方案数得来加上由前i-1个物品中取j - weight[i]容量的物品再加上当前的这个重量为weight[i]的物品得来吗？ 借此做完了这道题。 虽然理解了，但是目前在转移过程中，还是常常按自己的想法写成 j - i 和 i 。 因为卡了一段时间，所以写下来整理一下自己思路。 代码： code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768 /*ID:xiekeyi1PROG:subsetLANG:C++ */#include&lt;bits/stdc++.h&gt;using namespace std ;long long solve( int n ) &#123; int all_sum = 0 ; for( int i = 1 ; i &lt;= n ; i++) all_sum += i ; if( all_sum % 2 ) return 0; int capacity = all_sum / 2 ; int dp[n + 20 ][capacity + 50 ] ; long long cnt[n + 20][capacity + 50 ] ; for( int i = 0 ; i &lt;= n ; i++) for( int j = 0 ; j &lt;= capacity ; j++) dp[i][j] = -1000 , cnt[i][j] = 0 ; ; dp[0][0] = 0 ; cnt[0][0] = 1 ; for( int i = 1 ; i &lt;= n ; i++) &#123; for( int j = 0 ; j &lt;= capacity ; j++) &#123; if( j &gt;= i ) &#123; if( dp[i-1][j] &gt; dp[i-1][ j - i ] + i ) &#123; dp[i][j] = dp[i-1][j]; cnt[i][j] = cnt[i-1][j] ; &#125; else &#123; dp[i][j] = dp[i-1][j-i] + i ; cnt[i][j] = cnt[i-1][j-i] + cnt[i-1][j] ; &#125; &#125; else dp[i][j] = dp[i-1][j] , cnt[i][j] = cnt[i-1][j] ; &#125; &#125; return cnt[n][capacity];&#125;int main()&#123; freopen("subset.in","r",stdin); freopen("subset.out","w",stdout); int n ; cin &gt;&gt; n ; cout &lt;&lt; solve(n) / 2 &lt;&lt; endl ; return 0 ;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>USACO</tag>
        <tag>背包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO-Chapter2-Section2.1]]></title>
    <url>%2F6273dfc7.html</url>
    <content type="text"><![CDATA[USACO-Chapter2-Section2.1 1castle code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990 /*ID:xiekeyi1PROG:castleLANG:C++*/#include&lt;bits/stdc++.h&gt;using namespace std ;const int maxn = 55;int graph[maxn][maxn][5];int roomsize[maxn*maxn] ;int vis[maxn][maxn];int m , n , color , maxsize ; int dx[] = &#123; 1 , 0 , -1 , 0 &#125; ;int dy[] = &#123; 0 , 1 , 0 , -1 &#125;;int nowsize ; int ans_row , ans_col ; char dir ; void scan()&#123; cin &gt;&gt; m &gt;&gt; n ; for( int i = 1 ; i &lt;= n ; i++) for( int j = 1 ; j &lt;= m ; j++) &#123; int t ; cin &gt;&gt; t ; for( int k = 3 ; k &gt;= 0 ; k--) graph[i][j][k] = t % 2 , t = t &gt;&gt; 1 ; &#125;&#125;void floodfill( int x , int y )&#123; vis[x][y] = true ; roomsize[color]++; graph[x][y][4] = color ; for( int i = 0 ; i &lt; 4 ; i++) &#123; int nx = x + dx[i] ; int ny = y + dy[i]; if( nx &lt; 1 || ny &lt; 1 || nx &gt; n || ny &gt; m ) continue ; if( vis[nx][ny] || graph[x][y][i] ) continue ; floodfill(nx,ny); &#125;&#125;void merge( int x , int y )&#123; int sum = 0 ; if( x &gt;= 2 &amp;&amp; graph[x-1][y][4] != graph[x][y][4] ) &#123; sum = roomsize[ graph[x-1][y][4] ] + roomsize[ graph[x][y][4] ] ; if( sum &gt; maxsize) maxsize=sum,ans_row=x,ans_col=y,dir='N' ; &#125; if( y &lt; m &amp;&amp; graph[x][y+1][4] != graph[x][y][4] ) &#123; sum = roomsize[ graph[x][y+1][4] ] + roomsize[ graph[x][y][4] ] ; if( sum &gt; maxsize ) maxsize = sum , ans_row = x , ans_col = y , dir = 'E' ; &#125;&#125;int main()&#123; freopen("castle.in","r",stdin); freopen("castle.out","w",stdout); scan(); for( int i = 1 ; i &lt;= n ; i++) for( int j = 1 ; j &lt;= m ; j++) &#123; if( !vis[i][j] ) &#123; roomsize[ color ] = 0 ; floodfill( i , j ); color++; &#125; &#125; for( int i = 0 ; i &lt; color ; i++) nowsize = max( nowsize , roomsize[ i ] ) ; for( int i = 1 ; i &lt;= m ; i++) for( int j = n ; j &gt;= 1 ; j--) merge(j,i); cout &lt;&lt; color &lt;&lt; endl &lt;&lt; nowsize &lt;&lt; endl &lt;&lt; maxsize &lt;&lt; endl &lt;&lt; ans_row &lt;&lt; ' ' &lt;&lt; ans_col &lt;&lt; ' ' &lt;&lt; dir &lt;&lt; endl ; return 0 ;&#125; 2frac1 code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 /*ID:xiekeyi1PROG:frac1LANG:C++*/#include&lt;bits/stdc++.h&gt;using namespace std ;const int maxn = 170 ; struct node&#123; int fenzi , fenmu ; long double value ;&#125;x[maxn*maxn];bool operator &lt; ( struct node a , struct node b ) &#123; return a.value &lt; b.value ;&#125;int gcd( int a , int b )&#123; if( b == 0 ) return a ; if( a == 0 ) return b ; else return gcd( b , a % b ) ;&#125;int main()&#123; freopen("frac1.in","r",stdin); freopen("frac1.out","w",stdout); int n ; cin &gt;&gt; n ; int cnt = 0 ; for( int i = 0 ; i &lt;= n ; i++) for( int j = 1 ; j &lt;= n ; j++) if( gcd( i , j ) == 1 &amp;&amp; ( (i+0.0) / j ) &lt;= 1 ) x[cnt].fenzi = i , x[cnt].fenmu = j , x[cnt].value = (x[cnt].fenzi + 0.0) / x[cnt].fenmu , cnt++; sort(x,x+cnt); for( int i = 0 ; i &lt; cnt ; i++) printf("%d/%d\n",x[i].fenzi,x[i].fenmu); return 0 ; &#125; 3sort3 code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 /*ID:xiekeyi1PROG:sort3LANG:C++*/#include&lt;bits/stdc++.h&gt;using namespace std ;const int maxn = 1010 ;int a[maxn] , b[maxn];int c[5][5] ;int main()&#123; freopen("sort3.in","r",stdin); freopen("sort3.out","w",stdout); int n ; cin &gt;&gt; n ; for( int i = 1 ; i &lt;= n ; i++) &#123; cin &gt;&gt; a[i] ; b[i] = a[i] ; &#125; sort( b+1 , b+1+n ) ; for( int i = 1 ; i &lt;= n ; i++) if( a[i] != b[i] ) c[ b[i] ][ a[i] ]++; int ans = 0 ; for( int i = 1 ; i &lt;= 3 ; i++) &#123; for( int j = 1 ; j &lt;= 3 ;j++) &#123; if( c[i][j] &amp;&amp; c[j][i] ) &#123; int t = min( c[i][j] , c[j][i] ); c[i][j] -= t , c[j][i] -=t , ans+=t ; &#125; &#125; &#125; ans+= c[1][2] * 2 ; ans+= c[1][3] * 2 ; cout &lt;&lt; ans &lt;&lt; endl ; return 0 ; &#125; 4holstein code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374 /*ID:xiekeyi1PROG:holsteinLANG:C++*/#include&lt;bits/stdc++.h&gt;using namespace std ;const int maxn = 30 ; int v , vv[maxn] , g , gg[maxn][maxn];void init()&#123; cin &gt;&gt; v ; for( int i = 1 ; i &lt;= v ; i++) cin &gt;&gt; vv[i]; cin &gt;&gt; g ; for( int i = 1 ; i &lt;= g ; i++) for( int j = 1 ; j &lt;= v ; j++) cin &gt;&gt; gg[i][j];&#125;bool flag = false ;int num[maxn];int cnt = 0 ;int k = 1 ; void work() &#123; int a[30] = &#123;0&#125;; for( int i = 1 ; i &lt;= cnt ; i++) for( int j = 1 ; j &lt;= v ; j++) a[j] += gg[ num[i] ][j] ; for( int i = 1 ; i &lt;= v ; i++) if( a[i] &lt; vv[i] ) return ; flag = true ; cout &lt;&lt; cnt ; for( int i = 1 ; i &lt;= cnt ; i++) cout &lt;&lt; ' ' &lt;&lt; num[i] ; cout &lt;&lt; endl ;&#125;void dfs( int t )&#123; if( flag || t &gt; g ) return ; if( cnt &gt;= k ) &#123; work() ; return ; &#125; cnt++; num[cnt] = t + 1 ; dfs( t + 1 ) ; cnt--; dfs( t + 1 ) ; return ; &#125;int main()&#123; freopen("holstein.in","r",stdin); freopen("holstein.out","w",stdout); init() ; while( !flag ) &#123; dfs(0); k++; &#125; return 0 ; &#125; 5hamming code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889 /*ID:xiekeyi1PROG:hammingLANG:C++ */#include&lt;bits/stdc++.h&gt;using namespace std ;bool judge( int b , int n , int d , int aj)&#123; bitset&lt;8&gt; judge( n ^ aj ) ; int t1 = 0 , t2 = 0 ; for( int i = 0 ; i &lt; b ; i++) if( judge.test( i ) ) t1++; if( t1 &lt; d ) return false ; // judge.flip(); // for( int i = 0 ; i &lt; b ; i++) // if( judge.test( i ) ) // t2++; // if( t1 &lt; d &amp;&amp; t2 &lt; d ) // return false ; return true ; // int t1 = judge.count(); // judge.flip(); // int t2 = judge.count(); // if( t1 != d &amp;&amp; t2 != d ) // return false ; // return true ; &#125;int main()&#123; freopen("hamming.in","r",stdin); freopen("hamming.out","w",stdout); int n , b , d ; cin &gt;&gt; n &gt;&gt; b &gt;&gt; d ; int cnt = 0 ; vector&lt;int&gt; a; a.push_back(0); int i = 0 ; while( a.size() != n) &#123; for( ; i &lt;= 300; ) &#123; i++; //cout &lt;&lt; "Debug: " &lt;&lt; i &lt;&lt; endl ; bool flag = true ; for( int j = 0 ; j &lt; a.size() ; j++) &#123; //bitset&lt;8&gt; judge( i ^ a[j] ) ; if( !judge( b, i , d , a[j] ) ) &#123; flag = false ; break ; &#125; &#125; if( flag ) &#123; a.push_back(i) ; //cout &lt;&lt; "Debug:" &lt;&lt; i &lt;&lt; endl ; break ; &#125; &#125; &#125; int tcnt = 0 ; for( int i = 0 ; i &lt; a.size() ; i++) &#123; ++tcnt; if( tcnt == 1 ) cout &lt;&lt; a[i] ; else if( tcnt != 10 ) cout &lt;&lt; ' ' &lt;&lt; a[i] ; else if( tcnt == 10 ) &#123; tcnt = 0 ; cout &lt;&lt; ' ' &lt;&lt; a[i] &lt;&lt; endl ; &#125; &#125; if( tcnt != 0 ) cout &lt;&lt; endl ; return 0 ; &#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>USACO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO-Chapter1-Section1.5]]></title>
    <url>%2F10c67777.html</url>
    <content type="text"><![CDATA[1numtri code12345678910111213141516171819202122232425262728293031323334353637383940 /*ID:xiekeyi1PROG:numtriLANG:C++*/#include&lt;bits/stdc++.h&gt;using namespace std ;const int maxn = 1000 + 10 ;// ′óé?íù??int data[maxn][maxn] , dp[maxn][maxn];int main()&#123; freopen("numtri.in","r",stdin); freopen("numtri.out","w",stdout); int n ; cin &gt;&gt; n ; for( int i = 1 ; i &lt;= n ; i++) for( int j = 1 ; j &lt;= i ; j++) cin &gt;&gt; data[i][j] ; dp[1][1] = data[1][1] ; for( int i = 2 ; i &lt;= n ; i++) &#123; for( int j = 1 ; j &lt;= i ; j++) &#123; dp[i][j] = max(dp[i-1][j-1] , dp[i-1][j] ) + data[i][j] ; //注意边界问题 &#125; &#125; int ans = 0 ; for( int i = 1 ; i &lt;= n ; i++) ans = max( dp[n][i] , ans ) ; cout &lt;&lt; ans &lt;&lt; endl ; return 0 ;&#125; 2pprime code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178 /*ID:xiekeyi1PROG:pprimeLANG:C++*/#include&lt;bits/stdc++.h&gt;using namespace std ;bool isprime( int n )&#123; if( n == 0 || n == 1 ) return false ; if( n == 2 ) return true ; int sqrt_n = sqrt(n) ; for( int i = 2 ; i &lt;= sqrt_n ; i++) if( n % i == 0 ) return false ; return true ; &#125;int digit( int n )&#123; int d = 0 ; while( n != 0 ) n/=10 , d++; return d ; &#125;void f( int a , int b , int n )&#123; if( n &gt;= a &amp;&amp; n &lt;= b &amp;&amp; isprime( n ) ) cout &lt;&lt; n &lt;&lt; endl ; return ; &#125;void func( int a , int b , int dd1 , int dd2)&#123; int palindrom = 0; for( int i = dd1 ; i &lt;= dd2; i++) &#123; if( i == 1 ) &#123; for( int d1 = 0 ; d1 &lt;= 9 ; d1++) &#123; palindrom = d1 ; f(a,b,palindrom) ; &#125; &#125; else if ( i == 2 ) &#123; for( int d1 = 1 ; d1 &lt;= 9 ; d1++) &#123; palindrom = 1e1 * d1 + 1e0 * d1 ; f(a,b,palindrom); &#125; &#125; else if( i == 3 ) &#123; for( int d1 = 1 ; d1 &lt;= 9 ; d1++) &#123; for( int d2 = 0 ; d2 &lt;= 9 ; d2++) &#123; palindrom = 1e2 * d1 + 1e1 * d2 + d1 ; f(a,b,palindrom); &#125; &#125; &#125; else if( i == 4 ) &#123; for( int d1 = 1 ; d1 &lt;= 9 ; d1++) &#123; for( int d2 = 0 ; d2 &lt;= 9 ; d2++) &#123; palindrom = 1e3 * d1 + 1e2 * d2 + 1e1 * d2 + 1e0 * d1 ; f(a,b,palindrom) ; &#125; &#125; &#125; else if( i == 5 ) &#123; for( int d1 = 1 ; d1 &lt;= 9 ; d1++) &#123; for( int d2 = 0 ; d2 &lt;= 9 ; d2++ ) &#123; for( int d3 = 0 ; d3 &lt;= 9 ; d3++) &#123; palindrom = 1e4 * d1 + 1e3 * d2 + 1e2 * d3 + 1e1 * d2 + 1e0 * d1 ; f(a,b,palindrom) ; &#125; &#125; &#125; &#125; else if( i == 6 ) &#123; for( int d1 = 1 ; d1 &lt;= 9 ; d1++) &#123; for( int d2 = 0 ; d2 &lt;= 9 ; d2++) &#123; for( int d3 = 0 ; d3 &lt;= 9 ; d3++) &#123; palindrom = 1e5 * d1 + 1e4 * d2 + 1e3 * d3 + 1e2 * d3 + 1e1 * d2 + 1e0 * d1 ; f(a,b,palindrom); &#125; &#125; &#125; &#125; else if( i == 7 ) &#123; for( int d1 = 1 ; d1 &lt;= 9 ; d1++) &#123; for( int d2 = 0 ; d2 &lt;= 9 ; d2++) &#123; for( int d3 = 0 ; d3 &lt;= 9 ; d3++) &#123; for( int d4 = 0 ; d4 &lt;= 9 ; d4++) &#123; palindrom = 1e6 * d1 + 1e5 * d2 + 1e4 * d3 + 1e3 * d4 + 1e2 * d3 + 1e1 * d2 + 1e0 * d1 ; f(a,b,palindrom); &#125; &#125; &#125; &#125; &#125; else if( i == 8 ) &#123; for( int d1 = 1 ; d1 &lt;= 9 ; d1++) for( int d2 = 0 ; d2 &lt;= 9 ; d2++) for( int d3 = 0 ; d3 &lt;= 9 ; d3++) for( int d4 = 0 ; d4 &lt;=9 ; d4++) &#123; palindrom = 1e7 * d1 + 1e6 * d2 + 1e5 * d3 + 1e4 * d4 + 1e3 * d4 + 1e2 * d3 + 1e1 * d2 + 1e0 * d1 ; f(a,b,palindrom); &#125; &#125; else if( i == 9 ) &#123; for( int d1 = 1 ; d1 &lt;= 9 ; d1++) for( int d2 = 0 ; d2 &lt;= 9 ; d2++) for( int d3 = 0 ; d3 &lt;=9 ; d3++ ) for( int d4 = 0 ; d4 &lt;= 9 ; d4++) for( int d5 = 0 ; d5 &lt;= 9 ; d5++) &#123; palindrom = 1e8 * d1 + 1e7 * d2 + 1e6 * d3 + 1e5 * d4 + 1e4 * d5 + 1e3 * d4 + 1e2 * d3 + 1e1 * d2 + 1e0 * d1 ; f(a,b,palindrom); &#125; &#125; &#125; return ; &#125; int main()&#123; freopen("pprime.in","r",stdin); freopen("pprime.out","w",stdout); int a , b ; cin &gt;&gt; a &gt;&gt; b ; int d1 = digit(a) , d2 = digit(b) ; func( a , b , d1 , d2 ) ; return 0 ;&#125; 3sprime code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556 /*ID:xiekeyi1PROG:sprimeLANG:C++*/#include&lt;bits/stdc++.h&gt;using namespace std ;int ans = 0 ; bool isprime( int n )&#123; if( n == 0 || n == 1 ) return false ; if( n == 2 ) return true ; for( int i = 2 ; i &lt;= sqrt(n) ; i++) if( n % i == 0 ) return false ; return true ;&#125;void dfs( int n )&#123; if( n == 0 ) &#123; cout &lt;&lt; ans &lt;&lt; endl ; &#125; for( int i = 1 ; i &lt;= 9 ; i++) &#123; int t = ans ; ans = i + ans * 10 ; if( isprime ( ans ) ) dfs( n - 1 ) ; ans = t ; &#125;&#125; int main()&#123; freopen("sprime.in","r",stdin); freopen("sprime.out","w",stdout); int n ; cin &gt;&gt; n ; ans = 0 ; dfs(n) ; return 0 ;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>USACO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO-Chapter1-Section1.4]]></title>
    <url>%2F67c147e1.html</url>
    <content type="text"><![CDATA[1ariprog code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879 /*ID:xiekeyi1PROG:ariprogLANG:C++ */#include&lt;bits/stdc++.h&gt;using namespace std ;const int maxn = 250 * 250 * 2 ; bool a[maxn + 10 ] ; void init( int m )&#123; memset( a , false , sizeof(a) ) ; for( int i = 0 ; i &lt;= m ; i++) for( int j = i ; j &lt;= m ; j++) a[ i*i + j*j ] = true ; return ; &#125;struct node&#123; int a , b ; node( int _a , int _b) : a(_a) , b(_b) &#123;&#125; &#125;;vector&lt;node&gt; ans ; bool cmp( struct node a , struct node b )&#123; if( a.b &lt; b.b ) return true ; else if( a.b == b.b ) return a.a &lt; b.a ; else return false ;&#125;int main()&#123; freopen("ariprog.in","r",stdin); freopen("ariprog.out","w",stdout); int n , m; cin &gt;&gt; n &gt;&gt; m ; init(m) ; int d = 1 ; int maxx = m*m + m*m ; bool flag = false ; while( ( n - 1 ) * d &lt;= maxx) &#123; for( int i = 0 ; i &lt;= maxx - ( n - 1 ) * d ; i++) &#123; bool f = true ; for( int j = i ; j &lt;= i + ( n - 1 ) * d ; j +=d ) &#123; if( a[j] == false ) &#123; f = false ; break ; &#125; &#125; if( f ) &#123; ans.push_back( node(i,d) ) ; flag = true ; &#125; &#125; d++ ; &#125; sort( ans.begin() , ans.end() , cmp ) ; if( flag ) for( vector&lt;node&gt; :: iterator iter = ans.begin() ; iter != ans.end() ; iter++) cout &lt;&lt; iter-&gt;a &lt;&lt; ' ' &lt;&lt; iter-&gt;b &lt;&lt; endl ; else cout &lt;&lt; "NONE" &lt;&lt; endl ; return 0 ; &#125; 2milk3 code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273 /*ID:xiekeyi1PROG:milk3LANG:C++*/#include&lt;bits/stdc++.h&gt;using namespace std ;const int maxn =25;bool vis[maxn][maxn];bool note[maxn];int aa[4];void dfs( int a , int b , int c )&#123; if( vis[a][b] ) return ; vis[a][b] = true ; if( a == 0 ) note[c] = true ; int temp[4]; temp[1] = a , temp[2] = b , temp[3] = c ; for( int i = 1 ; i &lt;= 3 ; i++) &#123; for( int j = 1 ; j &lt;= 3 ; j++) &#123; if( i != j ) &#123; if( temp[i] != 0 &amp;&amp; temp[j] &lt; aa[j] ) &#123; if( temp[i] &lt;= aa[j] - temp[j] ) &#123; int t1 = temp[i] , t2 = temp[j] ; temp[j] += temp[i] ; temp[i] = 0 ; dfs( temp[1] ,temp[2] , temp[3]); temp[i] = t1 , temp[j] = t2 ; &#125; if( temp[i] &gt; aa[j] - temp[j] ) &#123; int t1= temp[i] , t2 = temp[j] ; temp[i] -= aa[j] - temp[j] ; temp[j] = aa[j] ; dfs( temp[1] , temp[2] , temp[3]); temp[i] = t1 , temp[j] = t2 ; &#125; &#125; &#125; &#125; &#125;&#125;int main()&#123; freopen("milk3.in","r",stdin); freopen("milk3.out","w",stdout); cin &gt;&gt; aa[1] &gt;&gt; aa[2] &gt;&gt; aa[3] ; dfs( 0,0,aa[3]) ; for( int i = 0 ; i &lt;= aa[3] - 1 ; i++) &#123; if( note[i] ) cout &lt;&lt; i &lt;&lt; ' ' ; &#125; cout &lt;&lt; aa[3] &lt;&lt; endl ; return 0 ; &#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>USACO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO-Chapter1-Section1.3]]></title>
    <url>%2Ff9a5d242.html</url>
    <content type="text"><![CDATA[1milk code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758 /*ID:xiekeyi1PROG:milkLANG:C++ */#include&lt;bits/stdc++.h&gt;using namespace std ;const int maxm = 5050 ; struct P&#123; int price ; int amount ;&#125;a[maxm];bool cmp( struct P a , struct P b )&#123; return ( a.price &lt; b.price ) ;&#125;int main()&#123; freopen("milk.in","r",stdin); freopen("milk.out","w",stdout); ios::sync_with_stdio(false); cin.tie(false) ; int n ; int m ; cin &gt;&gt; n &gt;&gt; m ; for( int i = 1 ; i &lt;= m ; i++) cin &gt;&gt; a[i].price &gt;&gt; a[i].amount ; sort(a+1,a+1+m,cmp); int ans = 0 ; int cnt = 1 ; while( n != 0 ) &#123; if( a[cnt].amount &lt;= n ) &#123; n -= a[cnt].amount; ans += a[cnt].amount * a[cnt].price; a[cnt].amount = 0 ; &#125; else &#123; ans+= n * a[cnt].price ; a[cnt].amount -= n ; n = 0 ; &#125; cnt++; &#125; cout &lt;&lt; ans &lt;&lt; endl ; return 0 ; &#125; 2barn1 code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374 /*ID:xiekeyi1PROG:barn1LANG:C++ */#include&lt;bits/stdc++.h&gt;using namespace std ; int a[210]; int maxr = 0 ; int minl = 999 ; void filling( int l , int r )&#123; for( int i = l ; i &lt;= r ; i++ ) a[i] = 3 ; &#125;int func()&#123; int l = 0 , r = 0 ; int cnt = 0 ; for( int i = minl ; i &lt;= maxr ; i++) &#123; if( a[i] != 0 ) continue ; int temp = 1 ; int j ; for( j = i + 1 ; j &lt;= maxr ; j++) &#123; if( a[j] == 0 ) temp++; else break ; &#125; if( temp &gt;= ( r - l + 1 ) ) l = i , r = j - 1 , cnt = temp ; ; &#125; filling( l , r ) ; return cnt ; &#125;int main()&#123; freopen("barn1.in","r",stdin); freopen("barn1.out","w",stdout); int m , s , c ; cin &gt;&gt; m &gt;&gt; s &gt;&gt; c ; memset( a , 0 , sizeof(a) ) ; int ans = 0 , mm = 1 ; for( int i = 1 ; i &lt;= c ; i++) &#123; int t ; cin &gt;&gt; t ; a[t] = 1 ; maxr = max( t , maxr ) ; minl = min( minl , t ) ; &#125; ans = maxr - minl + 1 ; while( mm &lt; m &amp;&amp; mm &lt; c ) &#123; ans = ans - func() ; mm++; &#125; cout &lt;&lt; ans &lt;&lt; endl ; return 0 ; &#125; 3crypt1 code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768 /*ID:xiekeyi1PROG:crypt1LANG:C++ */#include&lt;bits/stdc++.h&gt;using namespace std ;int a[100];set&lt;int&gt; b ;bool judge( int n )&#123; while( n != 0 ) &#123; if( !b.count( n % 10 ) ) return false ; n /= 10 ; &#125; return true ; &#125;int main()&#123; freopen("crypt1.in","r",stdin); freopen("crypt1.out","w",stdout); int n ; cin &gt;&gt; n ; for( int i = 1 ; i &lt;= n ; i++) &#123; cin &gt;&gt; a[i]; b.insert(a[i]) ; &#125; int ans = 0 ; int q = 0 , w = 0 , e = 0 ; for( int i = 1 ; i &lt;= n ; i++) &#123; for( int j = 1 ; j &lt;= n ; j++) &#123; for( int k = 1 ; k &lt;= n ; k++) &#123; for( int l = 1 ; l &lt;= n ; l++) &#123; for( int m = 1 ; m &lt;= n ; m++) &#123; q = ( a[i] * 100 + a[j] * 10 + a[k] ) * a[m] ; w = ( a[i] * 100 + a[j] * 10 + a[k] ) * a[l]; e = ( a[i] * 100 + a[j] * 10 + a[k] ) * ( a[l] * 10 + a[m] ) ; if( w &lt; 1000 &amp;&amp; q &lt; 1000 &amp;&amp; e &lt; 10000 &amp;&amp; judge(q) &amp;&amp; judge(w) &amp;&amp; judge(e) ) &#123; ans++; //cout &lt;&lt; q &lt;&lt; ' ' &lt;&lt; w &lt;&lt; ' ' &lt;&lt; e &lt;&lt; endl ; &#125; &#125; &#125; &#125; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl ; return 0 ; &#125; 4combo code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687 /*ID:xiekeyi1PROG:comboLANG:C++ */#include&lt;bits/stdc++.h&gt;using namespace std ;int n ;int john[4] , master[4];int similar( int a , int b )&#123; if( a &gt;= n - 1 &amp;&amp; b &lt;= n -1 ) return min( abs( a - b ) , abs( a - n - b ) ) ; if( b &gt;= n - 1 &amp;&amp; a &lt;= n - 1 ) return min( abs( a - b ) , abs( b - n - a ) ) ; return abs( a - b ) ; &#125;//int s( int a[] , int b )//&#123;// int minn = 99999999 ;// for( int i = 1 ; i &lt;= 3 ; i++ )// minn = min( minn , similar( b , a[i] ) ) ;//// return minn ;//&#125;bool judge( int a , int b , int c )&#123; int cnt = 0 ; if( similar( john[1] , a ) &lt;= 2 ) cnt++; if( similar( john[2] , b ) &lt;= 2 ) cnt++; if( similar( john[3] , c ) &lt;= 2 ) cnt++; if( cnt == 3 ) return true ; cnt = 0 ; if( similar( master[1] , a ) &lt;= 2 ) cnt++; if( similar( master[2] , b ) &lt;= 2 ) cnt++; if( similar( master[3] , c ) &lt;= 2 ) cnt++; if( cnt == 3 ) return true ; return false ; &#125;int main()&#123; freopen("combo.in","r",stdin); freopen("combo.out","w",stdout); cin &gt;&gt; n ; cin &gt;&gt; john[1] &gt;&gt; john[2] &gt;&gt; john[3] &gt;&gt; master[1] &gt;&gt; master[2] &gt;&gt; master[3] ; int ans = 0 ; for( int i = 1 ; i &lt;= n ; i++ ) &#123; for( int j = 1 ; j &lt;= n ; j++) &#123; for( int k = 1 ; k &lt;= n ; k++) &#123; if( judge( i , j , k ) ) &#123; ans++ ; // cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; j &lt;&lt; ' ' &lt;&lt; k &lt;&lt; endl ; &#125; &#125; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl ; return 0 ; &#125; 5wormhole code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899 /*ID:xiekeyi1PROG:wormholeLANG:C++ */#include&lt;bits/stdc++.h&gt;using namespace std ;int n ;int ans = 0 ;int b[15] ;struct node&#123; int x , y ;&#125;a[15];bool cmp( struct node a , struct node b )&#123; if( a.y &lt; b.y ) return 1 ; else if( a.y == b.y) return a.x &lt; b.x ; else return false ;&#125;bool doit( int num , int x , int begin , int into )&#123; if( num != 1 &amp;&amp; begin == x &amp;&amp; into == 0 ) return true ; else if( into == 0 ) &#123; if( a[x].y == a[x+1].y ) &#123; return doit( num+1,x+1,begin,1 ); &#125; else return false ; &#125; else &#123; return doit( num+1, b[x] , begin , 0 ) ; &#125;&#125;bool judge()&#123; for( int i = 1 ; i &lt;= n ; i++) if( doit( 1 , i , i , 0 ) == 1 ) return true ; return false ; &#125;void mpair( int x )&#123; if ( x == n + 1 ) &#123; if( judge() == 1) ans++; return ; &#125; else if( b[x] == 0 ) &#123; for( int i = x + 1 ; i &lt;= n ; i++) &#123; if( b[i] == 0 ) &#123; b[x] = i ; b[i] = x ; mpair(x+1); b[x] = 0 ; b[i] = 0 ; &#125; &#125; &#125; else mpair(x+1);&#125;int main()&#123; freopen("wormhole.in","r",stdin); freopen("wormhole.out","w",stdout); cin &gt;&gt; n ; for( int i = 1 ; i &lt;= n ; i++) cin &gt;&gt; a[i].x &gt;&gt; a[i].y ; sort(a+1,a+1+n,cmp) ; mpair(1); cout &lt;&lt; ans &lt;&lt; endl ; return 0 ; &#125; 6skidegisn code1234567891011121314151617181920212223242526272829303132333435363738394041 /*ID:xiekeyi1PROG: skidesign LANG:C++*/#include&lt;bits/stdc++.h&gt;using namespace std ;const int maxn = 1010 ;int a[maxn];int main()&#123; freopen("skidesign.in","r",stdin); freopen("skidesign.out","w",stdout); int n ; int ans = 0x7FFFFFFF; cin &gt;&gt; n ; for( int i = 1 ; i &lt;= n ; i++) cin &gt;&gt; a[i] ; sort( a+1 , a+1+n ) ; for( int i = a[1] ; i &lt;= a[n] ; i++) &#123; int temp = 0 ; for( int j = 1 ; j &lt;= n ; j++) &#123; if( a[j] &lt; i ) temp+= static_cast&lt;int&gt; ( pow( abs( i - a[j] ) , 2 ) ) ; if( a[j] &gt; i + 17 ) temp += static_cast&lt;int&gt; ( pow( abs( i + 17 - a[j] ) , 2 ) ) ; &#125; ans = min( ans , temp ) ; &#125; cout &lt;&lt; ans &lt;&lt; endl ; return 0 ; &#125; ** 错误代码 ** code123456789101112131415161718192021222324252627282930313233343536373839404142434445 /*ID:xiekeyi1PROG: skidesign LANG:C++*/// ??óD????è? 2 1 100 ?a?ùμ?ê?è??êìa #include&lt;bits/stdc++.h&gt;using namespace std ;const int maxn = 1010 ;int a[maxn];int main()&#123; freopen("skidesign.in","r",stdin); freopen("skidesign.out","w",stdout); int n ; int ans = 0xFFFFFFF; cin &gt;&gt; n ; for( int i = 1 ; i &lt;= n ; i++) cin &gt;&gt; a[i] ; sort( a+1 , a+1+n ) ; for( int i = 1 ; i &lt;= n ; i++) &#123; for( int j = n ; j &gt;= i ; j-- ) &#123; if( a[j] - a[i] &lt;= 17 ) &#123; int temp = 0 ; for( int k = 1 ; k &lt; i ; k++) temp += static_cast&lt;int&gt; ( pow( abs( a[k] - a[i] ) , 2 ) ) ; for( int k = n ; k &gt; j ; k-- ) temp+= static_cast&lt;int&gt; ( pow( abs( a[k] - a[j] ) , 2 ) ) ; ans = min( temp , ans) ; &#125; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl ; return 0 ; &#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>USACO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO-Chapter1-Section1.2]]></title>
    <url>%2F8ea2e2d4.html</url>
    <content type="text"><![CDATA[1milk2 code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657 /*ID:xiekeyi1PROG:milk2LANG:C++ */#include&lt;bits/stdc++.h&gt;using namespace std ; const int MAXN = 5010;struct point &#123; int begin , end ;&#125; a[MAXN] ;bool cmp( struct point a , struct point b )&#123; if( a.begin &lt; b.begin) return true ; else if( a.begin == b.begin &amp;&amp; a.end &lt; b.end ) return true ; else return false ; &#125;int main()&#123; freopen("milk2.in","r",stdin); freopen("milk2.out","w",stdout); int n ; cin &gt;&gt; n ; for( int i = 1 ; i &lt;= n ; i++) cin &gt;&gt; a[i].begin &gt;&gt; a[i].end ; sort(a+1,a+1+n,cmp) ; int ans1= 0 , ans2 = 0 ; int tem_begin = a[1].begin , tem_end= a[1].end; ans1 = max( tem_end - tem_begin , ans1 ); for( int i = 2 ; i &lt;=n ; i++) &#123; if( a[i].begin &lt;= tem_end) &#123; tem_end = max( tem_end , a[i].end) ; &#125; else &#123; ans1 = max(ans1 , tem_end - tem_begin ) ; ans2 =max( ans2 , a[i].begin - tem_end) ; tem_begin = a[i].begin; tem_end = a[i].end ; &#125; &#125; cout &lt;&lt; ans1 &lt;&lt; ' ' &lt;&lt; ans2 &lt;&lt; endl ; return 0 ; &#125; 2transform code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166 /*ID:xiekeyi1PROG:transformLANG:C++*/#include&lt;bits/stdc++.h&gt;using namespace std ;//#define DEBUG const int maxn = 15 ;char a[maxn][maxn] , b[maxn][maxn] , c[maxn][maxn];//template&lt;typename T&gt;//void swap( T &amp;a , T &amp;b )//&#123;// T c ;// c = a ;// a = b ;// b = a ; // return ; //&#125;bool judge( char a[maxn][maxn] , char b[maxn][maxn] , int &amp;n )&#123; for( int i = 1 ; i &lt;= n ; i++) for( int j = 1 ; j &lt;= n ; j++) if( a[i][j] != b[i][j] ) return false ; return true ;&#125;int rolate( int &amp;n )&#123; for( int i = 1 ; i &lt;= n ; i++) &#123; for( int j = 1 ; j &lt;= n ; j++) &#123; c[j][n-i+1] = a[i][j] ; &#125; &#125; if( judge( c , b , n ) ) return 1 ; for( int i = 1 ; i &lt;= n ; i++) &#123; for( int j = 1 ; j &lt;= n ; j++) &#123; c[n-i+1][n-j+1] = a[i][j] ; &#125; &#125; if( judge ( c , b , n ) ) return 2; for( int i = 1 ; i &lt;= n ; i++) &#123; for( int j = 1 ; j &lt;= n ; j++) &#123; c[n-j+1][i] = a[i][j] ; &#125; &#125; if( judge ( c , b , n ) ) return 3 ; for( int i = 1 ; i &lt;= n ; i++) for( int j = 1 ; j &lt;= n ; j++) c[i][j] = a[i][j] ; for( int i = 1 ; i &lt;= n ; i++) &#123; for( int j = 1 ; j &lt;= n / 2 ; j++) &#123; swap( c[i][j] , c[i][n-j+1]) ; &#125; &#125; if( judge( c , b , n ) ) return 4 ; // for( int i = 1 ; i &lt;= n ; i++) // for( int j = 1 ; j &lt;=n ; j++) // c[i][j] = a[i][j] ;#ifdef DEBUG for( int i = 1 ; i &lt;= n ; i++) &#123; for( int j = 1 ; j &lt;= n ; j++) cout &lt;&lt; c[i][j]; cout &lt;&lt; endl ; &#125; cout &lt;&lt; endl &lt;&lt; endl ; #endif char d[maxn][maxn]; for( int i = 1 ; i &lt;= n ; i++) for( int j = 1 ; j &lt;= n ; j++) d[j][n-i+1] = c[i][j] ;#ifdef DEBUG for( int i = 1 ; i &lt;= n ; i++) &#123; for( int j = 1 ; j &lt;= n ; j++) cout &lt;&lt; d[i][j] ; cout &lt;&lt; endl ; &#125; cout &lt;&lt; endl &lt;&lt; endl ;#endif if( judge( d , b , n ) ) return 5 ; for( int i = 1 ; i &lt;= n ; i++) for( int j = 1 ; j &lt;= n ; j++) d[n-i+1][n-j+1] = c[i][j] ;#ifdef DEBUG for( int i = 1 ; i &lt;= n ; i++) &#123; for( int j = 1 ; j &lt;= n ; j++) cout &lt;&lt; d[i][j] ; cout &lt;&lt; endl ; &#125; cout &lt;&lt; endl &lt;&lt; endl ;#endif if( judge( d , b , n ) ) return 5 ; for( int i = 1 ; i &lt;= n ; i++) for( int j = 1 ; j &lt;= n ; j++) d[n-j+1][i] = a[i][j] ;#ifdef DEBUG for( int i = 1 ; i &lt;= n ; i++) &#123; for( int j = 1 ; j &lt;= n ; j++) cout &lt;&lt; d[i][j] ; cout &lt;&lt; endl ; &#125; cout &lt;&lt; endl &lt;&lt; endl ;#endif if( judge( d , b , n ) ) return 5 ; if( judge( a , b , n ) ) return 6 ; return 7 ; &#125;int main()&#123; freopen("transform.in","r",stdin); freopen("transform.out","w",stdout) ; int n ; cin &gt;&gt; n ; char ch ; for( int i = 1 ; i &lt;= n ; i++) for( int j = 1 ; j &lt;=n ; j++) &#123; cin &gt;&gt; ch ; a[i][j] = ch ; &#125; for( int i = 1 ; i &lt;= n ; i++ ) for( int j = 1 ; j &lt;= n ; j++) &#123; cin &gt;&gt; ch ; b[i][j] = ch ; &#125; cout &lt;&lt; rolate(n) &lt;&lt; endl ; return 0 ; &#125; 3namenum code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 /*ID:xiekeyiPROG:namenumLANG:C++ */#include&lt;bits/stdc++.h&gt;#include&lt;iostream&gt;using namespace std ;int f( char ch )&#123; if( ch &lt; 'Q' ) return ( ch - 'A' + 1 + 2 ) / 3 + 1 ; else return ( ch - 'A' + 1 + 1 ) / 3 + 1 ;&#125;long long func( string &amp;s) &#123; long long ans = 0 ; for( int i = 0 ; i &lt; s.size() ; i++) ans = ans*10 + f(s[i]) ; return ans ;&#125;int main()&#123; ifstream fin ; freopen("namenum.out","w",stdout); fin.open("namenum.in",fstream::in); long long n ; fin &gt;&gt; n ; string s ; fin.close() ; fin.open("dict.txt",fstream::in); bool flag = false ; while( fin &gt;&gt; s ) if( func(s) == n ) &#123; cout &lt;&lt; s &lt;&lt; endl ; flag = true ; &#125; if( !flag ) cout &lt;&lt; "NONE" &lt;&lt; endl ; fin.close() ; return 0 ; &#125; 4palsquare code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273 /*ID:xiekeyi1PROG:palsquareLANG:C++ */#include&lt;bits/stdc++.h&gt;using namespace std ;const int maxn = 1000;int a[maxn] , b[maxn] ;void translate( int n , int B , int flag , int &amp;d )&#123; int digit = 0 ; while( n != 0 ) &#123; if( flag == 1 ) a[digit++] = n % B ; else b[digit++] = n % B ; n /= B ; &#125; d = digit ; return ; &#125;bool judge( int b[] , int d )&#123; for( int i = 0 ; i &lt;= d / 2 ; i++) if( b[i] != b[d-i-1] ) return false ; return true ;&#125;ostream&amp; p( int b[] , int d ) &#123; for( int i = d - 1 ; i &gt;= 0 ; i--) &#123; if( b[i] &lt; 10 ) cout &lt;&lt; b[i] ; else cout &lt;&lt; static_cast&lt;char&gt; ( b[i] - 10 + 'A' ) ; &#125; return cout ; &#125;int main()&#123; freopen("palsquare.in","r",stdin); freopen("palsquare.out","w",stdout); int B ; cin &gt;&gt; B ; for( int i = 1 ; i &lt;= 300 ; i++) &#123; int d1 = 0 , d2 = 0 ; int t = i * i ; translate( t , B , 2 , d2 ) ; if( judge( b , d2 ) ) &#123; translate( i , B , 1 , d1 ) ; p(a,d1) &lt;&lt; ' ' ; p(b,d2) &lt;&lt; endl ; &#125; &#125; return 0 ; &#125; 5dualpal code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960 /*ID:xiekeyi1PROG:dualpalLANG:C++ */#include&lt;bits/stdc++.h&gt;using namespace std ;const int maxn = 100 ;int a[maxn] ;void f( int a[] , int n , int b , int &amp;d )&#123; int digit = 0 ; while( n != 0 ) &#123; a[digit++] = n % b ; n /= b ; &#125; d = digit ; return ; &#125;bool judge( int a[] , int d )&#123; for( int i = 0 ; i &lt;= d/2 ; i++) if( a[i] != a[ d-i-1] ) return false ; return true ;&#125;int main()&#123; freopen("dualpal.in","r",stdin); freopen("dualpal.out","w",stdout); int n , s ; cin &gt;&gt; n &gt;&gt; s ; int i = 0 ; int temp = s+1 ; for( i = 0 ; i &lt; n ; ) &#123; int flag = 0 ; for( int j = 2 ; j &lt;= 10 ; j++) &#123; int d = 0 ; f(a,temp,j,d); if( judge( a , d ) ) flag++; if( flag &gt;= 2 ) &#123; cout &lt;&lt; temp &lt;&lt; endl ; i++; break ; &#125; &#125; temp++; &#125; return 0 ; &#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>USACO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO Chapter1 Section1.1]]></title>
    <url>%2F6a6ef8c4.html</url>
    <content type="text"><![CDATA[0test ```c++ code12345678910111213141516171819 /*ID:xiekeyi1PROG:testLANG:C++*/#include&lt;bits/stdc++.h&gt;using namespace std ;int main()&#123; freopen("test.in","r",stdin); freopen("test.out","w",stdout) ; long long a , b ; cin &gt;&gt; a &gt;&gt; b ; cout &lt;&lt; a + b &lt;&lt; endl ; return 0 ; &#125; ### 1ride code12345678910111213141516171819202122232425262728 /*ID:xiekeyi1PROG:rideLANG:C++*/#include&lt;bits/stdc++.h&gt;using namespace std ;int main()&#123; freopen("ride.in","r",stdin); freopen("ride.out","w",stdout) ; string s1 , s2 ; cin &gt;&gt; s1 &gt;&gt; s2 ; int ans1 = 1 , ans2 = 1 ; for( int i = 0 ; i &lt; s1.size() ; i++) ans1 *= (s1[i] - 'A' + 1 ) % 47 ; for( int i = 0 ; i &lt; s2.size() ; i++) ans2 *= (s2[i] - 'A' + 1 ) % 47 ; ans1 %= 47 , ans2 %= 47 ; if( ans1 == ans2 ) cout &lt;&lt; "GO" &lt;&lt; endl ; else cout &lt;&lt; "STAY" &lt;&lt; endl ; return 0 ; &#125; 2gift code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455 /*ID:xiekeyi1PROG:gift1LANG:C++*/#include&lt;bits/stdc++.h&gt;using namespace std ;map&lt;string,int&gt; na;struct &#123; string name ; int account = 0 ; int begiven = 0 ; &#125;a[1000];int main()&#123; freopen("gift1.in","r",stdin); freopen("gift1.out","w",stdout); int n ; cin &gt;&gt; n; for( int i = 1 ; i &lt;= n ; i++) &#123; cin &gt;&gt; a[i].name ; na[ a[i].name] = i ; &#125; string tempname ; int tempmoney , ng ; while( cin &gt;&gt; tempname &gt;&gt; tempmoney &gt;&gt; ng ) &#123; int tem = 0 ; a[ na[tempname] ].account -= tempmoney ; if( ng != 0 ) &#123; tem = tempmoney / ng ; a[ na[tempname] ].account = a[ na[tempname] ].account - ( a[ na[tempname] ].account + tem * ng ) ; &#125; for( int i = 1 ; i &lt;= ng ; i++) &#123; string t ; cin &gt;&gt; t ; a[ na[t] ] . begiven += tem ; &#125; &#125; for( int i = 1 ; i &lt;= n ; i++) &#123; cout &lt;&lt; a[i].name &lt;&lt; ' ' &lt;&lt; a[i].account + a[i].begiven &lt;&lt; endl ; &#125; return 0 ;&#125; code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586 ### 3friday```c++/*ID:xiekeyi1PROG:fridayLANG:C++*/#include&lt;bits/stdc++.h&gt;using namespace std ;int a[10] = &#123;0&#125; ;bool isleapyear( int n )&#123; if( n % 4 == 0 &amp;&amp; n % 100 != 0 ) return true ; else if( n % 400 == 0 ) return true ; else return false ;&#125;int days_month( int y , int m )&#123; switch(m)&#123; case 1 : case 3 : case 5 : case 7 : case 8 : case 10: case 12: return 31 ; case 4 : case 6 : case 9 : case 11 : return 30 ; case 2: if( isleapyear(y) ) return 29 ; else return 28 ; &#125;&#125;int days( int y , int m , int d )&#123; int ans = 0 ; for( int i = 1900 ; i &lt; y ; i++) &#123; if( isleapyear( i ) ) ans+=366; else ans+=365; &#125; for( int i = 1 ; i &lt; m ; i++) &#123; ans+= days_month( y , i ) ; &#125; ans += d ; return ans - 1 ; &#125; int main()&#123; freopen("friday.in" , "r" , stdin) ; freopen("friday.out" , "w" , stdout) ; int n ; cin &gt;&gt; n ; for( int i = 1900 ; i &lt; ( n + 1900 ) ; i++) &#123; for( int j = 1 ; j &lt;= 12 ; j++) a[ days(i,j,13) % 7 + 1 ]++ ; &#125; cout &lt;&lt; a[6] &lt;&lt; ' ' &lt;&lt; a[7] &lt;&lt; ' ' &lt;&lt; a[1] &lt;&lt; ' ' &lt;&lt; a[2] &lt;&lt; ' ' &lt;&lt; a[3] &lt;&lt; ' ' &lt;&lt; a[4] &lt;&lt; ' ' &lt;&lt; a[5] &lt;&lt; endl ; return 0 ; &#125; 4beads code123456789101112131415161718192021222324252627282930313233343536 /*ID:xiekeyi1PROG:beadsLANG:C++*/#include&lt;bits/stdc++.h&gt;using namespace std ; int main()&#123; freopen("beads.in","r",stdin); freopen("beads.out","w",stdout); int n ; string s ; cin &gt;&gt; n &gt;&gt; s ; s+=s; int a = 0 , b = 0 , w = 0 , c = 0 , ans = 0 ; for( int i = 0 ; i &lt; n*2 ; i++) &#123; if( s[i] == 'w' ) b++,w++; else if( s[i] == c ) b++,w=0; else &#123; ans = max( a+b,ans) ; a = b - w ; b = w + 1 ; w = 0 ; c = s[i] ; &#125; &#125; ans = max( a+b , ans ) ; cout &lt;&lt; min( ans , n ) &lt;&lt; endl ; return 0 ; &#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>USACO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[遇到的不错的思维水题]]></title>
    <url>%2F4888449e.html</url>
    <content type="text"><![CDATA[本文持续更新。 题目 矩阵翻转问题 给定一个01矩阵n*m ， \(n , m \leq 1000\) 。 两人轮流操作： 每次选择一个数值为1的点： 使得每次选择的点(包含)到右下角的矩阵01状态翻转。 无法操作则输。 问先手必胜还是后手必胜？ 题目来源: 2017Summertraining V8 讲课 博弈论 树翻转问题 上一道题进阶版：hdu5963(2016 CCPC 合肥) 一棵树，每个边有一个边权1,0。每次选一个边权为1的边， 将从这个边开始到根的路径的所有边的边权翻转。 不能操作则输。 问先手胜还是后手胜？ K倍动态减法游戏 两个人轮流取石子，第一次取可以取任意个(0除外)，但是不能取完，以后每次都只能取不超过上一次取的k倍(0除外)。 问先手必胜，还是后手必胜？ 当k = 2时 hdu2516 当\(1 \leq k \leq 1e5\) hdu2580 毒药问题 1000个瓶子中有一瓶毒药（编号000 ~ 999 ），一只老鼠吃到毒药一周后会死，瓶子里有无穷多的药水，老鼠可以吃任意瓶药水。 1. 如果只有10只老鼠，如何在一周内检测出老鼠所吃的毒药的编号是由哪几位数字组成？（如毒药为 413号的话，答案是1 3 4 、 3 1 4 、 4 1 3 等都对） 2. 如果只有10只老鼠，如何在一周内检测出所吃的毒药是哪一瓶？ 3. 如果要在两周内检测出哪一瓶是毒药，最少需要几只老鼠？ Codeforces Taxes 题目链接：Codeforces Round #382 (Div. 2)-735D TAXES 题意：年收入是N，那么需要缴税额是N除自身外的最大因子。为了偷税可以把N拆成K个数，但是拆成的数不能为1，因为这样会被税务局发现。找出最小税额。 好像是CCPC 2017 哈尔滨题 输入一个n，已知该数列是由 1 - n 共n个数组成的。 要求构造一个数列，数列满足 \[a\_{n} \\bmod | a\_{n} - a\_{n-2} | =0\] 给出任意一个满足要求的数列。 ----- 解答 矩阵反转问题 我们观察到无论如何进行游戏，每次必将使局面减少1个1(换句话说，将1个1恒久地变为0了，不可能再变回来了) 因此局面是朝着右下角不断缩小的。 最后必然缩小到最后一个格。 那么，如果右下角一开始是0，先手无论如何操作，都会将右下角变成1，后手只要将右下角一个变成0。那么这样操作下去，给先手的人一定是一个右下角是0的局面。所以先手必输。 反之，先手必胜。 (这道题很适合讲完博弈论的必胜必败态后出一下2333) 树翻转问题 考虑假如只有一条链，那么先手如果将第一个边的1变成0，后手无论怎么操作，都只能把这个1变回去，或者不可操作输了。 因此，如果第一个边是1，那么先手必胜。 如果是树的话，只需要知道和这棵树的根节点连接的边权为1的边的个数是奇数还是偶数就可以了。 (这里已经有点SG函数、异或之类的意思了) k倍动态减法游戏。 我目前对这里的理解还有一些问题，未完待续，仅供参考。 1. 当k等于1时，我们将石子数拆成二进制数，会发现先手如果每次只取1个的话，会把最后一位由1变成0，或者由0变成1。因此，只要最后一位是1的话，先手必胜。否则后手必胜。(因为局面必定会缩小到最后只有一位) 2. 1. 当k等于2时，同样将石子拆成二进制数，如果第一次取了1个，会发现第二次取只能取1个（即将最后一位0 1变换）或者取2个（即将倒数第二位0 1变换） ， 然后由任何一个正整数都可以由两个斐波那契数相加得到，求解.(我对这里不太理解，未完待续) 用必胜态必败态DP转移得到。不过这里细节比较多，比如dp[n][n]在第一手的时候因为不能拿完，但是在第二手又可以拿完，这里需要注意一下变化。 这道题V8当时主要讲的是如何把\(O(n^{3})\) (朴素)* 优化到\(O(n^{2})\) (减少维数) 再优化到\(O(n)\) (单调栈) 。 第一次听讲的时候惊艳了。 当到k倍的问题的时候，请参考NOI2009冬令营论文——《从“k倍动态减法游戏”出发探究一类组合游戏问题》 毒药问题 这其实是我一开始错误的想法改编后成的问题。 对于这样的话，只要让所有数字带0的药水，给第0个老鼠吃，所有数字带1的药水给第1个老鼠吃即可由哪几只老鼠死亡来判断所含数字。 将1000瓶药水的编号二进制拆分，正好是10位以内，即可把10只老鼠分别对应一个二进制位。由此准确确定毒药的二进制位，转成十进制即可。 将1000瓶药水三进制拆分，这样第一天可确定毒药每一位数字是否为0，第二天可确定是否为1，然后排除法确定哪些是2。 1000转成三进制是7位，所以需要7只老鼠。 Codeforces Taxes 哥德巴赫猜想。 需要注意的是，人们熟知的哥德巴赫猜想，是\(1+1=2\)，但是那是建立在1被作为素数的情况下。 因此，现代的哥德巴赫猜想有些不同。 &gt;原初猜想的现代陈述为：任一大于5的整数都可写成三个质数之和。欧拉在回信中也提出另一等价版本，即任一大于2的偶数都可写成两个质数之和。 &gt;今日常见的猜想陈述为欧拉的版本，即任一大于2的偶数都可写成两个素数之和，亦称为“强哥德巴赫猜想”或“关于偶数的哥德巴赫猜想”。 &gt;从关于偶数的哥德巴赫猜想，可推出：任一大于7的奇数都可写成三个质数之和的猜想。后者称为“弱哥德巴赫猜想”或“关于奇数的哥德巴赫猜想”。若关于偶数的哥德巴赫猜想是对的，则关于奇数的哥德巴赫猜想也会是对的。弱哥德巴赫猜想尚未完全解决，但1937年时前苏联数学家维诺格拉多夫已经证明充分大的奇质数都能写成三个质数的和，也称为“哥德巴赫-维诺格拉朵夫定理”或“三素数定理”。 因此，我们只需要对 大于7的奇数，判断他是否是由一个质数+2这个质数得来的，如果是，则答案为2，否则为3. 对大于2的偶数，答案为2. 好像是CCPC 2017 哈尔滨的题 本来我想的是任意偶数差两个都可以满足要求，但是奇数和质数就不太满足，然后考虑了一下，质数要满足，必定是$ a_{n} 与 a_{n-2} $ 相差1。因为任何数 mod 1 都是0 。 所以考虑构造数字的方法就是 类似于蛇形填数，第 1、3、5、7、.... n-1 依次填1234567，然后n-2、6、4、...2 以此填写8 9 10 11... 即可]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>水题</tag>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 442 Div.2 877B Nikita and String]]></title>
    <url>%2Ff11372ef.html</url>
    <content type="text"><![CDATA[题目链接： Codeforces 442 Div.2 B 题意: 给出一个只由小写字母ab组成的串，删除任意字符后，将剩下的拼起来（不改变顺序） ，问剩下的串满足由:\(s\_{1}\)、\(s\_{2}\)、\(s\_{3}\) 组成，其中\(s\_{1}\)为全部由小写字母a组成的或者是空串，\(s\_{2}\)为全部由小写字母b组成的或者是空串, \(s\_{3}\)为全部由小写字母a组成的或者是空串。 求满足这样条件的串，最长的长度是多少？( |s| &lt; 5000 ) 一开始比赛的时候，我考虑的是维护一个前缀和，把a看为正数，把b看为负数。 然后前缀和维护的话大概就是这么一个样子。 12345678910111213141516for( int j = i ; j &lt; length + 1 ; j++) &#123; if( s[i] == s[j] ) cnt++; else &#123; i = j - 1 ; if( s[i] == 'a' ) a.push_back( cnt ) ; else if(s[i] == 'b' ) a.push_back( -cnt ) ; cnt = 0 ; break ; &#125; &#125; &#125; 然后我想当然的认为，这道题就是求 Max{ a[i] + a[j] + a[k] ) ( i &lt; j &lt; ) } 结果WA了整整一个比赛。 主要原因是没有考虑到，有可能拼起来更长的情况。 比如: aaaabaaaaa 这样，可以把b删去后把a全部看成一起，这个做法没有考虑到这个情况。 思维太僵化了，其实有很简单的做法。结果经常自己陷入一开始的思维定式跳不出来。 做法1 因为数据量只由5000，所以其实可以直接\(n^{2}\)枚举分界点，然后前缀和之类的统计一下就可以了。 这道题细节不算少，分界点如何枚举，如何处理空串这类，我处理了不短的时间。 时间复杂度: \(O(n^{2})\) （前缀和） 做法2 我们可以用dp[n][3]这样的数组表示，其中dp[0]表示只由a构成的串，dp[1]表示由a、b构成的串，dp[2]表示由a、b、a构成的串。 那么，当我s[i] == 'a' 时， 123dp[i][0] = dp[i-1][0] + 1;dp[i][1] = dp[i-1][1] ;dp[i][2] = max( dp[i-1][1] + 1 , dp[i-1][2] + 1 ) ; 当 s[i] == 'b' 时 123dp[i][0] = dp[i-1][0] ;dp[i][1] = max( dp[i-1][1] + 1 , dp[i-1][0] + 1 ) ;dp[i][2] = dp[i-1][2] ; 转移应该是显而易见的。 对于只由a构成的串，每次都是遇到a的时候加一。 由ab构成的串，可以由 只由a的串转移而来，或者由ab串转移而来。 aba构成的串，可以由ab转移而来，也可以由aba转移而来。 时间复杂度: \(O(n)\) 做法3 我们可以把a看做是1，b看做是2，b后面的a看做是3. 那么题目就变成了求最长上升子序列（LIS）问题。 求LIS的做法有 \(O(n^{2})\)和\(O(nlogn)\)的做法。 这个写法本质上其实和做法2很像，因为只由3个数字的LIS，所以可以用做法2去实现。 因为这个方法细节较多，b前后的问题比较难处理，而且有了更容易理解的做法2. 因此没有写这个做法的代码。 做法1代码： code12345678910111213141516171819202122232425262728293031323334353637383940414243 // enumerate every interval .#include&lt;bits/stdc++.h&gt;using namespace std ;const int maxn = 5050 ;int a[maxn] , b[maxn];char s[maxn];int main()&#123; scanf("%s" , s + 1 ) ; int length = strlen(s+1) ; for( int i = 1 ; i &lt;= length ; i++) &#123; if( s[i] == 'a' ) a[i] = a[i-1] + 1 ; else a[i] = a[i-1]; if( s[i] == 'b' ) b[i] = b[i-1] + 1 ; else b[i] = b[i-1] ; &#125; int ans = 0 ; for( int i = 0 ; i &lt;= length + 1 ; i++) &#123; for( int j = i ; j &lt;= length + 1 ; j++) &#123; ans = max( ans , a[i] + b[j] - b[i] + ( ( j &gt;= length + 1 ) ? 0 : ( a[length] - a[j] ) ) ) ; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl ; return 0;&#125; 做法2代码： code123456789101112131415161718192021222324252627282930313233 #include&lt;bits/stdc++.h&gt;using namespace std ;const int maxn = 5050 ; int dp[maxn][3];int main()&#123; string s ; cin &gt;&gt; s ; for( int i = 0 ; i &lt; s.size() ; i++) &#123; if( s[i] == 'a' ) &#123; dp[i][0] = dp[i-1][0] + 1; dp[i][1] = dp[i-1][1] ; dp[i][2] = max( dp[i-1][1] + 1 , dp[i-1][2] + 1 ) ; &#125; else if( s[i] == 'b' ) &#123; dp[i][0] = dp[i-1][0] ; dp[i][1] = max( dp[i-1][1] + 1 , dp[i-1][0] + 1 ) ; dp[i][2] = dp[i-1][2] ; &#125; &#125; cout &lt;&lt; max( &#123; dp[s.size()-1][0] , dp[s.size()-1][1] , dp[s.size()-1][2] &#125; ) &lt;&lt; endl ; return 0 ; &#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>codeforces</tag>
        <tag>DP</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用HEXO+github.io搭建博客]]></title>
    <url>%2F461fdda0.html</url>
    <content type="text"><![CDATA[发现很多人都自建博客，比较可控也比较干净清爽，于是准备自己也搭建一个博客。 一方面熟悉一下具体流程，一方面是因为自己有一个空闲的腾讯云服务器。 正好可以把它利用起来。 优点: 可自己随意发表文章，没什么广告，清爽。 可自己折腾前端、研究建站。 很多东西存于本地，方便移植、备份、管理。 可以本地预览 缺点: 需要自己域名、服务器。比较花钱。( github.io ) 有免费空间。 搭建比较麻烦。 (本来我还想实习运维，结果自己照着框架、教程，还搭了一个周末) 事先了解了一下，常用的博客框架有jekyll(github官方推荐)、HEXO、Wordpress 。 wordpress收费，比较贵。优点是很容易搭建、比较友好。 不过因为自己本来就是为了折腾和学习，感觉优点反而成了缺点。所以不考虑了。 一开始比较想搭建jekyll，毕竟github官方推荐，和github.io配合最好。但是看HEXO扩展、支持又比较多。所以在这两个里面摇摆不定。 后来研究了一下发现jekyll是基于ruby的。 因为我认为我在Windows下写博客比较多，在Linux下主要只是写代码。 了解到ruby环境在Windows下比较难以搭建，比较麻烦。而HEXO是基于nodejs的，nodejs在Windows环境下比较友好。 考虑到这一点后，果断选择了HEXO。 本机环境搭建 安装Git环境 随便在git官网下载安装就好了。 注意一下它可以自动这是Path ，并且可以将Windows的回车换行转换成Linux的风格换行，这两个地方选择一下，在Windows下会变得比较方面。 在cmd(powershell)中输入 git --version , 显示版本号后即安装成功。 安装Node.js环境 在Node.js 找到适合自己系统的环境安装，一路下一步即可。 在cmd(powershell)中输入npm --version ， 显示版本号后即安装成功。 安装HEXO 命令行下输入 npm install hexo-cli -g , npm install hexo --save . npm是Node.js的包管理工具，可以理解为npm是用来安装Node.js程序的 hexo-cli是 hexo - Command Line Interface ，Hexo的命令行模式。 -g是指 -global， 全局安装。 表示将安装包放在 /usr/local 或 nodejs的安装目录。 可以直接在命令行中使用。 --save 是指自动处理一下依赖关系，将依赖关系的版本号和模块添加到 package.json 里。 安装完成后，cmd(powersheel)中输入 hexo --version ， 显示版本号后即安装成功。 本地使用HEXO 新建一个自己博客的文件夹。 用命令行进入该文件夹，输入 hexo init ，初始化本文件夹为hexo目录。 然后输入 npm install ，用npm自动安装所需要的组件。 接下来输入 hexo g ，即可生成博客。 输入 hexo s ， 即可在 http://localhost:4000/ 中预览自己的博客。 现在基本就可以使用HEXO了。 HEXO常用命令 hexo new "title" 即可在source/_post/ 文件夹里找到，在里面写文章即可。 hexo new page "newpage" 会在source/ 文件夹内创建一个新文件夹，对应一个新的页面（需要和_config.yml)相关联。 hexo g 生成本地页面 hexo d 将本地页面发布到网站上 hexo d -g ， 等价于 hexo g ; hexo d hexo s 开启本地服务器 ，可在本地预览。 HEXO的主题 可在github等很多地方找到。 使用方法各不相同，主要改好_config.yml和/themes/对应主题/_config.yml 即可 少部分主题怎么调都调不对，可考虑是主题问题。一开始我使用huno ，tags怎么调都有一些问题，后来换了主题后解决 这里推荐NEXT 主题， 使用教程多，持续更新，使用方便。 配置git 设置git的user name和email，用于标识自己git的身份。 12git config --global user.name &quot;Yourname&quot;git config --global user.email &quot;Youemail@xxx.com&quot; 这样就把全局的名字设置好了。 生成密钥 运行 ssh-keygen -t rsa -C "xxxxx@xxx.com" -t用于制定密钥类型为rsa，-C提供一个注释. 这样就生成了一对公钥和私钥。 LINUX默认放在/home/.ssh目录下 WINDOWS默认在C:\Users\xxxx\.ssh 下 将公钥id_rsa.pub 内的内容复制放到仓库-setting-Deploy keys下 或放到个人设置-SSH and GPG keys下即可 通过自己的私钥和公钥配对来证明自己本人。 Github Pages Github提供了 xxxx.github.io 这个域名供我们使用。 我们在github里新建一个仓库，取名为 xxxxx.github.io (必须取这个名字) 然后github会自动帮我们配置好各种文件。 之后在HEXO安装包里找到_config.xml ， 写成如下这段（如果前面有#号删掉即可，#号表示注释） 1234deploy: type: git repo: https://github.com/xxxxx/xxxxxx.github.io.git branch: master 然后即可通过 HEXO D 将自己已经生成的数据发布到该域名了。 之后即可通过该域名访问你的博客了，也可自己购买域名后做CNAME解析。 备份问题 做好备份可以方便跨电脑写作或更换电脑等情况。 我是新建了一个仓库用来备份，只要 1234git init git add .git commitgit push 这样就可以了。 有的人是新建分支来备份，我因为还不太熟练git所以没有采用。 另外有部分已经有git下来的文件夹(比如我的主题) 我还不知道怎么用git push 上去。 在此提供一个思路。 将其部署在自己的云服务器上 这是我折腾最久的一点。。。 我的环境是Ubuntu 16.04 LTS 腾讯云。 需要安装git和nginx. git是用来使自己的博客文件夹能推送发布到云服务器。 nginx是用来使自己的云服务器可以变成一个HTTP服务器，被广泛使用。 Nginx (engine x) 是一个高性能的HTTP和反向代理服务器，也是一个IMAP/POP3/SMTP服务器。 安装git(ubuntu大多默认自带) apt-get install git 安装nginx apt-get install nginx 配置云服务器 在/home/.ssh文件夹下创建一个authorized_keys文件，将id_rsa.pub复制后粘贴到这个文件内，即可在自己电脑上SSH到这台服务器。 建议创建一个专用的git用户来确保安全。 不过我一开始创建用户后很多权限处理都不太对，后来用默认用户成功以后也就没有再创建用户了。 然后在本地创建一个目录作为git仓库 比如在/home下 mkdir git 创建一个git文件夹 chown -R $USER:$USER /home/git chmod -R 755 /home/git 使当前用户有权限在这个git文件夹下搞事。 cd /home/git 进入该文件夹后 git init --bare hexo.git 创建一个hexo.git文件夹作为git仓库。 在/home/git/hexo.git/hook 文件夹下有一个post-update.sample文件，重命名为post-update后，修改内容为 123456#!/bin/shcd /cd /usr/share/nginx/html/git clone /home/git/hexo.gitcp -rf hexo/* .rm -rf hexo 表示每当该目录有更新，用bash命令，进入nginx默认目录，克隆该目录，将hexo的文件都复制下来，并删除hexo文件夹。 现在即可通过该云服务器IP访问自己博客了。 修改本机HEXO下的_config.yml 参照上文github.io的deploy写法即可。 也可以像我这样同时推送多个仓库(防止github无法正常访问，也为自己云服务器到期后切换到github提供方便） 一开始试了好多写法，发现都不太对。 最后查了下发现是 12345deploy: type: git repo: github: https://github.com/xxxxxx/xxxxx.github.io.git,master tencent: ubuntu@xxx.xxx.xxx.xxx.xxx:~/git/hexo.git,master 简单来说就是 12repo: 标签名: 地址 , 分支 遇到的一些坑 /usr/share/nginx/html/是nginx默认做网页的目录，不过不同安装方式该目录似乎不同。因此需要在/etc/nginx/的nginx.conf或/sites-enabled文件夹内 ，将root 后面的目录改为 /usr/share/nginx/html/文件夹。(发现还有的改site-available)文件夹的。 有的人修改的不是post-update文件，而是/hook/下新创建了一个post-receive文件进行了一些操作。 我没有试过，不知道是否可行 有很多时候问题是权限不够，我被这个坑了很久。请把用到的相关目录都添加相应权限。权限添加修改方法上文已给出 本文目的是为了给像我一样想自己搭建博客，又不知道怎么搭建，并且遇到很多坑不知道怎么解决的人一些帮助。 本文致力于使大家看完后都可以搭建成功。 因为本文开始动笔比学习搭建博客晚了一段时间，所以有些坑踩过后，不一定还记得是什么了，因此会有一些疏漏。 在阅读本文中有什么困难和不清晰，麻烦和我联系或评论。 以便我加以完善，方便更多人可以搭建出自己的博客。]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>HEXO</tag>
        <tag>github.io</tag>
      </tags>
  </entry>
</search>
