<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[travis-ci与codecov测试和测试覆盖度工具的使用]]></title>
    <url>%2F5e7bc721.html</url>
    <content type="text"><![CDATA[travis-ci和codecov测试工具的使用。 (未完待续，视后续使用情况补充更新) 今年参加了thoughtworks的线下结对编程体验活动。说来找了好多个网站都没有找到这个活动的详细信息，只有一些通知、公告和颁奖新闻。 终于在google找到了thoughtworks结对编程体验的一篇文章，碰巧还是去年一等奖。参考了他的历程和项目代码后，发现他使用了maven做项目管理，使用travis-ci做单元测试。 说来也是在这个研究过程中才发现，原来configure和makefile是有很多自动生成工具的(qmake、autotools等)，我一直以为是要手写的。 发现这个travis-ci，就是我一直很好奇的部分项目的测试贴纸。加上自己需要，所以简单学习了一下。 travis-ci travis-ci 是一个支持多平台、集成、持续的测试工具，这类工具其实有很多，这个是市场份额占的最大的。 个人公开仓库免费(私人仓库等我不太了解)，貌似必须和github一起使用才可以。 使用起来非常简单，只要注册账号，和github关联，然后在自己对应的项目中打开就可以。 打开以后，只要在自己的项目中添加.travis.yml文件，即可在每次push的时候，自动进行测试。 网上很多关于这个文件如何写的，都是php、js等语言，少量java、python，对于C++几乎没有。索性读了下文档，发现简单使用还是很简单的。 踩到的坑: 官方样例中只要写language: C++即可运行，但是实际上，那样默认的构建命令是./configure &amp;&amp; make &amp;&amp; make test 这样的话，我还研究了半天如何写configure，但是实际上，只要人工修改构建命令即可 给一下我的简单范例: 1234sudo: true #是否使用sudo命令执行language: C++script: - make 只要这么几句，就可以在每次运行的时候，执行测试了。不过这个测试只是执行了make，有进一步需求的话，可以在scrpit里，加入一个写好的bash，bash中运行自己的单元测试。 之后每次push的时候，就会在travis-ci的网站中的profile和github里的commit里看到测试结果。 如果需要贴纸的话，只要在profile里点击那个图标，即可得到markdown信息，加到readme里即可。 codecov codecov这是一个用来表示测试覆盖的代码有百分之多少的工具。使用起来，一开始看到别的教程，以为只需要在travis-ci中添加几句就可以，实际使用起来发现挺麻烦的。 截止目前，我并没有成功使用这个工具。 使用这个工具，大概需要安装codecov环境，并且使用gcov生成覆盖率测试文件。 因为使用样例给的是使用qmake，我自己一直手写makefile，所以暂时还没有成功使用。 具体请看参考资料。 参考资料 Travis CI Docs codecov documentation GCOV的使用-测试代码覆盖率 Travis CI 系列：自动化部署博客 持续集成服务 Travis CI 教程 Github装逼指南——Travis CI 和 Codecov]]></content>
      <categories>
        <category>工程</category>
      </categories>
      <tags>
        <tag>测试</tag>
        <tag>工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces #486(Div.3) CF988D Points and Powers of Two]]></title>
    <url>%2Ff4a229d0.html</url>
    <content type="text"><![CDATA[题意: 给出n个数字，找出这n个数字的一个子集，使得子集中任意两两(包括自己和自己)相减的数字，都是2的非负次幂。 题目链接:http://codeforces.com/contest/988/problem/D 错误想法 1234567for( 遍历元素 a[i] = a[1] to a[n] ) delta = 0 while( delta &lt;= MAXN ) if( 二分查找到( a[i] + delta ) ) 记录 a[i] + delta . dleta = ( delta == 0 ) ? 1 : delta * 2 维护最大值 时间复杂度: \(O(n* logMAXN * logn )\) WA在6上，一开始以为是MAXN开的不够大（第一次开了2e5），结果改到2e9后，反而WA1了。后来发现，这个思路根本不对，因为无法保证，任意两两相减的数字，都是2的非负次幂。 正确做法 有一个结论:这样的数组最多只会有3个 简单证明： 对于只有一个数字\(a\)的情况，显然成立。\(( a-a = 0 = 2^0 )\) 对于只有两个数字\(a，b\)的情况，只会有： \(( b - a = 2^x )\) 对于只有三个数字\(a,b,c,\)的情况: 则有 \(b - a = 2^x , c - b = 2^y\)，因为题目要求任意两两相减都要是2的非负次幂。所以显然应该有\(c - a = 2^z = 2^x + 2^y\) ，而只有\(x = y\)的时候，这个情况才成立 (考虑一下2的非负次幂的二进制表达，如果\(x!=y\)，那么二进制表达应该是有两位，就不能被表示成一个2的非负次幂的情况了，而是两个2的非负次幂相加) 所以三个数的情况，一定是\([a - x , a , a + x]\) 其中x是某个2的次幂。 那么对于四个数字\(a,b,c,d\)的情况，\(d - c\)是2的非负次幂，\(c - a\)也是2的非负次幂，那么\(d-a\)显然会是两个不同的二的次幂相加得到(假如对于这种情况，是两个相同的二的次幂，那么同样的情况，换几个选择，肯定又会是不同的二的次幂相加的情况。所以不能成立)。 对于数字大于4的情况，因为他包含了是任意两两相减都要满足情况，肯定包含了$ n 4$的情况，所以大于4都不行。 有了这个结论以后，我们只要稍微改动一下，当得到3个数字的结果就退出，对于1和2的情况，都分别处理一下即可。 ACcode12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;bits/stdc++.h&gt;using namespace std ;int n ;int cnt_ans = 0 ;vector&lt;long long &gt; a ;vector&lt;long long &gt; ans ; int main()&#123; cin &gt;&gt; n ; for( int i = 1 ; i &lt;= n ; i++) &#123; int t ; cin &gt;&gt; t ; a.push_back(t); &#125; sort( a.begin() , a.end()) ; long long delta = 1ll ; for( int i = 0 ; i &lt; n ; i++) &#123; delta = 1ll ; while( delta &lt;= 2000000000ll) &#123; int t = 1 ; vector&lt;long long &gt; tt ; tt.push_back(a[i]); if( binary_search( a.begin() , a.end(), a[i] + delta ) ) &#123; t++; tt.push_back( a[i] + delta ) ; &#125; if( binary_search( a.begin() , a.end(), a[i] - delta ) ) &#123; t++; tt.push_back(a[i]-delta); &#125; delta *= 2ll ; if( t &gt; cnt_ans ) &#123; cnt_ans = t ; ans = tt ; &#125; if( cnt_ans == 3 ) &#123; cout &lt;&lt; cnt_ans &lt;&lt; endl ; for( auto i : ans ) cout &lt;&lt; i &lt;&lt; ' ' ; cout &lt;&lt; endl ; return 0 ; &#125; &#125; &#125; cout &lt;&lt; cnt_ans &lt;&lt; endl ; for( auto i : ans ) cout &lt;&lt; i &lt;&lt; ' ' ; cout &lt;&lt; endl ; return 0 ;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 486 Div.3 CF988C Equal Sums]]></title>
    <url>%2F5aa8be3b.html</url>
    <content type="text"><![CDATA[题意: 给出k个数列，要求选出任意两个数列i和j，使得第i个数列减去第n个数的和，等于第j个数列减去第m个数的和。求i、j、nn、m。 题目链接:http://codeforces.com/contest/988/problem/C 错误想法 统计所有数列的和(a[i].value表示第i个数列的和是多少)，枚举两个数列(i、j)，枚举第i个数列的每个数字n。那么我们就确定了四个所求数中的三个，对于第四个数m进行二分即可。 \[ a[i].value - n == a[j].value - m \] 123456for( 数列 i = 1 to k ) for( 数列 j = 1 to i ) for( 元素 n = 1 to a[i].size() ) 二分查找a[j]中是否存在m( m == a[j].value - a[i],value + n ) 找到了输出YES.输出NO 算法复杂度: \(O(k^3*logn)\) 一开始考虑到这个肯定过不了，不过无意间看到保证所有数据元素加起来不超过\(2e5\)个，不知道怎么脑子抽了就写了。 但是实际上显然不能过的，只要每个数列一个数字，直接将近\(4e10\)，TLE是肯定的。 写了以后疯狂Wrong Answer.... TLE我也就接受了。应该是正常的，然而疯狂WA是怎么一回事。 查了两三天的错，主要的问题是: - 二分没有排序！ (这问题,orz) - 排序后，某下标错了…… WRONGANSWER1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;bits/stdc++.h&gt;using namespace std ;const int maxn = 2e5 + 10 ; // 一种HACK手法，用于将CODEFROCES大数据不能看全的时候，远程输出一些数据。//#define DEBUGstruct node&#123; vector&lt; pair&lt; long long , int &gt; &gt; e ; long long value = 0 ; int n = 0 ; int pos = 0 ; &#125;a[maxn];int main()&#123; ios::sync_with_stdio(false); cin.tie(0); int k ; cin &gt;&gt; k;#ifdef DEBUG int debug_1 , debug_2 ;#endif for( int i = 1 ; i &lt;= k ; i++) &#123; cin &gt;&gt; a[i].n; a[i].pos = i ; for( int j = 1 ; j &lt;= a[i].n ; j++) &#123; long long t ; cin &gt;&gt; t ; a[i].e.push_back(make_pair( t , j )); a[i].value += t ;#ifdef DEBUG if( i == 99 &amp;&amp; j == 418 ) debug_1 = t ; if( i == 128 &amp;&amp; j == 226 ) debug_2 = t ; #endif &#125; &#125; sort( a + 1 , a + 1 + k , [](const node &amp;a , const node &amp;b ) &#123; return a.value &lt; b.value ; &#125; ) ; // 二分需要排序！ for( int i = 1 ; i &lt;= k ; i++) sort( a[i].e.begin() , a[i].e.end() ) ; for( int i = 2 ; i &lt;= k ; i++) &#123; for( int j = 1 ; j &lt; i ; j++) &#123; for( int kk = 0 ; kk &lt; a[i].e.size() ; kk++) &#123; // 这个pair类型，这样查找不确定是否合适 auto iter = lower_bound( a[j].e.begin() , a[j].e.end() , make_pair(a[j].value - a[i].value + a[i].e[kk].first,1) ) ; if( iter == a[j].e.end() ) continue; else if( a[i].value - a[i].e[kk].first == a[j].value - iter-&gt;first ) &#123; cout &lt;&lt; "YES" &lt;&lt; endl ; cout &lt;&lt; a[i].pos &lt;&lt; ' ' &lt;&lt; a[i].e[kk].second &lt;&lt; endl ; cout &lt;&lt; a[j].pos &lt;&lt; ' ' &lt;&lt; iter-&gt;second &lt;&lt; endl ;#ifdef DEBUG if( k == 400 ) &#123; cout &lt;&lt; a[i].value &lt;&lt; ' ' &lt;&lt; a[j].value &lt;&lt; endl ; cout &lt;&lt; a[i].e[kk].first &lt;&lt; ' ' &lt;&lt; a[i].e[kk].second &lt;&lt; endl; cout &lt;&lt; iter-&gt;first &lt;&lt; ' ' &lt;&lt; iter-&gt;second &lt;&lt; endl ; cout &lt;&lt; debug_1 &lt;&lt; ' ' &lt;&lt; debug_2 &lt;&lt; endl ; &#125;#endif return 0 ; &#125; &#125; &#125; &#125; cout &lt;&lt; "NO" &lt;&lt; endl ; return 0 ;&#125; 和空气斗智斗勇 感觉自己问题出在，想到了一个简单的不行的结论，就以为get到了这道题的trick，然后就非常兴奋的撞了上去越陷越深。 正确做法 123map&lt; 去掉一个数后的和 , pair&lt;第一次出现这个和的时候的数列，第一次出现这个和的时候的数列元素位置 &gt; &gt; 只要遍历每一个数字，当这个数字在map中没有出现过的时候，放入这样一个map中，当这个数字在map中出现了的时候，输出map中记录的第一次出现的位置和当前位置即可。 时间复杂度:\(O(k*logn)\) ACcode1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;using namespace std ;const int maxn = 2e5 + 10 ; map&lt; int , pair&lt;int , int &gt; &gt; mp ;struct node&#123; vector&lt;int &gt; e ; int value = 0 ; int n = 0 ; &#125;a[maxn];int main()&#123; int k; cin&gt;&gt; k ; for( int i = 1 ; i &lt;= k ; i++) &#123; cin &gt;&gt; a[i].n; for( int j = 1 ; j &lt;= a[i].n ; j++) &#123; int t; cin &gt;&gt; t ; a[i].e.push_back(t); a[i].value += t ; &#125; &#125; for( int i = 1 ; i &lt;= k ; i++) &#123; for( int j = 0 ; j &lt; a[i].e.size() ; j++) &#123; if( mp[ a[i].value - a[i].e[j] ].first == 0 ) &#123; mp[ a[i].value - a[i].e[j] ] = make_pair( i , j + 1 ) ; &#125; else if( mp[ a[i].value - a[i].e[j] ].first != i ) &#123; cout &lt;&lt; "YES" &lt;&lt; endl ; cout &lt;&lt; mp[a[i].value - a[i].e[j] ].first &lt;&lt; ' ' &lt;&lt; mp[a[i].value - a[i].e[j] ].second &lt;&lt; endl ; cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; j + 1 &lt;&lt; endl ; return 0 ; &#125; &#125; &#125; cout &lt;&lt; "NO" &lt;&lt; endl ; return 0 ;&#125; 总结 以后对于这种出现两次，要找一对的情况之类的，可以考虑先存一下第一次出现的时候的情况，然后第二次出现的时候直接输出。]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>codeforces</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces edu.44 985C Liebig's Barrels]]></title>
    <url>%2Ff70cdf0b.html</url>
    <content type="text"><![CDATA[题目链接: http://codeforces.com/contest/985/problem/C 题目大意：给出n,k,l。接下来给出n*k块木板。k块木板可以做成一个木桶，一共要做n个木桶。木桶体积为最短的木板长度。最大的木桶的体积和最小的木桶体积不能超过l。求所能做成的木桶最大的面积之和。不能做出n个木桶则输出0. 场上想法 赛场上觉得，排序后看最小值+l所在的位置是否大于等于n，是则输出前n个之和，否则输出0即可。 结果发现这样太蠢了。因为这样显然不会是最大的。后来赛场上又在想，是否是前面的都是尽可能相邻k个一拼，最后相邻k个且满足减去l小于等于a[1]的，找这样的尽可能大的加起来就可以。 这也是错的！ 补题想法 感觉能摸到一点边了，但是还是想了好久才明白。 先排序，我们要分三种情况讨论(记数字a[1] + l范围内的最大值的位置为pos，pos可用upper_bound得到) : 如果pos \(\le\)n ，显然不满足条件。(无论怎么选，都会使a[1]+l的限制条件被破坏) 如果pos \(\geq\)n , 并且pos - k \(\geq\) n - 1 ，即就是选取了相邻的k个数(这是最好的局部策略，因为以这k个数中最小的数字为代价，把其他k-1个数字都控制住了)，且剩下的数字依然满足最坏条件(即剩下的数字每个都属于剩下不同的木桶)。 如果pos \(\geq\)n，并且不满足\(pos-k \geq n-1\)，则剩下的每个数字都要组成不同的木桶。将他们加起来即可。 这就是做法。 今天对第三个条件想了很久，因为我一开始认为有可能出现: n=3 k=3 l=2 1 1 1 2 2 2 2 3 4 pos↑ 这种情况，我一开始以为会出现前面都匹配好了，剩下的pos指在这里导致会加上3而不是2(因为看同学代码有倒序查找，见参考资料)，后来发现这种情况不会发生，要不然就会全部都满足条件二。 这三种情况理解了，题目也就很好做了。 AC代码 code1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;using namespace std ;const int maxn = 1e5 + 10 ;int a[maxn];int main()&#123; int n ,k , l ; cin &gt;&gt; n &gt;&gt; k &gt;&gt; l ; for( int i = 1; i &lt;= n * k ; i++) cin &gt;&gt; a[i]; sort( a + 1 , a + 1 + n*k ) ; int pos = upper_bound( a + 1 , a + 1 + n * k , a[1] + l ) - a ; pos--; if( pos &lt; n ) // 错写成小于等于，要注意这里。 &#123; cout &lt;&lt; 0 &lt;&lt; endl ; return 0; &#125; long long ans = 0 ; int p = 1 ; for( int i = 1 ; i &lt;= n ; i++) &#123; ans += a[p]; p++; for( int j = 1 ; j &lt;= k - 1 ; j++) &#123; if( pos - p + 1 &gt; n - i ) // 错写成小于等于，要注意这里是没选的情况 p++; else break ; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl ; return 0 ; &#125; 参考资料 Educational Codeforces Round 44 Editorial By PikMike(官方题解) codeforces 985C Liebig's Barrels —— 上紫 同学代码 感觉自己贪心好弱，思维好僵硬啊qwq。]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>codeforces</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Edu.44 CF985A Chess Placing]]></title>
    <url>%2F9fede59d.html</url>
    <content type="text"><![CDATA[题目链接：http://codeforces.com/contest/985/problem/A 题目大意：给出一个\([1,n]\)的范围，给出\(n/2\)个数，每次可以对任意一个数进行加一减一操作(数字之间不能穿过)。要求把所有数都变成奇数或偶数且各不相同。 错误做法 一开始他说数字之间不能穿过，我以为和蚂蚁(POJ1852)很像，就是不用考虑数字之间穿过的情况。 于是直接模拟了一下，对于某个数标记一下是否这个位置被占用。然后先模拟把所有偶数变成奇数，再反过来模拟，取最小值。模拟思路就是对于第i个数，去寻找第一个满足条件的 a[i] + j 或 a[i] - j ,然后把数字填上去。 一开始我还考虑了，会不会出现我先考虑左边后考虑右边，如果左边满足条件就填进去，而不去考虑右边的话，情况不会最优？ 后来觉得排序可破。于是大胆写了，过了Pretest。 结果就被人hack了。 hack的数据是: 12105 6 7 8 9 这组数据会出现,7可能放到了10的位置，9又要往左走放到左边的位置这样的情况(9放到10才是最优的)。 想了想觉得或许加一些特判，或者从左往右再从右往左搞一搞可破。但是觉得这么写下去，越写越不像是个正解的样子。 遂作罢。 ErrorCode1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;bits/stdc++.h&gt;using namespace std ;const int maxn = 110; int a[maxn];int n ;int solve( int c[] , int flag )&#123; int a[maxn] ; for( int i = 1 ; i &lt;= n/2 ; i++) a[i] = c[i]; bool chess[maxn]; memset( chess, false , sizeof(chess) ) ; for( int i = 1 ; i &lt;= n/2 ; i++) chess[a[i]] = true ; int ans = 0 ; if( flag == 1 ) &#123; for(int i = 1 ; i &lt;= n/2 ; i++) &#123; if( a[i] % 2 == 0 ) &#123; for( int j = 1 ; j + a[i] &lt;= n || a[i] - j &gt;= 1 ; j++) &#123; if( ( (a[i] - j) % 2 == 1 || (a[i] + j) % 2 == 1 ) &amp;&amp; ( !chess[ a[i] - j ] || !chess[ a[i] + j ] ) ) &#123; if( a[i]-j &gt;= 1 &amp;&amp; (a[i] - j) % 2 == 1 &amp;&amp; !chess[ a[i] - j ] ) &#123; chess[a[i]] = false , chess[a[i]-j] = true,ans += j ; break; &#125; else if( a[i]+j &lt;= n &amp;&amp; (a[i] + j) % 2 == 1 &amp;&amp; !chess[a[i]+j] ) &#123; chess[a[i]] = false , chess[a[i]+j] = true,ans += j ; break; &#125; &#125; &#125; &#125; &#125; &#125; else if( flag == 2 ) &#123; for(int i = 1 ; i &lt;= n/2 ; i++) &#123; if( a[i] % 2 == 1 ) &#123; for( int j = 1 ; j + a[i] &lt;= n || a[i] - j &gt;= 1 ; j++) &#123; if( ( (a[i] - j) % 2 == 0 || (a[i] + j) % 2 == 0 ) &amp;&amp; ( !chess[ a[i] - j ] || !chess[ a[i] + j ] ) ) &#123; if( a[i] - j &gt;= 1 &amp;&amp; (a[i] - j) % 2 == 0 &amp;&amp; !chess[ a[i] - j ] ) &#123; chess[a[i]] = false , chess[a[i]-j] = true,ans += j ; break; &#125; else if( a[i] + j &lt;= n &amp;&amp; (a[i] + j) % 2 == 0 &amp;&amp; !chess[a[i]+j] ) &#123; chess[a[i]] = false , chess[a[i]+j] = true,ans += j ; break; &#125; &#125; &#125; &#125; &#125; &#125; return ans ;&#125;int main()&#123; cin &gt;&gt; n ; for( int i = 1 ; i &lt;= n/2 ; i++) cin &gt;&gt; a[i]; sort( a + 1 , a + 1 + n/2 ) ; int ans = min( solve( a , 1 ) , solve(a , 2 ) ); cout &lt;&lt; ans &lt;&lt; endl ; return 0 ; &#125; 正确做法 这道题其实被我想复杂了。考虑到n个位置，一共只给了n/2个数，那么也就是说，每个偶数位或者奇数位肯定是可以被放满的，不会出现要做选择，有些放满有些没有的情况。 所以我们只需要对于第i个数字，考虑他和第i个偶数(奇数)位之间的关系，然后加起来取最小值就可以了。 ACcode123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;using namespace std ;const int maxn = 110 ;int a[maxn];int main()&#123; int n ; cin &gt;&gt; n ; for( int i = 1 ; i &lt;= n / 2; i++) cin &gt;&gt; a[i] ; sort( a + 1 , a + 1 + n / 2 ) ; int ans = 0x3f3f3f3f ; int t = 0 ; int p = 1 ; for( int i = 1 ; i &lt;= n ; i += 2 ) &#123; t+= abs( a[p++] - i ); &#125; ans = min( t , ans ) ; p = 1 ; t = 0 ; for( int i = 2 ; i &lt;= n ; i += 2 ) &#123; t+= abs( a[p++] - i ); &#125; ans = min( t , ans ) ; cout &lt;&lt; ans &lt;&lt; endl ; return 0 ;&#125; 感觉自己真是越来越菜了，哎qwq.]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>水题</tag>
        <tag>codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO-Chapter3-Section3-1]]></title>
    <url>%2Fd339aa5c.html</url>
    <content type="text"><![CDATA[不知道是自己变强了还是题目没有那么繁琐了，感觉这一节比前面的反而简单。 1Agrinet code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768 /*ID:xiekeyi1PROG:agrinetLANG:C++11*/#include&lt;bits/stdc++.h&gt;using namespace std ;const int maxn = 110 ;int graph[maxn][maxn];int father[maxn];struct node&#123; int u , v , value ; node( int uu , int vv , int va ) &#123; u = uu , v = vv , value = va; &#125; ; &#125;;vector&lt; node &gt; a ; int find( int x )&#123; if( x == father[x] ) return x ; else return x = find(father[x]) ;&#125;void uni( int x , int y )&#123; int xx = find(x) ; int yy = find(y) ; if( xx != yy ) &#123; father[xx] = yy ; &#125; return ;&#125;int main()&#123; freopen("agrinet.in","r",stdin); freopen("agrinet.out","w",stdout); for( int i = 0 ; i &lt; maxn ; i++) father[i] = i ; int n ; cin &gt;&gt; n ; for( int i = 1 ; i &lt;= n ; i++) for( int j = 1 ; j &lt;= n ; j++) cin &gt;&gt; graph[i][j] ; for( int i = 1 ; i &lt;= n ; i++) for( int j = i + 1 ; j &lt;= n ; j++) a.push_back( node( i , j , graph[i][j] ) ) ; sort( a.begin() , a.end() , [](node a , node b )&#123; return a.value &lt; b.value ; &#125; ) ; int ans = 0; for( auto iter = a.begin() ; iter != a.end() ; ++iter) &#123; if( find( iter-&gt;u ) != find( iter-&gt;v ) ) &#123; uni( iter-&gt;u , iter-&gt;v ) ; ans += iter-&gt;value ; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl ; return 0 ;&#125; 2inflate code1234567891011121314151617181920212223242526272829303132333435363738 /*ID:xiekeyi1PROG:inflateLANG:C++11*/#include&lt;bits/stdc++.h&gt;using namespace std ;const int maxn = 10010 ;int dp[maxn];struct node&#123; int value ; int time ;&#125;a[maxn];int main()&#123; freopen("inflate.in","r",stdin); freopen("inflate.out","w",stdout); int n , m ; cin &gt;&gt; n &gt;&gt; m ; for( int i = 1 ; i &lt;= m ; i++) cin &gt;&gt; a[i].value &gt;&gt; a[i].time ; for( int i = 1 ; i &lt;= m ; i++) &#123; for( int j = a[i].time ; j &lt;= n ; j++) &#123; dp[j] = max( dp[j] , dp[j-a[i].time] + a[i].value ) ; &#125; &#125; cout &lt;&lt; dp[n] &lt;&lt; endl ; return 0 ;&#125; 3humble 丑数进阶版，之前uva做过，用优先队列就搞定了。 这个貌似只能dp，趁机学了下。 code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 /*ID:xiekeyi1PROG:humbleLANG:C++11*/#include&lt;bits/stdc++.h&gt;using namespace std ;const int maxn = 110;int s[maxn];int indexs[maxn];long long humble_number[100000 + 10];int main()&#123; freopen("humble.in","r",stdin); freopen("humble.out","w",stdout); int n,m; cin &gt;&gt; n &gt;&gt; m ; for( int i = 1 ; i &lt;= n ; i++) &#123; cin &gt;&gt; s[i]; &#125; for( int i = 1 ; i &lt;= n ; i++) indexs[i] = 1 ; int cnt = 1 ; humble_number[1] = 1 ; while( cnt &lt;= m + 2 ) &#123; long long t = 0x7fffffffff; for( int i = 1 ; i&lt;= n ; i++) &#123; t = min( t , humble_number[ indexs[i] ] * s[i] ) ; &#125; for( int i = 1 ; i &lt;= n ; i++) &#123; if( t == humble_number[ indexs[i] ] * s[i] ) &#123; indexs[i]++; &#125; &#125; humble_number[++cnt] = t ; &#125; cout &lt;&lt; humble_number[m+1] &lt;&lt; endl ; return 0 ;&#125; 4contact code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110 /*ID:xiekeyi1PROG:contactLANG:C++11*/#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100100; map&lt;string,int&gt; mp ;string s ; struct node&#123; string s ; int num ;&#125;ans[maxn];bool operator&lt; (const string &amp;a , const string &amp;b )&#123; if( a.size() &lt; b.size() ) return true ; else if( a.size() == b.size() ) return ( strcmp( a.c_str() , b.c_str()) &lt; 0 ? true : false ) ; return false ; &#125;bool cmp( const node &amp;a , const node &amp;b )&#123; if( a.num &gt; b.num ) return true ; else if( a.num == b.num ) &#123; return a.s &lt; b.s ; &#125; else return false ;&#125;int main()&#123; freopen("contact.in","r" , stdin); freopen("contact.out","w" , stdout); int a ,b , n ; cin &gt;&gt; a &gt;&gt; b &gt;&gt; n ; string t ; while( getline( cin , t) ) s += t ; for( int i = a ; i &lt;= b ; i++) &#123; for( int j = 0 ; j + i &lt;= s. size() ; j++) &#123; mp[s.substr(j,i)] += 1 ; &#125; &#125; int p = 1 ; for( auto i = mp.begin() ; i != mp.end() ; ++i) &#123; ans[p].s = i-&gt;first , ans[p].num = i -&gt; second ; p++; &#125; p--; sort( ans + 1 , ans + 1 + p , cmp ) ; int cntt = 0 ; bool flag = false ; for( int i = 1 ; i &lt;= p ; i++) &#123; if( cntt == n ) break ; cout &lt;&lt; ans[i].num &lt;&lt; endl ; cntt++; int cnt = 0 ; flag = false ; for( int j = i ; j &lt;= p ; j++) &#123; if( ans[j].num == ans[i].num ) &#123; if( cnt == 0 ) &#123; cout &lt;&lt; ans[j].s ; cnt++; &#125; else &#123; cout &lt;&lt; ' ' &lt;&lt; ans[j].s ; cnt++; &#125; if( cnt % 6 == 0 ) &#123; cnt = 0 ; cout &lt;&lt; endl ; &#125; &#125; else &#123; i = j - 1 ; if( cnt % 6 != 0 ) cout &lt;&lt; endl ; flag = true ; break ; &#125; &#125; &#125; if( !flag ) cout &lt;&lt; endl ; return 0 ;&#125; 5stamps 一开始想着用set，然后枚举set里的元素加上coin，最后遍历set求连续的数最大值就可以了。 结果MLE一发TLE一发。 然后想了想改了dp。 顺便发现，map和数组访问差距还是有点大的。一开始我以为多一个log，顶多是常数差距，问题不大。结果没想到:map 1.7s TLE,数组0.05s AC code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263 /*ID:xiekeyi1PROG:stampsLANG:C++11*/#include&lt;bits/stdc++.h&gt;using namespace std ;int coin[55];int dp[2000010];int main()&#123; freopen("stamps.in","r",stdin); freopen("stamps.out","w",stdout); int k , n ; cin &gt;&gt; k &gt;&gt; n ; int maxn = 0 ; for( int i = 1 ; i &lt;= n ; i++) &#123; cin &gt;&gt; coin[i] ; maxn = max( coin[i] , maxn ) ; dp[ coin[i] ] = 1 ; &#125; maxn = maxn * k + 100; for( int i = 1 ; i &lt;= maxn; i++) &#123; for( int j = 1 ; j &lt;= n ; j++) &#123; if( i - coin[j] &gt; 0 &amp;&amp; dp[ i - coin[j] ] != 0 &amp;&amp; dp[i-coin[j]] + 1 &lt;= k ) &#123; if( dp[i] == 0 ) dp[i] = dp[ i - coin[j]] + 1 ; else dp[i] = min( dp[i] , dp[i-coin[j]] + 1 ) ; &#125; &#125; &#125; int ans = 0 ; for( int i = 1 ; i &lt;= maxn; i++) &#123; if( dp[i] != 0 ) &#123; for( int j = i + 1 ; j &lt;= maxn; j++ ) &#123; if( dp[j] != 0 &amp;&amp; dp[j-1] != 0 ) continue ; else &#123; ans = max( ans , j - i ); i = j - 1 ; break ; &#125; &#125; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl ; return 0 ; &#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>USACO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串哈希——解决KMP等问题]]></title>
    <url>%2Fd9000e89.html</url>
    <content type="text"><![CDATA[字符串哈希邪教(不保证正确性)，解决一些奇怪的字符串哈希问题 字符串哈希 一开始以为这个是一个比较难的东西，最近学了下，发现是个挺傻屌的东西的。很好理解。 所谓\(hash\)，就是希望有这么一个函数value hash( const string &amp;s ) 对于给定的每一个字符串，都能返回给我一个值。我们利用这个值，可以把长度为\(n\)的串，本来需要\(O(n)\)的去比较一次，现在用这个值可以只进行一次比较得出结果。 其实我们可以把这个映射，看成是\(BASE\)进制下的一种操作。对于一个字符串长度为\(n\)的话，我们就要用\(n\)位\(BASE\)进制去表示这个值。这个很好表示： \[ BASE^{n} * s[n] + BASE^{n-1} * s[n-1] + ... + BASE^{1} * s[1] \] 注意，字符串哈希尽可能避免其中有\(0\)的出现，如果将\(a\)映射为\(0\)，那么\(ab\)和\(b\)可能会出现一样的结果 我们很难有那么多位去表示一个串，如果高精度的话，那么和直接去比较也没什么区别了。所以我们可以取模一个数，看成是\(mod\ P\)意义下的映射表示。 具体的\(hash\)函数: 1234567ull hashh( char s2[] , int n )&#123; ull ans = 0 ; for( int i = 1 ; i &lt;= n ; i++) ans = ans * BASE + s2[i] ; return ans ;&#125; 这样，我们就可以给出一个字符串进去，然后出来一个\(hash\)值了。 如果是需要涉及子串的问题，我们可以这样： 1234567void hashh( ull ans[] , char s1[] , int n )&#123; for( int i = 1 ; i &lt;= n ; i++) &#123; ans[i] = ans[i-1] * BASE + s1[i] ; &#125;&#125; 维护一个像前缀和一样的东西就就可以了。 这里是需要取余的，我这里没有，是利用了unsigned类型的数字，溢出会自动取余的性质和unsigned long long 刚好是一个素数的性质 如果不用素数取余，错误概率将大大提高。为了减少冲突概率，还可以使用双取余等各种其他方法（详情见参考资料）。如果自己手写处理\(hash\)冲突，那么其实这种做法就没有什么优点了。 对于这个，子串如何去使用呢？ 一开始我以为，我只需要简单的对于截取子串\(l...r\)的哈希值，使用ans[r] - ans[l] 就可以了。结果实际使用中发现崩了。 想了想才明白，我们应该将他看成是\(r\)位和\(l\)位的\(BASE\)进制下的数，我现在想截取前\(l\)位（想一下，每一位对应于第几位)。 所以，我们需要进行一个简单的变形: \[ ans[r] - ans[l] * BASE^{r-l+1} \] 我当时这里卡了一下。可以类比于我有\(12345\)和\(123\)， 需要把\(45\)提出，是不是需要乘上一些进制，把\(123\)变成\(12300\)？ 我一开始以为\(hash\)出来的值，最高位存的是\(s[n]\)，后来想了下构建过程，构建是从\(1...n\)，然后又不断的乘\(BASE\)，其实是把最低位给送到了\(hash\)出来的值的最高位。 遇到的问题： - 如何证明\(hash\)冲突的概率是多大？ 相关题目 HDU 1686 题意： 给出串\(T\)和串\(S\)，询问串\(T\)在串\(S\)中出现了几次(允许有重叠部分，具体参考样例) code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;using namespace std ;typedef unsigned long long ull;const int maxn = 1000000 + 10 ; const ull BASE = 1e9 + 7 ;char s1[maxn] , s2[maxn];ull hashs1[maxn];void hashh( ull ans[] , char s1[] , int n )&#123; for( int i = 1 ; i &lt;= n ; i++) &#123; ans[i] = ans[i-1] * BASE + s1[i] ; &#125;&#125;ull hashh( char s2[] , int n )&#123; ull ans = 0 ; for( int i = 1 ; i &lt;= n ; i++) ans = ans * BASE + s2[i] ; return ans ;&#125;int main()&#123; int t ; scanf("%d",&amp;t); while(t--) &#123; scanf("%s",s2+1); scanf("%s",s1+1); int s1_size = strlen(s1+1) , s2_size = strlen(s2+1) ; hashh( hashs1 , s1 , s1_size) ; ull hashs2 = hashh( s2 , s2_size ) ; ull coefficient = 1 ; for( int i = 1 ; i &lt;= s2_size ; i++) coefficient *= BASE ; int ans = 0 ; for( int i = 1 ; i + s2_size - 1 &lt;= s1_size &amp;&amp; i &lt;= s1_size ; i++) &#123; ull t1 = hashs1[i + s2_size - 1 ]; ull t2 = hashs1[i-1]; t2 *= coefficient; if( t1 - t2 == hashs2 ) ans++; &#125; printf("%d\n",ans); &#125; return 0 ; &#125; HDU 1711 题意：给出数列\(S\)和数列\(T\)，求\(T\)在数列\(S\)中第一次出现的位置。 code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include&lt;bits/stdc++.h&gt;using namespace std ;const int maxn = 1000000 + 10 ;typedef unsigned long long ull ; ull a[maxn] , b[maxn] ; ull hashs1[maxn] ;const ull BASE = 1e9 + 7 ;void hashh( ull ans[] , ull a[] , int n )&#123; for( int i = 1 ; i &lt;= n ; i++) &#123; ans[i] = ans[i-1] * BASE + a[i]; &#125;&#125;ull hashh( ull a[] , int n )&#123; ull ans = 0 ; for( int i = 1 ; i &lt;= n ; i++) &#123; ans = ans * BASE + a[i]; &#125; return ans ;&#125;int main()&#123; int t ; scanf("%d",&amp;t); while(t--) &#123; memset( a , 0 , sizeof(a) ) ; memset( b , 0 , sizeof(b) ) ; memset( hashs1 , 0 , sizeof( hashs1 ) ) ; int n , m ; scanf("%d%d",&amp;n , &amp;m ); for( int i = 1 ; i &lt;= n ; i++) &#123; int t ; scanf("%d",&amp;t); a[i] = t + maxn ; &#125; for( int i = 1 ; i &lt;= m ; i++) &#123; int t ; scanf("%d",&amp;t); b[i] = t + maxn ; &#125; hashh( hashs1 , a , n ) ; ull s2 = hashh( b , m ) ; int ans = -1 ; ull t = 1 ; for( int i = 1 ; i &lt;= m ; i++) t *= BASE ; for( int i = 1 ; i + m - 1 &lt;= n &amp;&amp; i &lt;= n ; i++) &#123; ull h1 = hashs1[ i + m - 1 ] ; ull h2 = hashs1[i-1]; h2 *= t ; if( h1 - h2 == s2 ) &#123; ans = i ; break ; &#125; &#125; printf("%d\n",ans); &#125; return 0 ; &#125; HDU 2097 题意： 给出串\(s\)和串\(t\)，求串\(t\)在串\(s\)中出现了几次（无重叠） code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;bits/stdc++.h&gt;using namespace std ;typedef unsigned long long ull ; const int maxn = 1010 ;char s1[maxn],s2[maxn];ull hashs1[maxn];const int BASE = 1e9 + 7 ;const ull mod = 19260817 ; void hashh( ull ans[] , char s[] , int n )&#123; for( int i = 1 ; i &lt;= n ; i++) ans[i] = ( ans[i-1] * BASE + s[i] ) % mod ;&#125;ull hashh( char s[] , int n )&#123; ull ans = 0 ; for( int i = 1 ; i &lt;= n ; i++) ans = ( ans * BASE + s[i] ) % mod ; return ans % mod ; &#125;int main()&#123; while( scanf("%s" , s1 + 1 ) != EOF ) &#123; if( s1[1] == '#' ) break ; scanf("%s" , s2 + 1 ) ; int s1_size = strlen(s1+1) , s2_size = strlen(s2+1) ; hashh( hashs1 , s1 , s1_size ) ; ull hashs2 = hashh( s2 , s2_size ) ; ull coeffcient = 1 ; for( int i = 1 ; i &lt;= s2_size ; i++) coeffcient *= BASE ; coeffcient %= mod ; int ans = 0 ; for( int i = 1 ; i + s2_size - 1 &lt;= s1_size &amp;&amp; i &lt;= s1_size ; i++) &#123; ull h1 = hashs1[ i + s2_size - 1 ] ; ull h2 = hashs1[ i - 1 ]; h2 *= coeffcient ; h1 %= mod , h2 %= mod ; if( h1 - h2 == hashs2 ) &#123; ans++; i = i + s2_size - 1 ; continue ; &#125; &#125; printf("%d\n",ans); &#125; return 0 ;&#125; HDU 5510 题意：找出一个串，这个串前面的至少\(1\)个串不是该串的子串，且该串给出的顺序最靠后，求该串是第几个给出的串？ 这道题时间复杂度挺高的，我第一眼以为是\(AC\)自动机。但是加上剪枝的话，时间复杂度上界没变，下界小很多，想卡这种做法似乎很难(听说剪枝后暴力都可过)。 这是\(ACM-ICPC 2015\)沈阳的题，我在想现场赛遇到这种题，敢不敢写，该怎么写啊？ code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include&lt;bits/stdc++.h&gt;typedef unsigned long long ull ;const int maxn = 2020 ;const ull BASE = 1e9 + 7 ;char s[550][maxn];bool vis[maxn];ull hashall[550];ull hashevery[550][maxn];ull coe[550];int len[550];ull hashh( char s[] , int n )&#123; ull ans = 0 ; for( int i = 1 ; i &lt;= n ; i++) ans = ans * BASE + s[i] ; return ans ;&#125;int main()&#123; int t ; scanf("%d",&amp;t); int KASE = 0 ; while( t-- ) &#123; memset(vis, false ,sizeof(vis)); memset( len , 0 , sizeof(len) ) ; int n ; scanf("%d",&amp;n); for( int i = 1 ; i &lt;= n ; i++) coe[i] = 1 ; for( int i = 1 ; i &lt;= n ; i++) &#123; scanf("%s", &amp;s[i][1] ); len[i] = strlen( &amp;s[i][1] ) ; for( int j = 1 ; j &lt;= len[i] ; j++) coe[i] *= BASE ; &#125; for( int i = 1 ; i &lt;= n ; i++) hashall[i] = hashh( s[i], len[i] ) ; for( int i = 1 ; i &lt;= n ; i++) &#123; for( int j = 1 ; j &lt;= len[i] ; j++) hashevery[i][j] = hashevery[i][j-1] * BASE + s[i][j] ; &#125; int ans = -1 ; for( int i = 2 ; i &lt;= n ; i++) &#123; for( int j = 1 ; j &lt; i ; j++) &#123; if( !vis[j] ) &#123; bool succ = false ; for( int k = 1 ; k + len[j] - 1 &lt;= len[i] ; k++) &#123; ull h1 = hashevery[i][k+len[j]-1]; ull h2 = hashevery[i][k-1]; h2 *= coe[j] ; if( h1 - h2 == hashall[j] ) &#123; succ = true ; vis[j] = true ; break ; &#125; &#125; if( !succ ) ans = i ; &#125; &#125; &#125; printf("Case #%d: %d\n", ++KASE, ans ) ; &#125; return 0 ;&#125; 参考资料 字符串Hash总结 cdoj1092-韩爷的梦 （字符串hash）【hash】 OI 字符串 常用哈希方法]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>hash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XDU2018校赛-Xieldy And His Password]]></title>
    <url>%2Ff2b85b98.html</url>
    <content type="text"><![CDATA[简单DP. 题意：一个长度小于\(1e6\)的01字符串，求所有子串有能在十进制下被三整除的的方案数。（允许有前导零，不同子段视为不同） 题目链接：Xieldy And His Password 比赛的时候，感觉是\(dp\)，曾列过一个方程。当时现场赛上的思路是，考虑设\(dp[i][0/1]\)表示对于当前以\(s[i]\)为结尾的字符串是否能被\(3\)整除。然后又以为被\(3\)整除的数可能会有一些性质（如我知道十进制下能被三整除的数充要条件是各个位数之和能被三整除）。推了一下性质，发现情况很多，而且就算推出来了以后，会发现对于长度为\(1\)到\(i\)之间的串不好处理。 赛后和同学交流，告诉我是模\(3\)意义下的\(dp\)，当时听到这个名词还觉得挺难的。回来看了题解，发现其实是很简单的一个东西→_→。 我们设dp[i][j] ( 0 &lt;= j &lt;= 2 )表示以s[i]为结尾的，所有被\(3\)除余\(j\)的方案数。 那么，分情况讨论： 1. 对于s[i] == 0的情况，可以看做是长度为\(i-1\)的串乘\(2\)得到： - dp[i][0] = dp[i-1][0] + 1 ( 考虑单独一个0的情况 , $3k * 2 ≡ 0 ( mod 3 ) $ ) - dp[i][1] = dp[i-1][2] ( $ ( 3k + 2 ) * 2 ≡ 1 ( mod 3 ) $ ) - dp[i][2] = dp[i-1][1] ( $ ( 3k + 1 ) * 2 ≡ 2 ( mod 3 ) $ ) 2. 对于s[i] == 1的情况，可以看做是长度为\(i-1\)的串乘\(2\)再加\(1\)得到: - dp[i][0] = dp[i-1][1] ( $ ( 3k + 1 ) * 2 + 1 ≡ 0 ( mod 3 ) $ ) - dp[i][1] = dp[i-1][0] + 1( 考虑单独一个1的情况， $ 3k * 2 + 1 ≡ 1 ( mod 3 ) $ ) - dp[i][2] = dp[i-1][1] ( $ ( 3k + 2 ) * 2 + 1 ≡ 0 ( mod 3 ) $ ) 那么，很容易的写出\(dp\)方程。 最终会答案为\(\sum_{1}^{n}dp[i][0]\) 代码如下: code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;using namespace std ;typedef long long ll ;const int maxn = 1e6 + 10 ;ll dp[maxn][3];string s ;int main()&#123; while(cin &gt;&gt; s ) &#123; memset( dp , 0 , sizeof(dp) ) ; // if( s[0] == '0' ) // &#123; // dp[0][0] = 1 ; // &#125; // if( s[0] == '1' ) // &#123; // dp[0][1] = 0 ; // &#125; s.insert( s.begin() , '#' ); for( int i = 1 ; i &lt; s.size() ; i++) &#123; if( s[i] == '0' ) &#123; dp[i][0] = dp[i-1][0] + 1 ; dp[i][1] = dp[i-1][2] ; dp[i][2] = dp[i-1][1] ; &#125; else if( s[i] == '1' ) &#123; dp[i][0] = dp[i-1][1] ; dp[i][1] = dp[i-1][0] + 1 ; dp[i][2] = dp[i-1][2] ; &#125; &#125; ll ans = 0 ; for( int i = 1 ; i &lt; s.size() ; i++) &#123; ans += dp[i][0]; &#125; cout &lt;&lt; ans &lt;&lt; endl ; &#125; return 0 ;&#125; 遇到的问题： - 注意开$long long $ 。一开始以为不会有那么多的情况，后来想了下，如果全是\(0\)的时候，答案最大，是\(\sum_{i=1}^{1e6}i\)]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO-Chapter2-Section2.4]]></title>
    <url>%2F12192b48.html</url>
    <content type="text"><![CDATA[USACO-Chapter2-Section2.4 Shortest Path 感觉虽然题目说是最短路，实际上很多不能算最短路吧。题目也不难，最难也就是裸的dijkstra。不过自己搜索从一开始的很丑陋很暴力的，越写越优雅了倒是真的。 2.4.1 ttwo code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118/*ID:xiekeyi1PROG:ttwoLANG:C++11 */#include&lt;bits/stdc++.h&gt;using namespace std ;const int maxn =15 ;char graph[maxn][maxn];pair&lt; pair&lt; int , int &gt; , int &gt; cow , farm;int ans = 0 ; bool succ = true ; bool judge()&#123; if( cow.first == farm.first ) &#123; succ = true ; return false ; &#125; else if( ans &gt;= 10000 ) &#123; succ = false ; return false ; &#125; return true ;&#125;void rolate( pair&lt; pair&lt;int,int&gt; , int &gt; &amp;a ) &#123; a.second = ( a.second + 1 ) % 4 ; return ; &#125;void go_away( pair&lt; pair&lt; int , int &gt; , int &gt; &amp;a )&#123; if( a.second == 0 ) &#123; if( graph[ a.first.first-1][a.first.second] != '*' &amp;&amp; a.first.first-1 &gt;= 1 ) a.first.first -= 1 ; else rolate(a); &#125; else if( a.second == 1 ) &#123; if( graph[ a.first.first][a.first.second+1] != '*' &amp;&amp; a.first.second+1 &lt;= 10 ) a.first.second+= 1 ; else rolate(a); &#125; else if( a.second == 2 ) &#123; if( graph[ a.first.first+1][a.first.second] != '*' &amp;&amp; a.first.first + 1 &lt;= 10 ) a.first.first+= 1 ; else rolate(a); &#125; else if( a. second == 3 ) &#123; if( graph[ a.first.first][a.first.second-1] != '*' &amp;&amp; a.first.second -1 &gt;= 1 ) a.first.second -= 1 ; else rolate(a); &#125; return ;&#125;void func() &#123; go_away(cow); go_away(farm); ans++; return ; &#125;int main()&#123; freopen("ttwo.in","r",stdin); freopen("ttwo.out","w",stdout); for( int i = 1 ; i &lt;= 10 ; i++) scanf("%s",graph[i]+1); for( int i = 1 ; i &lt;= 10 ; i++) &#123; for( int j = 1 ; j &lt;= 10 ; j++) &#123; if( graph[i][j] == 'F' ) farm.first.first = i , farm.first.second = j , farm.second = 0 ; if( graph[i][j] == 'C' ) cow.first.first = i , cow.first.second = j , cow.second = 0 ; &#125; &#125; while( judge() ) &#123; func(); &#125; if( succ ) cout &lt;&lt; ans &lt;&lt; endl ; else cout &lt;&lt; 0 &lt;&lt; endl ; return 0 ; &#125; 2.4.2 overfencing code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173/*ID:xiekeyi1PROG:maze1LANG:C++11 */ #include&lt;bits/stdc++.h&gt;using namespace std ;const int maxn = 210 ; const int dx[] = &#123; 0 , 1 , -1 , 0 &#125;;const int dy[] = &#123; 1 , 0 , 0 , -1 &#125;;char graph[maxn][maxn];int W , H ; int dis[maxn][maxn];int dis2[maxn][maxn];bool isAns( pair&lt; int , int &gt; pp )&#123; if( pp.first == 1 || pp.first == 2 * H + 1 || pp.second == 1 || pp.second == 2 * W + 1 ) &#123; if( graph[pp.first][pp.second] == ' ' ) return true ; &#125; return false ; &#125;bool isLegal( int x , int y )&#123; if( x &gt;= 1 &amp;&amp; x &lt;= 2 * H + 1 &amp;&amp; y &gt;= 1 &amp;&amp; y &lt;= 2 * W + 1 ) &#123; if( graph[x][y] == ' ' &amp;&amp; dis[x][y] == 0 ) return true ; &#125; return false ;&#125;void BFS( int x , int y )&#123; queue&lt; pair&lt;int , int &gt; &gt; q ; q.push( make_pair( x , y ) ) ; while( !q.empty() ) &#123; pair&lt;int , int &gt; top ; top = q.front() ; q.pop() ; // if( isAns( top ) ) // return dis[top.first][top.second] + 1 ; for( int i = 0 ; i &lt; 4 ; i++) &#123; if( isLegal( top.first + dx[i] , top.second + dy[i] ) ) &#123; q.push( make_pair( top.first + dx[i] , top.second + dy[i] ) ) ; dis[top.first + dx[i] ][ top.second + dy[i] ] = dis[top.first][top.second] + 1 ; &#125; &#125; &#125;; return ; &#125;int main()&#123; freopen("maze1.in","r",stdin); freopen("maze1.out","w",stdout); scanf("%d%d",&amp;W,&amp;H);/* //getchar() ;getchar() ; fflush(stdin); for( int i = 1 ; i &lt;= 2 * H + 1 ; i ++) &#123; scanf("%[^\n]" , graph[i] + 1 ) ; fflush(stdin); &#125;*/ string t ; for( int i = 1 ; i &lt;= 2 * H + 1 ; i++) &#123; do getline(cin,t); while( t.size() &lt;= 0 ) ; for( int j = 0 ; j &lt; 2 * W + 1 ; j++) &#123; graph[i][j+1] = t[j] ; &#125; &#125; int startx = 0 , starty = 0 ; for( int i = 1 ; i &lt;= 2 * H + 1 ; i++) &#123; for( int j = 1 ; j &lt;= 2 * W + 1 ; j++) &#123; if( isAns( make_pair( i , j ) ) ) &#123; startx = i , starty = j ; dis[startx][starty] = 1 ; break ; &#125; &#125; if( startx != 0 &amp;&amp; starty != 0 ) break ; &#125; int ans = 0; for( int i = 1 ; i &lt;= 2 * H + 1 ; i++) &#123; for( int j = 1 ; j &lt;= 2 * W + 1 ; j++) &#123; BFS( startx , starty ) ; &#125; &#125; // for( int i = 1 ; i &lt;= 2 * H + 1 ; i++ ) // &#123; // for( int j = 1 ; j &lt;= 2 * W + 1 ; j++) // &#123; // ans = max( ans , dis[i][j] ) ; // &#125; // &#125; for( int i = 1 ; i &lt;= 2 * H + 1 ; i++) &#123; for( int j = 1 ; j &lt;= 2 * W + 1 ; j++) &#123; dis2[i][j] = dis[i][j] ; &#125; &#125; memset( dis, 0 , sizeof( dis) ) ; int startx2 = 0 ,starty2 = 0 ; for( int i = 1 ; i &lt;= 2 * H + 1 ; i++) &#123; for( int j = 1 ; j &lt;= 2 * W + 1 ; j++) &#123; if( ( i != startx || j != starty ) &amp;&amp; isAns( make_pair( i , j ) ) ) &#123; startx2 = i , starty2 = j ; dis[startx2][starty2] = 1 ; break ; &#125; &#125; if( startx2 != 0 &amp;&amp; starty2 != 0 ) break ; &#125; for( int i = 1 ; i &lt;= 2 * H + 1 ; i++) &#123; for( int j = 1 ; j &lt;= 2 * W + 1 ; j++) &#123; BFS( startx2 , starty2 ) ; &#125; &#125;/* printf(" startx : %d , starty : %d , startx2 : %d , starty2 : %d \n " , startx , starty , startx2 , starty2 ) ; printf(" graph[%d][%d] = %c \n " , startx , starty , graph[startx][starty] ) ;*/ for( int i = 1 ; i &lt;= 2 * H + 1 ; i++ ) &#123; for( int j = 1 ; j &lt;= 2 * W + 1 ; j++) &#123; // printf(" dis[%d][%d] = %d , dis2[%d][%d] = %d , ans = %d \n" ,i,j, dis[i][j] ,i,j, dis2[i][j], ans); ans = max( ans , min( dis[i][j],dis2[i][j] ) ) ; &#125; &#125; printf("%d\n",ans/2); return 0 ;&#125; 2.4.3 cowtour code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103/*ID:xiekeyi1PROG:cowtourLANG:C++11 */#include&lt;bits/stdc++.h&gt;using namespace std ;const int maxn = 150 ;int graph[maxn][maxn];double minpath[maxn][maxn];double maxdis[maxn];pair&lt; int , int &gt; coo[maxn] ;double calcdis( pair&lt;int , int &gt; &amp;a , pair&lt; int , int &gt; &amp;b ) &#123; return sqrt( ( a.first - b.first + 0.0 ) * ( a.first - b.first) + (a.second - b.second ) * ( a.second - b.second) ) ;&#125;int main()&#123; freopen("cowtour.in","r",stdin); freopen("cowtour.out","w",stdout); int n ; cin &gt;&gt; n ; for( int i = 1 ; i &lt;= n ; i++) &#123; int x , y ; cin &gt;&gt; x &gt;&gt; y ; coo[i] = make_pair( x , y ) ; &#125; for( int i = 1 ; i &lt;= n ; i++) &#123; string s ; cin &gt;&gt; s ; for( int j = 1 ; j &lt;= n ; j++) &#123; graph[i][j] = s[j-1] - '0' ; &#125; &#125; for( int i = 1 ; i &lt;= n ; i++) &#123; for( int j = 1 ; j &lt;= n ; j++) &#123; if( graph[i][j] == 1 ) &#123; minpath[i][j] = calcdis( coo[i] , coo[j] ) ; &#125; else &#123; minpath[i][j] = 1e10 ; &#125; &#125; &#125; for( int k = 1 ; k &lt;= n ; k++) &#123; for( int i = 1 ; i &lt;= n ; i++) &#123; for( int j = 1 ; j &lt;= n ; j++) &#123; if( i != j ) minpath[i][j] = min( minpath[i][j] , minpath[i][k] + minpath[k][j] ); &#125; &#125; &#125; for( int i = 1 ; i &lt;= n ; i++ ) &#123; for( int j = 1 ; j &lt;= n ; j++) &#123; if( i != j &amp;&amp; minpath[i][j] &lt; 1e9 ) maxdis[i] = max( maxdis[i] , minpath[i][j] ) ; &#125; &#125; double r1 = 0 , r2 = 1e10; for( int i = 1 ; i &lt;= n ; i++) &#123; r1 = max( r1 , maxdis[i] ); for( int j = 1 ; j &lt;= n ; j++) &#123; if( i != j &amp;&amp; minpath[i][j] &gt; 1e8 ) r2 = min( r2 , maxdis[i] + maxdis[j] + calcdis( coo[i] , coo[j] ) ) ; &#125; &#125; double ans ; if( r2 &lt; 1e8 ) ans = max( r1 , r2 ) ; else &#123; ans = r1 ; &#125; printf("%.6f\n",ans); return 0 ;&#125; 2.4.4 comehome 这道题一开始我想的是反向BFS的，后来发现这个图，直接BFS不一定最先出来的是最短边，可能还是要遍历整张图。于是用了dijkstra。 dijkstra用裸的，什么优化都没有的就可以跑。一开始我还在觉得用字母好难处理，后来发现用字母太妙了。 一开始看到一万条边，把我吓得不行，后来想了想，用字母表示点，最多也就五十多个点，等于有很多重边和自环，easy~ dijkstra反向跑一下就行了，难点在hash一下字母和数字对应关系。 有的人是dijkstra松弛到大写字母最短边就return了，因为我不太会这种写法，所以我跑完了全部的dijkstra然后再去找。 code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101/*ID:xiekeyi1PROG:comehomeLANG:C++11*/#include&lt;bits/stdc++.h&gt;#include&lt;unordered_map&gt;using namespace std ;const int MAXN = 55 ;int graph[MAXN][MAXN];int n ;inline int index( char ch )&#123; if( ch &gt;= 'a' &amp;&amp; ch &lt;= 'z' ) &#123; return ch - 'a' ; &#125; else if( ch &gt;= 'A' &amp;&amp; ch &lt;= 'Z' ) &#123; return ch - 'A' + 26 ; &#125;&#125;void dijkstra( pair&lt; char , int &gt; &amp;ans )&#123; bool vis[MAXN]; memset( vis , false ,sizeof( vis ) ) ; int dis[MAXN]; for( int i = 0 ; i &lt; MAXN ; i++) dis[i] = 0x3f3f3f3f ; dis[ index( 'Z' ) ] = 0 ; for( int i = 0 ; i &lt; MAXN ; i++) &#123; // find the nearest point . int node = -1 , len = 0x3f3f3f3f ; for( int j = 0 ; j &lt; MAXN ; j++) &#123; if( !vis[j] &amp;&amp; dis[j] &lt; len ) node = j , len = dis[j] ; &#125; if( node != -1 ) &#123; vis[node] = true ; for( int j = 0 ; j &lt; MAXN ; j++) &#123; if( !vis[j] &amp;&amp; dis[node] + graph[node][j] &lt; dis[j] ) dis[j] = dis[node] + graph[node][j] ; &#125; &#125; &#125; int t1 = 0 , t2 = 0x3f3f3f3f ; for( int i = 26 ; i &lt;= 50 ; i++) &#123; if( dis[i] &lt; t2 ) &#123; t2 = dis[i] ; t1 = i ; &#125; &#125; ans = make_pair( t1 - 26 + 'A' , t2 ) ;&#125;int main()&#123; freopen("comehome.in","r",stdin); freopen("comehome.out","w",stdout); cin &gt;&gt; n ; for( int i = 0 ; i &lt; MAXN ; i++) &#123; for( int j = 0 ; j &lt; MAXN ; j++) &#123; graph[i][j] = 0x3f3f3f3f ; &#125; &#125; for( int i = 1 ; i &lt;= n ; i++) &#123; string u , v ; int value ; cin &gt;&gt; u &gt;&gt; v &gt;&gt; value ; graph[ index( u[0] ) ][ index( v[0] ) ] = min( graph[ index( u[0] ) ][ index( v[0] ) ] , value ) ; graph[ index( v[0] ) ][ index( u[0] ) ] = min( graph[ index( v[0] ) ][ index( u[0] ) ] , value ) ; &#125; pair&lt; char , int &gt; ans ; dijkstra( ans ) ; cout &lt;&lt; ans.first &lt;&lt; ' ' &lt;&lt; ans.second &lt;&lt; endl ; return 0 ;&#125; 2.4.5 fracdec 直接模拟就好了。遇到了的几个问题： 1. 一开始判断是否出现过这个情况，我没用set&lt; pair &gt;来处理，而是用了两个set，一个记录商，一个记录余数。结果会发现可能，商是出现过的，余数也是出现过的，然而这两个不是同时出现的，导致出现错误(样例就是这种情况)。 2. 对整除的\(1.0\)这种情况，容易变成\(1.(0)\)。可以通过判断余数是否是0来判断整除与否。 code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/*ID:xiekeyi1PROG:fracdecLANG:C++11 */#include&lt;bits/stdc++.h&gt;using namespace std ;set&lt; pair&lt; int , int &gt; &gt; st ; map&lt; pair&lt; int , int &gt; , int &gt; mp ; int main()&#123; freopen("fracdec.in","r",stdin); freopen("fracdec.out","w",stdout); int n ,d ; cin &gt;&gt; n &gt;&gt; d ; string a; a+= to_string( n / d ) ; int ans = n - n / d * d ; ans *= 10 ; a += "." ; int i = 0 ; int pos = a.size() ; while( true ) &#123; if( st.count( make_pair( ans / d , ans - ans / d * d ) )) &#123; pos += mp[ make_pair( ans / d , ans - ans / d * d ) ] ; break ; &#125; int s = ans / d ; a += to_string( s) ; //shang.insert( s ); // ans 是余数 ans = ans - s * d ; //yushu.insert(ans); st.insert( make_pair( s , ans ) ) ; if( mp[ make_pair( s , ans ) ] == 0 ) mp[ make_pair( s , ans ) ] = i ; ans *= 10 ; i++; // 判断整除 if( ans == 0 ) break ; &#125; if( ans != 0 ) &#123; a.insert( pos , "(" ) ; a += ")" ; &#125; for( int i = 0 ; i &lt; a.size() ; i++) &#123; cout &lt;&lt; a[i] ; if( ( i + 1 ) % 76 == 0 ) &#123; cout &lt;&lt; endl ; &#125; &#125; if( a.size() % 76 != 0 ) &#123; cout &lt;&lt; endl ; &#125; return 0 ;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>USACO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Manacher-最大回文串匹配线性算法]]></title>
    <url>%2Ff89d3c0b.html</url>
    <content type="text"><![CDATA[线性求最大回文串匹配算法。 以往我是不太爱学算法的，尤其是这种适用面很狭窄的算法，因为总感觉算法这东西学了也不一定考，考了也不一定能A。不过最近刷题的时候发现，自己经常遇到的一些题，虽然和我学过的算法没什么关系，但是代码技巧和思维技巧，明明就是我学XX算法的时候的思路嘛。再加上我最近的代码能力有所增强，看新算法、学新算法的时间我感觉明显缩短，理解力up↑up↑。于是开始喜欢看新算法了。 据说这个算法赛场上很难有机会用到，因为适用面狭窄。 关于最大回文串的匹配，常见的算法有两种： 1. 用\(O(n^2)\)的时间复杂度，暴力枚举每一个子串。再对于每一个子串，用\(O(n)\)的复杂度去判断他是否是一个回文串。总时间复杂度为\(O(n^3)\)。 2. 用\(O(n)\)的时间复杂度去枚举中轴，对于每一个中轴，用\(O(n)\)的时间复杂度去向两边扩展。总时间复杂度为\(O(n^2)\)。(注意，这种方法对于偶数中轴和奇数中轴会有一些不一样的情况需要考虑。) Manacher（马拉车）算法 这种算法可以看做是上面第二种算法的一个改进(成电视频中认为这是一个剪枝)。 对于第二种算法，如果当前匹配GG了，那么下一次匹配，依然要从\(1\)(或\(0\))开始重新去检查回文串。 然而，回文串里面有大量相似和冗余的信息，我们希望能用回文串本身的一些性质和所包含的信息，去避免每次都要从头开始匹配的问题。 首先，我们需要对串本身进行一些改进，以避免第二种算法对于奇数和偶数需要分开判断的情况。我们在串的每个字母前后都加入特殊字符#，如对于aaa来说，改变后串为#a#a#a。 接下来我们约定四个变量表示： 1234Ma[i] // Ma表示改进后串，Ma[i]表示第i个字符Mp[i] // 表示从第i个字符开始向两边延伸，最多可以延伸Mp[i]位（他们都是回文串）。Mx // 表示之前延伸过的所有回文串，所到达过的最右端。Id // 表示Mx所对应的回文串的中心。 首先我们初始化：$Mx = 0 , Id = 0 $ 接下来我们和第二种算法所做的基本一样，枚举中轴： 12// 为缩减代码，这里使用strlen函数，实际使用中请务必注意。for( int i = 0 ; i &lt; strlen(Ma) ; i++ ) 分类讨论 情况1 Mx &gt; i 那么如果我们枚举中发现$ Mx &gt; i \(，便可以说明，之前肯定有某一个串，曾经更新覆盖过\)i\(，我们能否利用对称的性质，使\)i$能有一个比较大的初始值，然后再进行常规操作。 由$ Mx &gt; i $ ，我们可以知道显然有$ Mx &gt; i &gt; id \(，那么既然\)Mx和Mx'\(对称，中轴\)id\(知道，那么\)i\(和\)i'$也一定会对称。 这是这个算法的核心。 \(i&#39;\)的坐标是多少呢？就是$ 2 * id - i $ 由 $ id - ( i - id ) $得到 。 情况(1) i和i'都在Mx与Mx'内 那么我们是不是可以直接使用 $ Mp[i] = Mp[ 2 * id - i ] \(呢？ 在\)i\(和\)i'\(都在\)Mx\(和\)Mx'$内时，这是正确无误的。 但是还有另外一种情况。 情况(2) i'在Mx'外 当\(i&#39;\)很长，延伸到了\(Mx&#39;\)外时，我们并不能保证\(i\)也能一如既往的延伸到\(Mx\)以外。这时候我们只能保证\(i\)在\(Mx\)以内的时候，是对称的。 所以这时候 \[ Mp[i] = Mx - i \] 情况(1)和情况(2) 我们并不关心具体是什么情况，因为这对时间复杂度没有影响。所以我们只要Mp[i] = min( Mp[2*id-i] , Mx - i ) 就足够了。 情况2 Mx &lt;= i 遇到这种情况我们怎么办呢？老老实实的去扩展吧。但是在这里我们可以一边扩展，一边去更新Mp[i]的值。 1while( Ma[ i + Mp[i] ] == Ma[ i - Mp[i] ] ) Mp[i]++; 这样即就是一遍扩展，一遍更新了。 Manacher完整实现 最后，我们把上面这几部分组合一下，并注意更新\(Mx\)和\(Id\)的值，就可以了。 code1234567891011121314151617for( int i = 0 ; i &lt; size ; i++)&#123; if( Mx &gt; i ) &#123; Mp[i] = min( Mp[ 2 * Id - i ] , Mx - i ) ; &#125; else Mp[i] = 1 ; while( Ma[i + Mp[i] ] == Ma[i - Mp[i]] ) Mp[i]++; if( i + Mp[i] &gt; Mx ) &#123; Mx = i + Mp[i] ; Id = i ; &#125; ans = max( ans , Mp[i] ) ;&#125; 最终第i个字符的回文串长度为\(Mp[i] - 1\) ## 时间复杂度 这个时间复杂度不是特别好算，我们可以使用摊还分析。具体可以参考一下其他量化分析文章，会很详细。简单的理解可以是： 发现\(Mx\)每次最少往右移动\(1\)，并且除此之外其他的不会对复杂度有贡献。 遇到的一些问题 理解为何\(Mp\)数组只是记录了向其中一边延伸的问题，却可以做最终答案： 因为#号的存在，使得两边的#号必然相等，那么，一边就可以看做是两边了。 需要正确理解为什么第i个字符的回文串长度需要\(-1\)： 同样因为#的存在，当以#为中心，需要去除中心的#，当以非#为中心，需要去除相邻的一个#。 边界等问题。(有些地方会把开头加一些其他的特殊字符以避免边界问题。目前这类问题我还没有遇到) 参考资料 电子科技大学-字符串算法选讲 (昨天很多博客没看清楚，看了这个半个小时就会了) 有什么浅显易懂的Manacher Algorithm详解 - 知乎 (和第一个一起使用） O(n)回文子串(Manacher)算法 如何证明Manacher算法的时间复杂度是O(n)]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>Manacher</tag>
        <tag>字符串</tag>
        <tag>ACM</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT-CCCC-L2-008-最长对称子串]]></title>
    <url>%2Ffb32b34c.html</url>
    <content type="text"><![CDATA[最长回文子串问题 题目链接：https://www.patest.cn/contests/gplt/L2-008 枚举子串 超时一个点 复杂度O(n^3) code12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;using namespace std ;string s ;bool issymm( int l , int r )&#123; for( int i = l ; i &lt;= r ; i++) &#123; if( s[i] != s[r-i+l] ) return false ; &#125; return true ;&#125;int main()&#123; getline(cin,s); int ans = 0 ; for( int i = 0 ; i &lt; s.size() ; i++) &#123; for( int j = 0 ; j &lt; s.size() ; j++) &#123; if( issymm( i , j ) ) &#123; ans = max( ans , j - i + 1 ) ; &#125; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl ;&#125; 枚举中轴 这个方法就是枚举轴，然后从轴向两边扩展。 复杂度O(n^2) 需要注意的是，轴有两种情况: 1. 以中间一个数字为轴 2. 以中间两个数字为轴 code1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;using namespace std ;string s ;int solve( string &amp;s )&#123; int ans = 0 ; for( int i = 0 ; i &lt; s.size() ; i++) &#123; int temp = 1 ; for( int j = 1 ; j &lt; s.size() ; j++) // 以中间一个数字为轴的情况 &#123; if( i - j &lt; 0 || i + j &gt;= s.size() || s[i-j] != s[i+j] ) break; temp += 2; &#125; ans = max( temp , ans ) ; temp = 0 ; for( int j = 1 ; j &lt; s.size() ; j++) // 以中间两个数字为轴的情况 &#123; // 注意这里i-j+1的情况，这是因为需要两个数字之间比较，不相等为0，这里WA了一次。 if( i - j + 1 &lt; 0 || i + j &gt;= s.size() || s[i-j+1] != s[i+j] ) break ; temp+=2; &#125; ans = max( ans , temp ) ; &#125; return ans ;&#125;int main()&#123; getline(cin,s); int ans = 0 ; ans = solve( s ) ; cout &lt;&lt; ans &lt;&lt; endl ;&#125; Manacher 复杂度:O(n) 这个算法看了两天才看明白。 具体这个算法可以看我的下一篇博客： code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;using namespace std ;const int maxn = 3000;char Ma[maxn] ;int Mp[maxn];int Mx = 0 , Id = 0 ; int main()&#123; string s ; getline( cin ,s ) ; Ma[0] = '#' ; for( int i = 1 , cnt = 0 ; cnt &lt; s.size() ; i++) &#123; if( i % 2 == 1 ) &#123; Ma[i] = '#'; &#125; else &#123; Ma[i] = s[cnt++]; &#125; &#125; int size = strlen(Ma); Ma[size++] = '#' ; int ans = 0 ; for( int i = 0 ; i &lt; size ; i++) &#123; if( Mx &gt; i ) &#123; Mp[i] = min( Mp[ 2 * Id - i ] , Mx - i ) ; &#125; else Mp[i] = 1 ; while( Ma[i + Mp[i] ] == Ma[i - Mp[i]] ) Mp[i]++; if( i + Mp[i] &gt; Mx ) &#123; Mx = i + Mp[i] ; Id = i ; &#125; ans = max( ans , Mp[i] ) ; &#125; cout &lt;&lt; ans - 1 &lt;&lt; endl ; return 0 ;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>CCCC</tag>
        <tag>PAT</tag>
        <tag>Manacher</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Boost.test单元测试 第一次使用]]></title>
    <url>%2F4fb81a46.html</url>
    <content type="text"><![CDATA[第一次学习单元测试 之前在申请GSoC的Boost库相关项目，要求我实现一个线段树类。在实现后要求我去做单元测试。一开始是一直不愿意去做这个单元测试的，因为查了一下发现资料很少，时间很紧，感觉英文文档太长，使用起来感觉有点抵触，觉得会很困难。 最后硬着头皮上了。 单元测试其实比我想象的简单，就是把我一直都在使用的人肉测试自动化了而已。 ** 单元测试是面向接口的，和面向对象的程序设计思想重合** 。 我使用的系统是Ubuntu 16.04 ，首先安装 sudo apt-get install libboost-dev （如果找不到相关的可以使用sudo apt-cache search boost 来查找关于boost的全部信息。如果找不到的话，尝试sudo apt-get update 进行更新。 一开始我以为boost库会很大，实际下载下来也就几百MB，很少。 下载完成后，我照着官方文档的tutorials做了一些简单的测试，发现使用起来很方便。 这个文档中的代码基本上上拿来就可以使用了，唯一需要注意的是要在最上面加上这一句宏#define BOOST_TEST_DYN_LINK ，这一句宏是为了开启动态链接的。** 这个宏必须必须放在最开头！** 我之前放在第二行，结果总是提示找不到main函数，最后鬼使神差的调整了一下位置解决了这个问题。 编译命令需要加上-lboost_unit_test_framework 进行链接。 编译后运行即可。 boost.test库里还有很多更强大的东西，但是因为这次我只需要做一些简单的测试，所以并没有进一步学习。希望以后有机会可以学到如何使用大文件大数据(像模拟一个本地OJ一样)。 code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495代码如下：```c++#define BOOST_TEST_DYN_LINK#define BOOST_TEST_MODULE TEST_SEGMENT_TREE #include &lt;boost/test/unit_test.hpp&gt;#include "segment_tree.hpp"#include&lt;vector&gt;#include&lt;iostream&gt;using namespace std ;using namespace st ; // segment_tree ;using namespace boost ;// g++ -std=gnu++11 unit_test.cpp -lboost_unit_test_frameworkBOOST_AUTO_TEST_CASE( MAX )&#123; vector&lt;int&gt; a; for( int i = 0 ; i &lt; 10 ; i++) &#123; a.push_back(i); &#125; segment_tree&lt; int , Max&lt;int&gt; &gt; *st = new segment_tree&lt; int , Max&lt;int&gt; &gt; ; st-&gt;build( a , 0 , 9 ) ; BOOST_CHECK_MESSAGE( st-&gt;query( 0,0 ) == 0 , "st.query(..) result: " &lt;&lt; st-&gt;query(0,0) ); // check border zero BOOST_CHECK_MESSAGE( st-&gt;query( 0,9 ) == 9 , "st.query(..) result: " &lt;&lt; st-&gt;query(0,9) ); // check all segment ; BOOST_CHECK_MESSAGE( st-&gt;query(1,5) == 5 , "st.query(..) result: " &lt;&lt; st-&gt;query(1,5) ); // check a segment ; st-&gt;modify1(1,5,100); // add [1,5] to 100 ; BOOST_CHECK_MESSAGE( st-&gt;query(1,5) == 105 , "st.query(..) result: " &lt;&lt; st-&gt;query(1,5) ); // check the modify correct; BOOST_CHECK_MESSAGE( st-&gt;query(8,8) == 8, "st.query(..) result: " &lt;&lt; st-&gt;query(8,8) ); // check the not modify node ; BOOST_CHECK_MESSAGE( st-&gt;query(6,9) == 9, "st.query(..) result: " &lt;&lt; st-&gt;query(6,9) ); // check the not modify segment ; st-&gt;modify1(1,5,-100); // add [[1,5] to -100 ; BOOST_CHECK_MESSAGE( st-&gt;query(0,9) == 9, "st.query(..) result: " &lt;&lt; st-&gt;query(0,9) ); //; check the modify ; delete st;&#125;BOOST_AUTO_TEST_CASE( MIN )&#123; vector&lt;int&gt; a; for( int i = 0 ; i &lt; 10 ; i++) &#123; a.push_back(i); &#125; segment_tree&lt; int , Min&lt;int&gt; &gt; *st = new segment_tree&lt; int , Min&lt;int&gt; &gt; ; st-&gt;build( a , 0 , 9 ) ; BOOST_CHECK_MESSAGE( st-&gt;query( 0,0 ) == 0 , "st.query(..) result: " &lt;&lt; st-&gt;query(0,0) ); // check border zero BOOST_CHECK_MESSAGE( st-&gt;query( 0,9 ) == 0 , "st.query(..) result: " &lt;&lt; st-&gt;query(0,9) ); // check all segment ; BOOST_CHECK_MESSAGE( st-&gt;query(1,5) == 1 , "st.query(..) result: " &lt;&lt; st-&gt;query(1,5) ); // check a segment ; st-&gt;modify1(1,5,100); // add [1,5] to 100 ; BOOST_CHECK_MESSAGE( st-&gt;query(1,5) == 101, "st.query(..) result: " &lt;&lt; st-&gt;query(1,5) ); // check the modify correct; BOOST_CHECK_MESSAGE( st-&gt;query(8,8) == 8, "st.query(..) result: " &lt;&lt; st-&gt;query(8,8) ); // check the not modify node ; BOOST_CHECK_MESSAGE( st-&gt;query(6,9) == 6, "st.query(..) result: " &lt;&lt; st-&gt;query(6,9) ); // check the not modify segment ; st-&gt;modify1(1,5,-200); // add [[1,5] to -100 ; BOOST_CHECK_MESSAGE( st-&gt;query(0,9) == -99, "st.query(..) result: " &lt;&lt; st-&gt;query(0,9) ); //; check the modify ; delete st;&#125;BOOST_AUTO_TEST_CASE( PLUS )&#123; vector&lt;int&gt; a; for( int i = 0 ; i &lt; 10 ; i++) &#123; a.push_back(i); &#125; segment_tree&lt; int , Plus&lt;int&gt; &gt; *st = new segment_tree&lt; int , Plus&lt;int&gt; &gt; ; st-&gt;build( a , 0 , 9 ) ; BOOST_CHECK_MESSAGE( st-&gt;query( 0,0 ) == 0 , "st.query(..) result: " &lt;&lt; st-&gt;query(0,0) ); // check border zero BOOST_CHECK_MESSAGE( st-&gt;query( 0,9 ) == 45 , "st.query(..) result: " &lt;&lt; st-&gt;query(0,9) ); // check all segment ; BOOST_CHECK_MESSAGE( st-&gt;query(1,5) == 15 , "st.query(..) result: " &lt;&lt; st-&gt;query(1,5) ); // check a segment ; st-&gt;modify1(1,5,100); // add [1,5] to 100 ; BOOST_CHECK_MESSAGE( st-&gt;query(1,5) == 515, "st.query(..) result: " &lt;&lt; st-&gt;query(1,5) ); // check the modify correct; BOOST_CHECK_MESSAGE( st-&gt;query(8,8) == 8, "st.query(..) result: " &lt;&lt; st-&gt;query(8,8) ); // check the not modify node ; BOOST_CHECK_MESSAGE( st-&gt;query(6,9) == 30 , "st.query(..) result: " &lt;&lt; st-&gt;query(6,9) ); // check the not modify segment ; st-&gt;modify1(1,5,-100); // add [[1,5] to -100 ; BOOST_CHECK_MESSAGE( st-&gt;query(0,9) == 45, "st.query(..) result: " &lt;&lt; st-&gt;query(0,9) ); //; check the modify ; delete st;&#125; 运行结果：]]></content>
      <categories>
        <category>工程</category>
      </categories>
      <tags>
        <tag>测试</tag>
        <tag>Boost</tag>
        <tag>工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT-CCCC-L2.002紧急救援]]></title>
    <url>%2F777eca84.html</url>
    <content type="text"><![CDATA[题目链接：https://www.patest.cn/contests/gplt/L2-001 有点小瞧了这道题的难度。从L1一路高歌猛进过来，以为L2一开始不会太难，只是一个简单的最短路。 想了一会后发现，主要问题是： 1. 边权和最小的情况下（就是普通最短路），点权和最大。 2. 输出路径。（一个pre数组记录，栈输出或者递归输出，基本操作）。 3. 求所有最短路的个数。（之前没有接触过）。 要点权和最大，就类似于多关键字排序一样，再加一层松弛判断就可以。 求最短路个数，就是如果松弛了i，pathnum[i] = 1 ， 如果是在距离一样的情况下松弛了，那么就pathnum[i] += pathnum[node]（node是链接过来的点）即可。 这道题卡了我很久的两个地方： 1. 点权和最大的判断自己写蠢了好几次。明明模仿边权和判断的问题就可以了，然而还是蠢了不少。 2. 这道题一开始我以为有重边。处理很久不清楚在邻接矩阵的情况下怎么处理，一开始考虑要不要用邻接链表的时候，找了个别人A的测了下，发现它也没处理重边，于是重边问题没有解决。 遗留问题： 1. ** 如何在邻接矩阵的情况下处理重边? 2. 为什么很多人的迪杰斯特拉，都要源点先在循环外松弛一圈，我尝试了一下，放在循环内松弛也是可以的。所以这个有什么问题吗？** code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include&lt;bits/stdc++.h&gt;using namespace std ;const int maxn = 550 ;const int inf = 0x3f3f3f3f ;int graph[maxn][maxn];int dis[maxn];int pathnum[maxn] ;int sum[maxn];int num[maxn];bool vis[maxn];int pre[maxn];int main()&#123; for( int i = 0 ; i &lt; maxn ; i++) for(int j = 0 ; j &lt; maxn ; j++) graph[i][j] = inf; fill( dis , dis + maxn , inf ) ; memset(pathnum,0,sizeof(pathnum)); memset(sum,0,sizeof(sum)); memset(num,0,sizeof(num)); memset(vis,false,sizeof(vis)); memset(pre,0,sizeof(pre)); int N , M , S , D; cin &gt;&gt; N &gt;&gt; M &gt;&gt; S &gt;&gt; D ; pre[S] = S ; for( int i = 0 ; i &lt; N ; i++) &#123; cin &gt;&gt; num[i]; sum[i] = num[i]; &#125; for( int i = 0 ; i &lt; M ; i++) &#123; int u , v , diss ; cin &gt;&gt; u &gt;&gt; v &gt;&gt; diss; graph[u][v] = min( graph[u][v] , diss ) , graph[v][u] = min( graph[v][u] , diss ) ; &#125; graph[S][S] = 0 ; dis[S] = 0 ; pathnum[S] = 1 ; for( int i = 0 ; i &lt; N ; i++) &#123; int node = -1 , minn = inf , summ = 0 ; for( int j = 0 ; j &lt; N ; j++) &#123; if( !vis[j] &amp;&amp; minn &gt; dis[j] ) node = j , minn = dis[j] , summ = num[j] ; else if( ! vis[j] &amp;&amp; minn == dis[j] ) if( summ &lt; num[j] ) node = j , minn = dis[j] , summ = num[j] ; &#125; vis[node] = true ; for( int j = 0 ; j &lt; N ; j++) &#123; if( !vis[j] &amp;&amp; graph[node][j] + minn &lt; dis[j] ) &#123; pathnum[j] = pathnum[node]; dis[j] = graph[node][j] + minn ; sum[j] = sum[node] + num[j] ; pre[j] = node ; &#125; else if ( !vis[j] &amp;&amp; graph[node][j] + minn == dis[j] ) &#123; pathnum[j] += pathnum[node]; if( sum[j] &lt; sum[node] + num[j]) &#123; dis[j] = graph[node][j] + minn ; sum[j] = sum[node] + num[j] ; pre[j] = node ; &#125; &#125; &#125; &#125; int node = D ; stack&lt;int&gt; path ; while( pre[node] != node ) &#123; path.push(node); node = pre[node]; &#125; path.push(S); cout &lt;&lt; pathnum[D] &lt;&lt; ' ' &lt;&lt; sum[D] &lt;&lt; endl ; bool flag = false ; while( !path.empty() ) &#123; if( !flag ) &#123; cout &lt;&lt; path.top() ; flag = true ; &#125; else &#123; cout &lt;&lt; ' ' &lt;&lt; path.top() ; &#125; path.pop(); &#125; cout &lt;&lt; endl ;&#125; 错了这么多次终于A了，真的是爽到。]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>CCCC</tag>
        <tag>PAT</tag>
        <tag>图论</tag>
        <tag>dijkstra</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO-Chapter2-Section2.3]]></title>
    <url>%2F8c7dbeeb.html</url>
    <content type="text"><![CDATA[快期末考试了，可能ECL FINAL结束后，会停止训练一个月左右去准备期末考试了。 这一章，刷的时间有点久啊。 1Prefix code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384 /*ID:xiekeyi1PROG:prefixLANG:C++ */#include&lt;bits/stdc++.h&gt;using namespace std ;//vector&lt;string&gt; a;//string s ; char a[210][15];int num_string = 0 ; int s_size = 0 ; char s[200100];bool vis[200100];int dfs( int n )&#123; if( vis[n] ) return 0; else vis[n] = 1 ; int ans = 0; if( n &gt;= s_size ) return s_size; for( int i = 0 ; i &lt; num_string ; i++) &#123; bool flag = true; int tt = strlen(a[i]) ; for( int j = 0 ; j &lt; tt ; j++ ) &#123; if( s[n + j ] != a[i][j] ) &#123; flag = false ; break ; &#125; &#125; if( flag ) &#123; ans = max( ans , dfs( n + tt ) ) ; &#125; &#125; return ( ans != 0 ) ? ans : n ;&#125;int main()&#123; freopen("prefix.in","r",stdin); freopen("prefix.out","w",stdout); char ch ; while( scanf("%s" , a[ num_string++]) ) if( strcmp( a[num_string - 1 ] , "." ) == 0 ) break ; num_string--;// string t ;// while( cin &gt;&gt; t &amp;&amp; t != "." )// a.push_back(t);// while( cin &gt;&gt; t )// s += t ; while( ( ch = getchar() ) != EOF ) &#123; if( ch == EOF ) break ; if( ch == ' ' || ch == '\n' ) continue ; s[ s_size++ ] = ch ; &#125; cout &lt;&lt; dfs(0) &lt;&lt; endl ;&#125; 2nocows 爆搜(TLE) code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263 /*ID:xiekeyi1PROG:nocowsLANG:C++ */#include&lt;bits/stdc++.h&gt;using namespace std ;int n , k ; int dfs( int remain_points , int now_floor , int floor )&#123; remain_points-- ; if( now_floor &gt;= floor || remain_points &lt;= 0 ) &#123; if( remain_points == 0 &amp;&amp; now_floor == floor ) return 1 ; else return 0 ; &#125; int ans = 0 ; for( int i = 0 ; i &lt;= remain_points ; i++) &#123; if( i &gt; 0 &amp;&amp; remain_points - i &gt; 0 ) &#123; int t1 = 0 ; int t2 = 0 ; t1 += dfs( i , now_floor + 1 , floor ) ; for( int j = now_floor + 1 ; j &lt;= floor - 1 ; j++) &#123; t2 += dfs( remain_points - i , now_floor + 1 , j ) ; &#125; ans += t1 * t2 ; t1 = 0 ; t2 = 0 ; t2 += dfs( remain_points - i , now_floor + 1 , floor ) ; for( int j = now_floor + 1 ; j &lt;= floor - 1 ; j++) &#123; t1 += dfs( i , now_floor + 1 , j ) ; &#125; ans += t1 * t2 ; ans += dfs( i , now_floor + 1 , floor ) * dfs( remain_points - i , now_floor + 1 , floor ) ; &#125; &#125; return ans ; &#125;int main()&#123; freopen("nocows.in","r",stdin); freopen("nocows.out","w",stdout); cin &gt;&gt; n &gt;&gt; k ; cout &lt;&lt; dfs( n , 1 , k ) % 9901 &lt;&lt; endl ;&#125; 压状态爆搜(TLE) code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778 /*ID:xiekeyi1PROG:nocowsLANG:C++ */#include&lt;bits/stdc++.h&gt;using namespace std ;int n , k ;int dfs( int remain_points , int now_floor , bool flag )&#123; remain_points-- ; if( now_floor &gt;= k || remain_points &lt;= 0 ) &#123; if( flag ) &#123; if( remain_points == 0 &amp;&amp; now_floor == k ) return 1 ; else return 0 ; &#125; else &#123; if( remain_points == 0 &amp;&amp; now_floor &lt; k ) return 1 ; else return 0 ; &#125; &#125; int ans = 0 ; for( int i = 0 ; i &lt;= remain_points ; i++) &#123; if( i &gt; 0 &amp;&amp; remain_points - i &gt; 0 ) &#123; if( flag ) &#123; int t1 = 0 ; int t2 = 0 ; t1 += dfs( i , now_floor + 1 , true ) ; t2 += dfs( remain_points - i , now_floor + 1 , false ) ; ans += t1 * t2 ; t1 = 0 ; t2 = 0 ; t2 += dfs( remain_points - i , now_floor + 1 , true ) ; t1 += dfs( i , now_floor + 1 , false ) ; ans += t1 * t2 ; ans += dfs( i , now_floor + 1 , true ) * dfs( remain_points - i , now_floor + 1 , true ) ; &#125; else &#123; ans += dfs( i , now_floor + 1 , false ) * dfs( remain_points - i , now_floor + 1 , false ) ; &#125; &#125; &#125; //printf(" dfs( %d , %d , %d ) : %d \n " , remain_points , now_floor , floor , ans ) ; return ans ; &#125;int main()&#123; freopen("nocows.in","r",stdin); freopen("nocows.out","w",stdout); cin &gt;&gt; n &gt;&gt; k ; cout &lt;&lt; dfs( n , 1 , true ) &lt;&lt; endl ; return 0 ; &#125; 压状态记忆化搜索 code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384 /*ID:xiekeyi1PROG:nocowsLANG:C++ */#include&lt;bits/stdc++.h&gt;using namespace std ;int n , k ;int dp[200][200][2];int dfs( int remain_points , int now_floor , bool flag )&#123; if( dp[remain_points][now_floor][flag] != - 1) return dp[remain_points][now_floor][flag] ; remain_points-- ; if( now_floor &gt;= k || remain_points &lt;= 0 ) &#123; if( flag ) &#123; if( remain_points == 0 &amp;&amp; now_floor == k ) return dp[remain_points + 1 ][ now_floor][flag] = 1 ; else return dp[remain_points + 1 ][now_floor][flag] = 0 ; &#125; else &#123; if( remain_points == 0 &amp;&amp; now_floor &lt; k ) return dp[remain_points+1][now_floor][flag] = 1 ; else return dp[remain_points+1][now_floor][flag] = 0 ; &#125; &#125; int ans = 0 ; for( int i = 0 ; i &lt;= remain_points ; i++) &#123; if( i &gt; 0 &amp;&amp; remain_points - i &gt; 0 ) &#123; if( flag ) &#123; int t1 = 0 ; int t2 = 0 ; t1 += dfs( i , now_floor + 1 , true ) ; t2 += dfs( remain_points - i , now_floor + 1 , false ) ; ans += ( t1 % 9901 * t2 % 9901 ) % 9901 ; t1 = 0 ; t2 = 0 ; t2 += dfs( remain_points - i , now_floor + 1 , true ) ; t1 += dfs( i , now_floor + 1 , false ) ; ans += ( t1 %9901 * t2 % 9901 ) % 9901 ; ans += dfs( i , now_floor + 1 , true ) % 9901 * dfs( remain_points - i , now_floor + 1 , true ) %9901 ; &#125; else &#123; ans += dfs( i , now_floor + 1 , false ) % 9901 * dfs( remain_points - i , now_floor + 1 , false ) % 9901 ; &#125; &#125; &#125; //printf(" dfs( %d , %d , %d ) : %d \n " , remain_points , now_floor , floor , ans ) ; return dp[remain_points+1][now_floor][flag] = ans % 9901 ; &#125;int main()&#123; freopen("nocows.in","r",stdin); freopen("nocows.out","w",stdout); memset( dp , -1 , sizeof(dp ) ) ; cin &gt;&gt; n &gt;&gt; k ; cout &lt;&lt; dfs( n , 1 , true ) % 9901 &lt;&lt; endl ; return 0 ; &#125; 四次方DP code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061 /*ID:xiekeyi1PROG:nocowsLANG:C++ */#include&lt;bits/stdc++.h&gt;using namespace std ;const int maxn = 200 + 10 , maxk = 100 + 10 ;const int modp = 9901 ;int n , k ;int dp[maxn][maxk]; // dp[i][j] means the number of schemes with points i in floor j ;int main()&#123; freopen("nocows.in","r",stdin); freopen("nocows.out","w",stdout); cin &gt;&gt; n &gt;&gt; k ; dp[1][1] = 1 ; for( int now_floor = 1 ; now_floor &lt;= k ; now_floor++) &#123; for( int now_point = 1 ; now_point &lt;= n ; now_point++ ) &#123; for( int enum_point = 1 ; enum_point &lt;= now_point - 1 ; enum_point++) &#123; int less_than_nowfloor = 0 ; for( int enum_floor = 1 ; enum_floor &lt;= now_floor - 2 ; enum_floor++ ) less_than_nowfloor += dp[ now_point - 1 - enum_point ][ enum_floor ] % modp ; less_than_nowfloor %= modp ; dp[now_point][now_floor] += dp[ enum_point ][ now_floor - 1 ] % modp * less_than_nowfloor % modp ; dp[now_point][now_floor] %= modp ; less_than_nowfloor = 0 ; for( int enum_floor = 1 ; enum_floor &lt;= now_floor - 2 ; enum_floor++ ) less_than_nowfloor += dp[enum_point][enum_floor] % modp ; less_than_nowfloor %= modp ; dp[now_point][now_floor] += less_than_nowfloor % modp * dp[ now_point - 1 - enum_point][now_floor-1] % modp ; dp[now_point][now_floor] %= modp ; dp[now_point][now_floor] += dp[ enum_point][now_floor-1] % modp * dp[ now_point - 1 - enum_point][now_floor-1] % modp ; dp[now_point][now_floor] %= modp ; &#125; &#125; &#125; cout &lt;&lt; dp[n][k] % modp &lt;&lt; endl ;&#125; 三次方DP code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354 /*ID:xiekeyi1PROG:nocowsLANG:C++ */#include&lt;bits/stdc++.h&gt;using namespace std ;const int maxn = 200 + 10 , maxk = 100 + 10 ;const int modp = 9901 ;int n , k ;int dp[maxn][maxk]; // dp[i][j] means the number of schemes with points i in floor j ;int sum[maxn][maxk]; // sum[i][j] means the number of schemes with points i less floor j ; int main()&#123; freopen("nocows.in","r",stdin); freopen("nocows.out","w",stdout); cin &gt;&gt; n &gt;&gt; k ; dp[1][1] = 1 ; for( int i = 1 ; i &lt;= k ; i++) sum[1][i] = 1 ; for( int now_floor = 1 ; now_floor &lt;= k ; now_floor++) &#123; for( int now_point = 1 ; now_point &lt;= n ; now_point++ ) &#123; for( int enum_point = 1 ; enum_point &lt;= now_point - 1 ; enum_point++) &#123; dp[now_point][now_floor] += dp[enum_point][now_floor-1] * sum[now_point - enum_point - 1 ][ now_floor-2]; dp[now_point][now_floor] += dp[now_point-enum_point-1][now_floor-1] * sum[enum_point][ now_floor-2]; dp[now_point][now_floor] += dp[now_point-enum_point-1][now_floor-1] * dp[enum_point][now_floor-1]; dp[now_point][now_floor] %= modp ; &#125; for( int j = 1 ; j &lt;= now_floor ; j++) sum[now_point][j] = ( sum[now_point][j-1] + dp[now_point][j] ) % modp ; &#125; &#125; cout &lt;&lt; dp[n][k] % modp &lt;&lt; endl ;&#125; 3zerosum code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152 /*ID:xiekeyi1PROG: zerosum LANG: C++11 */#include&lt;bits/stdc++.h&gt;using namespace std ;string s ; int n ;vector&lt;string&gt; a ; void dfs( int pos , string sss )&#123; //if( sss == "1-2 3+4+5+6+7" ) // cout &lt;&lt; sss &lt;&lt; endl ; if( pos &gt;= n - 1 ) &#123; int ans = 0 ; bool flag = true ; for( int i = 0 ; i &lt; sss.size() ; i++) &#123; if( i == 0 &amp;&amp; flag ) &#123; flag = false ; int num = 0 ; for( int j = i ; j &lt; sss.size() ; j++) &#123; if( sss[j] == '+' ) &#123; i = j - 1 ; break ; &#125; else if( sss[j] == '-' ) &#123; i = j - 1 ; break ; &#125; else if( sss[j] == ' ' ) num *= 10 ; else num += sss[j] - '0' ; &#125; ans = num ; &#125; else if( sss[i] == '+' || sss[i] == '-' ) &#123; char ch ; if( sss[i] == '+' ) &#123; ch = '+' ;&#125; if( sss[i] == '-' ) &#123; ch = '-' ;&#125; int num = 0 ; for( int j = i + 1 ; j &lt; sss.size() ; j++) &#123; if( sss[j] == '+' ) &#123; i = j - 1 ; break ; &#125; else if( sss[j] == '-' ) &#123; i = j - 1 ; break ; &#125; else if( sss[j] == ' ' ) num *= 10 ; else num += sss[j] - '0' ; &#125; ans = ( ( ch == '+' ) ? ( ans + num ) : ( ans - num ) ) ; &#125; &#125; if( ans == 0 ) &#123; sss.push_back('\n' ) ; a.push_back(sss); &#125; &#125; else &#123; string t ; t = sss; t.insert( t.begin() + pos + 1 , ' ' ); dfs( pos + 2 , t ) ; t = sss ; t.insert( t.begin() + pos + 1 , '+' ) ; dfs( pos + 2 , t ) ; t = sss; t.insert( t.begin() + pos + 1 , '-' ); dfs( pos + 2 , t ) ; &#125; return ;&#125;const bool cmp( const string &amp;s1 , const string &amp;s2 )&#123; for( int i = 0 ; i &lt; s1.size() ; i++) &#123; if( s1[i] == s2[i] ) continue; else &#123; if( s1[i] == ' ' ) return true ; else if( s1[i] == '+' ) &#123; if( s2[i] == '-' || s2[i] == ' ' ) return false ; else return true ; &#125; else if( s1[i] == '-' ) &#123; if( s2[i] == '+' || s2[i] == ' ' ) return false ; else return true ; &#125; &#125; &#125; return false ; &#125;int main()&#123; freopen("zerosum.in","r",stdin); freopen("zerosum.out","w",stdout); cin &gt;&gt; n ; string ss ; for( int i = 1 ; i &lt;= n ; i++) s += i + '0' ; n += n - 1 ; ss = s ; dfs( 0 , ss ) ; sort( a.begin() , a.end() , cmp ) ; for( auto i : a ) cout &lt;&lt; i ; return 0 ;&#125; 4money 记忆化搜索 code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748 /*ID:xiekey1PROG:moneyLANG:C++*/#include&lt;bits/stdc++.h&gt;using namespace std;const int maxv = 30 , maxn = 10010 ; int v , n ;int a[maxv] ;long long dp[maxn][maxv];long long dfs( int n , int i )&#123; if( dp[n][i] != - 1 ) return dp[n][i] ; if( n == 0 ) return dp[n][i] = 1 ; if( i &gt; v ) return dp[n][i] = 0 ; long long ans = 0; for( int j = 0 ; j * a[i] &lt;= n ; j++) &#123; ans += dfs( n - j * a[i] , i + 1 ) ; &#125; return dp[n][i] = ans ; &#125;int main()&#123; freopen("money.in","r",stdin); freopen("money.out","w",stdout); memset( dp , -1 , sizeof( dp ) ) ; cin &gt;&gt; v &gt;&gt; n ; for( int i = 1 ; i &lt;= v ; i++) cin &gt;&gt; a[i] ; cout &lt;&lt; dfs( n , 1 ) &lt;&lt; endl ;&#125; 多重背包 code123456789101112131415161718192021222324252627282930313233343536373839404142 /*ID:xiekey1PROG:moneyLANG:C++*/#include&lt;bits/stdc++.h&gt;using namespace std ;const int maxv = 30 , maxn = 10010 ; int v , n ;int a[maxv] ;long long dp[maxv][maxn];int main()&#123; freopen("money.in","r",stdin); freopen("money.out","w",stdout); cin &gt;&gt; v &gt;&gt; n ; for( int i = 1 ; i &lt;= v ; i++) cin &gt;&gt; a[i] ; memset(dp,0,sizeof(dp)); dp[0][0] = 1 ; for( int i = 1 ; i &lt;= v ; i++) &#123; for( int j = 0 ; j &lt;= n ; j++) &#123; for( int k = 0 ; k * a[i] &lt;= j ; k++) &#123; dp[i][j] += dp[i-1][j-k*a[i]] ; &#125; &#125; &#125; cout &lt;&lt; dp[v][n] &lt;&lt; endl ; return 0 ;&#125; 完全背包 code1234567891011121314151617181920212223242526272829303132333435363738394041424344 /*ID:xiekey1PROG:moneyLANG:C++*/#include&lt;bits/stdc++.h&gt;using namespace std;const int maxv = 30 , maxn = 10010 ;int v , n ;long long dp[maxv][maxn];int a[maxv];int main()&#123; freopen("money.in","r",stdin); freopen("money.out","w",stdout); cin &gt;&gt; v &gt;&gt; n ; for( int i = 1 ; i &lt;= v ; i++) cin &gt;&gt; a[i]; memset( dp , 0 , sizeof(dp) ) ; dp[0][0] = 1 ; for( int i = 1 ; i &lt;= v ; i++) &#123; for( int j = 0; j &lt;= n ; j++) &#123; if( j &gt;= a[i] ) dp[i][j] = dp[i-1][j] + dp[i][ j - a[i] ] ; else dp[i][j] = dp[i-1][j] ; &#125; &#125; cout &lt;&lt; dp[v][n] &lt;&lt; endl ; return 0 ;&#125; 5Controlling Companies code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768 /*ID:xiekeyi1PROG:concomLANG:C++11*/#include&lt;bits/stdc++.h&gt;using namespace std ;const int maxn = 100 + 10 ;int graph[maxn][maxn];int max_num = 0 ; int own[maxn] ; bool vis[maxn]; void dfs( int n )&#123; for( int i = 1 ; i &lt;= max_num ; i++) &#123; own[i] += graph[n][i] ; if( i != n &amp;&amp; !vis[i] &amp;&amp; own[i] &gt;= 50 ) &#123; vis[i] = true ; dfs( i ); &#125; &#125; return ; &#125;int main()&#123; freopen("concom.in","r",stdin); freopen("concom.out","w",stdout); int n ; cin &gt;&gt; n ; for( int i = 1 ; i &lt;= n ; i++) &#123; int x , y ; cin &gt;&gt; x &gt;&gt; y ; cin &gt;&gt; graph[x][y] ; max_num = max( &#123; max_num , x , y &#125; ) ; &#125; string ans ; for( int i = 1 ; i &lt;= max_num ; i++) &#123; memset(own,0,sizeof(own)); memset(vis,0,sizeof(vis)); dfs(i); for( int j = 1 ; j &lt;= max_num ; j++) &#123; if( i != j &amp;&amp; own[j] &gt;= 50 ) &#123; cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; j &lt;&lt; endl ; &#125; &#125; &#125; return 0 ; &#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>USACO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO-2.2.2-Nocows-DP]]></title>
    <url>%2Fd94f5e84.html</url>
    <content type="text"><![CDATA[给定\(N\)、\(K\)，求由\(N\)个节点、构造出的\(K\)层完全二叉树的方案数。 题意: 题目描述 农民约翰准备购买一群新奶牛。 在这个新的奶牛群中, 每一个母亲奶牛都生两个小奶牛。这些奶牛间的关系可以用二叉树来表示。这些二叉树总共有\(N\)个节点($ 3 N &lt; 200 $)。这些二叉树有如下性质: 每一个节点的度是\(0\)或\(2\)。度是这个节点的孩子的数目。 树的高度等于\(K\)(\(1 &lt; K &lt; 100\))。高度是从根到最远的那个叶子所需要经过的结点数; 叶子是指没有孩子的节点。 有多少不同的家谱结构? 如果一个家谱的树结构不同于另一个的, 那么这两个家谱就是不同的。输出可能的家谱数的个数除以\(9901\)的余数。 输入格式： 两个空格分开的整数, N和K。 输出格式： 一个整数，表示可能的家谱树的个数除以9901的余数。 输入输出样例 输入样例#1： 5 3 输出样例#1： 2 说明 翻译来自NOCOW USACO 2.3 做法： 暴搜(TLE) 对于已知\(1到i\)层二叉树的方案数，想要在此之上构建出第\(i+1\)层的方案数。我们的方法有： 1. 左子树是\(i\)层，右子树是\(1到i-1\)层。(在这种情况下，上面加一个根节点) 2. 左子树是\(1到i-1\)层，右子树是\(i\)层。(在这种情况下，上面加一个根节点) 3. 左右子树都是\(i\)层。(在这种情况下，上面加一个根节点) 按照这个方法，可以递归去生成这么一颗树。但是我们并不知道左右子树的节点个数，所以我们还要枚举节点个数。 因此，我们可以定义函数dfs( remain_points , now_floor , floor ) 表示使用remain_points个节点，构建floor的方案数。按照上面的方法去生成即可。 代码： code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960 /*ID:xiekeyi1PROG:nocowsLANG:C++*/#include&lt;bits/stdc++.h&gt;using namespace std ;int n , k ; int dfs( int remain_points , int now_floor , int floor )&#123; remain_points-- ; // 减去当前的根节点。 if( now_floor &gt;= floor || remain_points &lt;= 0 ) // 超过当前要求的层数或剩余节点小于0即退出。 &#123; if( remain_points == 0 &amp;&amp; now_floor == floor ) // 当当前层数和剩余节点都满足时为合格方案数。 return 1 ; else return 0 ; &#125; int ans = 0 ; // 枚举，i表示对左子树分配的节点，对右子树分配 remian_points - i个节点。 for( int i = 0 ; i &lt;= remain_points ; i++) &#123; if( i &gt; 0 &amp;&amp; remain_points - i &gt; 0 ) // 因为对度数有0或者2的要求，所以左右子树都要大于0. &#123; // 第一种情况，左子树是i层，右子树是 1 到 i - 1 层。 int t1 = 0 ; int t2 = 0 ; t1 += dfs( i , now_floor + 1 , floor ) ; for( int j = now_floor + 1 ; j &lt;= floor - 1 ; j++) &#123; t2 += dfs( remain_points - i , now_floor + 1 , j ) ; &#125; ans += t1 * t2 ; // 第二种情况， 左子树是1到i-1层，右子树是i层。 t1 = 0 ; t2 = 0 ; t2 += dfs( remain_points - i , now_floor + 1 , floor ) ; for( int j = now_floor + 1 ; j &lt;= floor - 1 ; j++) &#123; t1 += dfs( i , now_floor + 1 , j ) ; &#125; ans += t1 * t2 ; // 第三种情况，左右两个子树都是i层。 ans += dfs( i , now_floor + 1 , floor ) * dfs( remain_points - i , now_floor + 1 , floor ) ; &#125; &#125; return ans ; &#125;int main()&#123; freopen("nocows.in","r",stdin); freopen("nocows.out","w",stdout); cin &gt;&gt; n &gt;&gt; k ; cout &lt;&lt; dfs( n , 1 , k ) % 9901 &lt;&lt; endl ;&#125; 这样的代码毫无疑问是会T的。时间复杂度\(O( n * 2^k )\) 然后我想用我无往不利的将dfs改成记忆化搜索，我想那样的话就肯定可以过。 结果用和dfs参数类似的数组dp[maxn][maxk][maxk]改记忆化搜索后，\(MLE\)了(说来搞ACM，好久没遇到MLE了2333。感觉一直对空间限制都不是很严格。没想到USACO限制挺严格的。)。 压状态爆搜(TLE) 因为我们dp[maxn][maxk][maxk]爆空间了。毫无疑问是我们的状态太多了。因此，我们不得不去压缩一下状态。 考虑到对于floor这个参数来说，其实完全没有必要记录\(1到k\)每一个的状态。对于我们来说，只关心是等于k还是小于k即可。 所以我们修改dfs为dfs( remain_points , now_floor , flag )，用一个二维状态表示即可(不过这个修改，我还改了挺长时间的。改起来挺麻烦的)。 代码: code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182 /*ID:xiekeyi1PROG:nocowsLANG:C++ */#include&lt;bits/stdc++.h&gt;using namespace std ;int n , k ;int dfs( int remain_points , int now_floor , bool flag )&#123; remain_points-- ; if( now_floor &gt;= k || remain_points &lt;= 0 ) &#123; if( flag ) &#123; // 如果是要到达k层，那么只有到k层才能返回1. if( remain_points == 0 &amp;&amp; now_floor == k ) return 1 ; else return 0 ; &#125; else &#123; // 如果要求小于k层，则只有这种情况才能返回1. if( remain_points == 0 &amp;&amp; now_floor &lt; k ) return 1 ; else return 0 ; &#125; &#125; int ans = 0 ; for( int i = 0 ; i &lt;= remain_points ; i++) &#123; if( i &gt; 0 &amp;&amp; remain_points - i &gt; 0 ) &#123; if( flag ) &#123; // 当flag是true时，对应上文的三种情况。 //即就是，左边true右边false，右边true，左边false，两边true的情况。 int t1 = 0 ; int t2 = 0 ; t1 += dfs( i , now_floor + 1 , true ) ; t2 += dfs( remain_points - i , now_floor + 1 , false ) ; ans += t1 * t2 ; t1 = 0 ; t2 = 0 ; t2 += dfs( remain_points - i , now_floor + 1 , true ) ; t1 += dfs( i , now_floor + 1 , false ) ; ans += t1 * t2 ; ans += dfs( i , now_floor + 1 , true ) * dfs( remain_points - i , now_floor + 1 , true ) ; &#125; else &#123; // 否则只有一种情况，就是两边都是false的情况。 ans += dfs( i , now_floor + 1 , false ) * dfs( remain_points - i , now_floor + 1 , false ) ; &#125; &#125; &#125; //printf(" dfs( %d , %d , %d ) : %d \n " , remain_points , now_floor , floor , ans ) ; return ans ; &#125;int main()&#123; freopen("nocows.in","r",stdin); freopen("nocows.out","w",stdout); cin &gt;&gt; n &gt;&gt; k ; cout &lt;&lt; dfs( n , 1 , true ) &lt;&lt; endl ; return 0 ; &#125; 这个代码的时间复杂度和上面的方法没有本质的区别。因此毫无疑问，依然是一个\(TLE\)的代码。 所以需要加上记忆化搜索。 压状态记忆化搜索(AC) 我们用dp[maxn][maxk][flag] 表示一个状态，加上记忆化搜索后。 代码如下： code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384 /*ID:xiekeyi1PROG:nocowsLANG:C++ */#include&lt;bits/stdc++.h&gt;using namespace std ;int n , k ;int dp[200][200][2];int dfs( int remain_points , int now_floor , bool flag )&#123; if( dp[remain_points][now_floor][flag] != - 1) return dp[remain_points][now_floor][flag] ; remain_points-- ; if( now_floor &gt;= k || remain_points &lt;= 0 ) &#123; if( flag ) &#123; if( remain_points == 0 &amp;&amp; now_floor == k ) return dp[remain_points + 1 ][ now_floor][flag] = 1 ; else return dp[remain_points + 1 ][now_floor][flag] = 0 ; &#125; else &#123; if( remain_points == 0 &amp;&amp; now_floor &lt; k ) return dp[remain_points+1][now_floor][flag] = 1 ; else return dp[remain_points+1][now_floor][flag] = 0 ; &#125; &#125; int ans = 0 ; for( int i = 0 ; i &lt;= remain_points ; i++) &#123; if( i &gt; 0 &amp;&amp; remain_points - i &gt; 0 ) &#123; if( flag ) &#123; int t1 = 0 ; int t2 = 0 ; t1 += dfs( i , now_floor + 1 , true ) ; t2 += dfs( remain_points - i , now_floor + 1 , false ) ; ans += ( t1 % 9901 * t2 % 9901 ) % 9901 ; t1 = 0 ; t2 = 0 ; t2 += dfs( remain_points - i , now_floor + 1 , true ) ; t1 += dfs( i , now_floor + 1 , false ) ; ans += ( t1 %9901 * t2 % 9901 ) % 9901 ; ans += dfs( i , now_floor + 1 , true ) % 9901 * dfs( remain_points - i , now_floor + 1 , true ) %9901 ; &#125; else &#123; ans += dfs( i , now_floor + 1 , false ) % 9901 * dfs( remain_points - i , now_floor + 1 , false ) % 9901 ; &#125; &#125; &#125; //printf(" dfs( %d , %d , %d ) : %d \n " , remain_points , now_floor , floor , ans ) ; return dp[remain_points+1][now_floor][flag] = ans % 9901 ; &#125;int main()&#123; freopen("nocows.in","r",stdin); freopen("nocows.out","w",stdout); memset( dp , -1 , sizeof(dp ) ) ; cin &gt;&gt; n &gt;&gt; k ; cout &lt;&lt; dfs( n , 1 , true ) % 9901 &lt;&lt; endl ; return 0 ; &#125; 成功AC。 四次方DP(AC） 考虑改写成DP形式。 用dp[i][j]表示使用\(i\)个节点，恰好构成\(j\)层的方案数。 则dp的转移方程，和上文所说的三种情况一样。枚举两维，二维转移即可。 代码： code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162 /*ID:xiekeyi1PROG:nocowsLANG:C++ */#include&lt;bits/stdc++.h&gt;using namespace std ;const int maxn = 200 + 10 , maxk = 100 + 10 ;const int modp = 9901 ;int n , k ;int dp[maxn][maxk]; // dp[i][j] means the number of schemes with points i in floor j ;int main()&#123; freopen("nocows.in","r",stdin); freopen("nocows.out","w",stdout); cin &gt;&gt; n &gt;&gt; k ; dp[1][1] = 1 ; // 边界情况，1个节点构成1层是一个方案，其他都是0. //枚举每一层。 for( int now_floor = 1 ; now_floor &lt;= k ; now_floor++) &#123; //枚举对于第now_floor层来说，用1到n个节点构造的情况。 for( int now_point = 1 ; now_point &lt;= n ; now_point++ ) &#123; //枚举对于第now_floor层，用now_point节点构造。 // 用enum_point去构造左子树，用 now_point - 1 - enum_point构造右子树。 for( int enum_point = 1 ; enum_point &lt;= now_point - 1 ; enum_point++) &#123; int less_than_nowfloor = 0 ; // 统计左子树是i-1层，右子树从 1到i- 2层的情况(对应讨论1) for( int enum_floor = 1 ; enum_floor &lt;= now_floor - 2 ; enum_floor++ ) less_than_nowfloor += dp[ now_point - 1 - enum_point ][ enum_floor ] % modp ; less_than_nowfloor %= modp ; dp[now_point][now_floor] += dp[ enum_point ][ now_floor - 1 ] % modp * less_than_nowfloor % modp ; dp[now_point][now_floor] %= modp ; // 统计左子树是1到i - 2 层，右子树是i-1层的情况(对应讨论2) less_than_nowfloor = 0 ; for( int enum_floor = 1 ; enum_floor &lt;= now_floor - 2 ; enum_floor++ ) less_than_nowfloor += dp[enum_point][enum_floor] % modp ; less_than_nowfloor %= modp ; dp[now_point][now_floor] += less_than_nowfloor % modp * dp[ now_point - 1 - enum_point][now_floor-1] % modp ; dp[now_point][now_floor] %= modp ; // 统计当两边都是i-1层的情况(对应讨论3) dp[now_point][now_floor] += dp[ enum_point][now_floor-1] % modp * dp[ now_point - 1 - enum_point][now_floor-1] % modp ; dp[now_point][now_floor] %= modp ; &#125; &#125; &#125; cout &lt;&lt; dp[n][k] % modp &lt;&lt; endl ;&#125; 三次方DP(AC) 注意到四次方DP，每次都重复计算了\(1到i-2\)层的情况。因此我们考虑可以使用数组sum[i][j]表示使用\(i\)个节点，构成的少于\(j\)层的方案数。 代码： code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455 /*ID:xiekeyi1PROG:nocowsLANG:C++ */#include&lt;bits/stdc++.h&gt;using namespace std ;const int maxn = 200 + 10 , maxk = 100 + 10 ;const int modp = 9901 ;int n , k ;int dp[maxn][maxk]; // dp[i][j] means the number of schemes with points i in floor j ;int sum[maxn][maxk]; // sum[i][j] means the number of schemes with points i less floor j ; int main()&#123; freopen("nocows.in","r",stdin); freopen("nocows.out","w",stdout); cin &gt;&gt; n &gt;&gt; k ; dp[1][1] = 1 ; for( int i = 1 ; i &lt;= k ; i++) sum[1][i] = 1 ; //枚举每一层 for( int now_floor = 1 ; now_floor &lt;= k ; now_floor++) &#123; // 枚举对于第now_floor层，使用1到n个节点去构造。 for( int now_point = 1 ; now_point &lt;= n ; now_point++ ) &#123; //枚举左子树节点个数。 for( int enum_point = 1 ; enum_point &lt;= now_point - 1 ; enum_point++) &#123; // 对应讨论1 dp[now_point][now_floor] += dp[enum_point][now_floor-1] * sum[now_point - enum_point - 1 ][ now_floor-2]; // 对应讨论2 dp[now_point][now_floor] += dp[now_point-enum_point-1][now_floor-1] * sum[enum_point][ now_floor-2]; // 对应讨论3. dp[now_point][now_floor] += dp[now_point-enum_point-1][now_floor-1] * dp[enum_point][now_floor-1]; dp[now_point][now_floor] %= modp ; &#125; // 这个方法的核心。 // 维护sum数组。 for( int j = 1 ; j &lt;= now_floor ; j++) sum[now_point][j] = ( sum[now_point][j-1] + dp[now_point][j] ) % modp ; &#125; &#125; cout &lt;&lt; dp[n][k] % modp &lt;&lt; endl ;&#125; 这个sum数组用了前缀和的思想。一开始我把sum数组放到了第三层循环里面，变成了四次方的DP。结果答案是对的，但是\(TLE\)了。(上面那个四次方DP能过大概是因为枚举的状态少一些吧。每次不一定把循环跑满了。) 因为我们把dp方程写成加和的形式，会发现: \[sum[i][nowfloor-2]=\\sum_{j=1}^{nowfloor-2}{sum[i][j]}\] 也就是说，每次更新了dp[now_point][now_floor]数组后，sum数组显然需要一同更新。 因为每次更新的时候dp的时候，now_point都是新出现的，所以这一维不需要去变化。而层数因为sum[now_point][now_floor]表示的是小于now_floor的情况，所以所有大于等于now_floor等都应该遍历去更新。这里可以利用构造前缀和的思想去操作。 （关于转移而来的状态，由代码很容易看出都是已经被计算过的) 三次方DP(AC) 看到有题解使用的方法是，用dp[i][j]表示用i个节点，构造出的小于等于j个节点的情况。然后最终答案是dp[n][k] - dp[n-1][k]。 这个方法也很巧妙。代码量极少。我认为这个方法是把我上一个方法的dp数组和sum数组结合起来而产生的dp方法。 因为复杂度和我的代码区别不是很大，加上别人的这个想法我目前理解的不是很透彻，也并非我自己独立思考得来，这道题我也想了五六天了。所以这个方法暂时没有去花时间思考和实现。有机会可能会补上。 一些优化 这道题还有一些优化部分。 如 - 注意到每层字数分配的节点肯定都是奇数个，所以可以以2递增。 - 对于每层子树，很容易计算出最大节点数。借此剪枝。]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>USACO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO-2.3.4-MoneySystems-背包]]></title>
    <url>%2Ff7932c4a.html</url>
    <content type="text"><![CDATA[(记忆化搜索 完全背包 多重背包)求方案数。 题意： 题目描述 母牛们不但创建了它们自己的政府而且选择了建立了自己的货币系统。由于它们特殊的思考方式，它们对货币的数值感到好奇。 传统地，一个货币系统是由\(1,5,10,20\)或\(25,50,\)和\(100\)的单位面值组成的。 母牛想知道有多少种不同的方法来用货币系统中的货币来构造一个确定的数值。 举例来说, 使用一个货币系统 \({1,2,5,10,...}\)产生\(18\)单位面值的一些可能的方法是: $ 18x1, 9x2, 8x2+2x1, 3x5+2+1$ ,等等其它。 写一个程序来计算有多少种方法用给定的货币系统来构造一定数量的面值。保证总数将会适合long long (C/C++) 和 Int64 (Free Pascal)，即在\(0\)到\(2^{63}-1\)之间。 输入输出格式 输入格式： 货币系统中货币的种类数目是 V ($ 1 V 25 $)。要构造的数量钱是 N (\(1 \leq N \leq10,000\))。 第一行: 二个整数，V 和 N 。 第二行： 可用的货币的面值 。 输出格式: 单独的一行包含那个可能的用这v种硬币凑足n单位货币的方案数。 输入输出样例 输入样例#1： 3 10 1 2 5 输出样例#1： 10 说明 翻译来自NOCOW USACO 2.3 做法： 一开始考虑dfs。 本来考虑的是用dfs(i)表示，当前还剩下n块钱没有组成。用下面这种方法去解决。 1234for( int i = 1 ; i &lt;= v ; i++) if( n &gt;= a[i] ) dfs( n - a[i] ) ;// 退出条件是 n == 0 不过这种方法，后来发现有点蠢。因为我无法处理比如：先选\(1\)后选\(2\) 和 先选\(2\)后选\(1\)这样的重复情况。想了一下如何去重，发现去重的话，不同情况下不一样。应该是自己走远了。 之后又感觉有点像多重背包。不过自己胡乱操作了一番，用USACO-2-2-2-subset-01背包求方案数曾经自己总结过的，感觉不错的方法来做多重背包，发现遇到了很多问题。 因为曾经的方法的不足，感觉有很多变量很多余，或者不知道用来存什么记录什么，比如dp和cnt数组就不知道存什么。 曾经的不足即：只是求方案的话，完全没必要去开dp数组，只要一个cnt其实就可以了。我现在回过头来看，感觉dp数组里存的东西很奇怪，完全没必要啊。dp[i][j]难道表示的是前\(i\)个物品装到容量为\(j\)的背包里，最大价值吗？ 感觉完全没必要了。。 这也暴露了自己的一个问题： 1. 对于问题要勤思考，不能生搬硬套。否则就会发现很多东西很模糊不确定，又因为是曾经总结过的，所以又不太敢随意修改。这有点像郑人买履了。以后要尽可能的去思考，有自己的想法，并且敢于去修改和质疑模板的问题。 2. 就算曾经总结过的东西，以后也要反复总结、提炼，不能满足于以前总结的。因为即使曾经总结过的东西，过一段时间提高后再回头看，发现依然有很多不足和问题。所以要不断总结，哪怕之前总结过。 说的有点跑题了。 后来发现那种dfs行不通以后，我考虑用dfs(n,i)表示，当前还剩下\(n\)个钱没有被表示，目前是第\(i\)枚硬币。 这样写下来的代码为： code12345678910111213141516171819 long long dfs( int n , int i )&#123; if( dp[n][i] != - 1 ) return dp[n][i] ; if( n == 0 ) return dp[n][i] = 1 ; if( i &gt; v ) return dp[n][i] = 0 ; long long ans = 0; // 枚举对于当前第i枚硬币，可以用 0 ..到 j * a[i]枚。 for( int j = 0 ; j * a[i] &lt;= n ; j++) &#123; ans += dfs( n - j * a[i] , i + 1 ) ; &#125; return dp[n][i] = ans ; &#125; 成功AC。 看到这个dfs后，感觉就是多重背包的意思啊。所以又进一步想了下如何改成多重背包。 对于多重背包来讲，用dp[i][j]表示对于i个物品，放在容积为j的背包里的方案数(这里之前的博客里就是有点问题，表达的太啰嗦了)。那么边界条件就是dp[0][0] = 1 , dp[others][others] = 0 显然只有\(0\)个物品，放在\(0\)的背包里的方案数是\(1\)，除此之外其他都是\(0\)。 转移的话，只是再加一个维度，考虑对于当前的物品可以考虑放\(0\)到$ j * a[i] n$个情况。转移即可。 1234567891011dp[0][0] = 1 ;for( int i = 1 ; i &lt;= v ; i++)&#123; for( int j = 0 ; j &lt;= n ; j++) &#123; for( int k = 0 ; k * a[i] &lt;= j ; k++) &#123; dp[i][j] += dp[i-1][j-k*a[i]] ; &#125; &#125;&#125; PS： 多重背包正常是有优化的，可以用二进制拆分后看做是01背包。 之后，对背包学艺不精的我突然发现，这其实是完全背包！多重背包是对于物品使用次数是有限制的，这个没有限制，所以应该是完全背包。 完全背包的话，正常的滚动数组的写法其实就是和01背包顺序相反而已。因为对于01背包来说，决策的状态必须对于每个物品放或者不放决策一次，不能重复。而完全背包因为物品可以随便选，决策过的可以再决策再选择一次，所以可以从曾计算过的状态再决策得来。 因为初学，所以这些都还没有使用滚动数组。不过这也导致自己在写完全背包的时候遇到了一点困难。网上的都是滚动数组优化过的，当我想写一个不优化的方便理解的时候，发现找不到代码。 1234567891011dp[0][0] = 1 ;for( int i = 1 ; i &lt;= v ; i++)&#123; for( int j = 0; j &lt;= n ; j++) &#123; if( j &gt;= a[i] ) dp[i][j] = dp[i-1][j] + dp[i][ j - a[i] ] ; else dp[i][j] = dp[i-1][j] ; &#125;&#125; 这个一开始遇到的坑是，模仿别人的滚动数组的j = a[i] .. n ，然后答案总是差一点。后来发现问题是因为对于$ j &lt; a[i]$的时候，状态应该移动过来。不然的话计算出来的状态其实是有缺失的。滚动数组的写法省了这个问题，所以自己一直没注意到。 这个主要的决策问题就是dp[i][j] = dp[i-1][j] + dp[i][ j - a[i] ]; 。 对于01背包来说，只有选或者不选两种。应该都是从上一个物品的情况转移而来，这样对于当前物品来说，只会有不选当前物品，从dp[i-1][j]转移，和选了当前物品，从dp[i-1][j-a[i]]转移，这两种情况都是没有选当前物品的，转移过来的话，也只会是没选和选。不过出现选择多个的情况。 但是因为对于完全背包来说，已经选择过的物品可以再次选择，所以我们应该是从之前已经决策过拿还是没拿的物品转移而来。对于dp[i][j-a[i]]这个状态来说，可能之前已经拿过第i个物品，也可能没拿过，但是who cares? 因为我物品是没有限制的，所以只要直接这么决策过来就可以了。 对于目前的这些知识，自己还只是雏形，理解不是很透彻。在这个阶段本文是对自己的思路进行一下简单整理和总结，便于以后提高。有错误的话十分麻烦各位能花一点点时间指出出来。 最近对DP这类问题，发现自己总是爱用记忆化搜索的方法去写。总是先想搜索，然后才能转成递推。而网上的答案和代码等几乎都是清一色的递推的方法。一开始我以为只是因为递推常数小，所以写熟练了大家都是这样直接写递推的,对于这个问题只是我自己的思维差异，不需要太重视。 后来问了一下学长，学长表示：“这个问题还是挺需要注意的，很多时候DP用递推比用记忆化要好写很多。而且递推这种思维方法其实才是DP的本质。也就是先想状态再想转移最后想边界，状态和转移有了的话，很多时候就能写递推了。”学长建议我以后思考尽量用递推，代码会比较少，也比较好调试。而且这种思维方法挺需要注意的。]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>USACO</tag>
        <tag>背包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO-2.3.1-LongestPrefix-搜索DP]]></title>
    <url>%2F2a04174f.html</url>
    <content type="text"><![CDATA[感觉自己最近对时间复杂度的计算越来越吃力了。尤其是记忆化搜索的时间复杂度。 题意： 给出N个字符串，和一个字符串S。求能由这N个字符串随意组成(可重复使用)，组成的串和S的前缀最大匹配是多长？ 做法： 开始想的就是DFS。对于S中的第i个位置来来说，枚举所有的N个字符串，那么如果可以匹配，dfs转移到 i + 所匹配的串长度即可。 不过不停的TLE( 1.7s )，一开始我以为是因为我用的vector&lt;string&gt;之类的STL的原因。于是改成C语言风格，依然不行。 于是想了一下，一开始以为是贪心的去选取最大的可匹配的，或者最长的之类的策略。可是这样的话，会过不了比如：N个字符串是ab、aaaa 和aaa 匹配字符串S aaaab的话，就不行。 类似的反例很多。 想了一下，发现可以改成记忆化。对于第i个位置来说，如果能达到，就加个标记。之后搜索到这个位置，就return即可。 这样就有效避免了，对于S很长重复很多，N个字符串有很多很短。然后第i个位置可以由前面的串好多种方法组合得到，导致反复计算。 因为，第i个串只要有一种能达到即可，一种方法还是多种，对之后的决策和选择都没有影响。这样保证了前面的串只要能达到都会只计算一种能达到的情况，并且不会重复计算。 代码: code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586 /*ID:xiekeyi1PROG:prefixLANG:C++ */#include&lt;bits/stdc++.h&gt;using namespace std ;//vector&lt;string&gt; a;//string s ; char a[210][15]; //存放n个串int num_string = 0 ; // N个串的个数int s_size = 0 ; // S的长度char s[200100]; bool vis[200100];int dfs( int n )&#123; // 标记 if( vis[n] ) return 0; else vis[n] = 1 ; int ans = 0; if( n &gt;= s_size ) return s_size; //枚举n个串 for( int i = 0 ; i &lt; num_string ; i++) &#123; bool flag = true; int tt = strlen(a[i]) ; // 匹配，如果匹配失败则换下一个串. for( int j = 0 ; j &lt; tt ; j++ ) &#123; if( s[n + j ] != a[i][j] ) &#123; flag = false ; break ; &#125; &#125; if( flag ) &#123; ans = max( ans , dfs( n + tt ) ) ; &#125; &#125; return ( ans != 0 ) ? ans : n ; // 这里我处理其实不太好，DFS写的有点蠢了。&#125;int main()&#123; freopen("prefix.in","r",stdin); freopen("prefix.out","w",stdout); char ch ; while( scanf("%s" , a[ num_string++]) ) if( strcmp( a[num_string - 1 ] , "." ) == 0 ) break ; num_string--;// string t ;// while( cin &gt;&gt; t &amp;&amp; t != "." )// a.push_back(t);// while( cin &gt;&gt; t )// s += t ; while( ( ch = getchar() ) != EOF ) &#123; if( ch == EOF ) break ; if( ch == ' ' || ch == '\n' ) continue ; s[ s_size++ ] = ch ; &#125; cout &lt;&lt; dfs(0) &lt;&lt; endl ;&#125; 由此也可以改成递推的方式。 code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152 /*ID:xiekeyi1PROG:prefixLANG:C++ */#include&lt;bits/stdc++.h&gt;using namespace std ;string s ;vector&lt;string&gt; a ;bool vis[200100];int main()&#123; string t ; while( cin &gt;&gt; t &amp;&amp; t != "." ) a.push_back(t); while( cin &gt;&gt; t ) s += t ; int ans = 0 ; for( int i = 0 ; i &lt; s.size() ; i++) &#123; if( vis[i] || i == 0 ) &#123; for( int j = 0 ; j &lt; a.size() ; j++) &#123; bool flag = true ; for( int k = 0 ; k &lt; a[j].size() ; k++) &#123; if( i + k &gt; s.size() ) &#123; flag = false ; break ; &#125; if( s[ i + k ] != a[j][k] ) &#123; flag = false ; break ; &#125; &#125; if( flag ) &#123; vis[i + a[j].size() ] = true ; ans = max( ans , static_cast&lt;int&gt; ( i + a[j].size() ) ) ; &#125; &#125; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl ; return 0 ; &#125; 我是从访问过的向没访问过的转移,似乎有人是从没访问过的去找访问过的转移。]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>DP</tag>
        <tag>USACO</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO-Chapter2-Section2.2]]></title>
    <url>%2Ffb7a8e7d.html</url>
    <content type="text"><![CDATA[USACO-Chapter2-Section2.2 2.2.1 Preface Numbering code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151 /*ID:xiekeyi1PROG:prefaceLANG:C++*/#include&lt;bits/stdc++.h&gt;using namespace std ;string func( int n , int digit )&#123; if( digit == 1 ) &#123; if( n == 1 ) return "I" ; else if( n == 2 ) return "II" ; else if ( n == 3 ) return "III" ; else if( n == 4 ) return "IV" ; else if( n == 5 ) return "V" ; else if( n == 6 ) return "VI" ; else if( n == 7 ) return "VII" ; else if ( n == 8 ) return "VIII" ; else if( n == 9 ) return "IX" ; &#125; else if( digit == 2 ) &#123; if ( n == 1 ) return "X" ; else if( n == 2 ) return "XX"; else if( n == 3 ) return "XXX"; else if ( n == 4 ) return "XL"; else if( n == 5 ) return "L"; else if( n == 6 ) return "LX" ; else if( n == 7 ) return "LXX" ; else if( n == 8 ) return "LXXX" ; else if( n == 9 ) return "XC"; &#125; else if( digit == 3 ) &#123; if( n == 1 ) return "C" ; else if( n == 2 ) return "CC"; else if( n == 3 ) return "CCC" ; else if ( n == 4 ) return "CD"; else if( n == 5 ) return "D"; else if( n == 6 ) return "DC"; else if( n == 7 ) return "DCC"; else if( n == 8 ) return "DCCC"; else if( n == 9 ) return "CM"; &#125; else if( digit == 4 ) &#123; if( n == 1 ) return "M"; else if( n == 2 ) return "MM"; else if( n == 3 ) return "MMM"; &#125; return "" ;&#125;string r_s( int n )&#123; int d = 1 ; string ans ; while( n != 0 ) &#123; ans += func( n % 10 , d ) , n /= 10 , d++ ; &#125; return ans ; &#125;int main()&#123; freopen("preface.in","r",stdin); freopen("preface.out","w",stdout); int n ; cin &gt;&gt; n ; string ans ; for( int i = 1 ; i &lt;= n ; i++) &#123; ans += r_s( i ) ; &#125; int cnt_i = 0 , cnt_v = 0 , cnt_x = 0 , cnt_l = 0 , cnt_c = 0 , cnt_d = 0 , cnt_m = 0 ; for( int i = 0 ; i &lt; ans.size() ; i++) &#123; if( ans[i] == 'I' ) cnt_i++; if( ans[i] == 'V' ) cnt_v++; if( ans[i] == 'X' ) cnt_x++; if( ans[i] =='L' ) cnt_l++; if( ans[i] == 'C' ) cnt_c++; if( ans[i] == 'D' ) cnt_d++; if( ans[i] == 'M' ) cnt_m++; &#125; if( cnt_i != 0 ) cout &lt;&lt; "I" &lt;&lt; ' ' &lt;&lt; cnt_i &lt;&lt; endl ; if( cnt_v != 0 ) cout &lt;&lt; "V" &lt;&lt; ' ' &lt;&lt; cnt_v &lt;&lt; endl ; if( cnt_x != 0 ) cout &lt;&lt; "X" &lt;&lt; ' ' &lt;&lt; cnt_x &lt;&lt; endl ; if( cnt_l != 0 ) cout &lt;&lt; "L" &lt;&lt; ' ' &lt;&lt; cnt_l &lt;&lt; endl ; if( cnt_c != 0 ) cout &lt;&lt; "C" &lt;&lt; ' ' &lt;&lt; cnt_c &lt;&lt; endl ; if( cnt_d != 0 ) cout &lt;&lt; "D" &lt;&lt; ' ' &lt;&lt; cnt_d &lt;&lt; endl ; if( cnt_m != 0 ) cout &lt;&lt; "M" &lt;&lt; ' ' &lt;&lt; cnt_m &lt;&lt; endl ; return 0 ;&#125; 2.2.2 subset 暴力(TLE) code1234567891011121314151617181920212223242526272829303132333435363738394041424344 /*ID:xiekeyi1PROG:subsetLANG:C++*/#include&lt;bits/stdc++.h&gt;using namespace std ;int all_sum = 0 ; int dfs( int n , int now_num , int now_sum)&#123; int ans = 0 ; if( now_num &lt; 1 ) return 0 ; if( now_sum &gt; (all_sum / 2) ) return 0 ; if( now_sum == all_sum - now_sum ) return 1 ; ans += dfs( n , now_num - 1 , now_sum + now_num - 1 ) + dfs( n , now_num -1 , now_sum ) ; return ans ; &#125;int main()&#123; freopen("subset.in" , "r", stdin); freopen("subset.out","w",stdout); int n ; cin &gt;&gt; n ; for( int i = 1 ; i &lt;= n ; i++) all_sum += i ; cout &lt;&lt; dfs( n , n + 1 , 0 ) / 2 &lt;&lt; endl ;&#125; 01背包求方案数 code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667 /*ID:xiekeyi1PROG:subsetLANG:C++*/#include&lt;bits/stdc++.h&gt;using namespace std ;long long solve( int n ) &#123; int all_sum = 0 ; for( int i = 1 ; i &lt;= n ; i++) all_sum += i ; if( all_sum % 2 ) return 0; int capacity = all_sum / 2 ; int dp[n + 20 ][capacity + 50 ] ; long long cnt[n + 20][capacity + 50 ] ; for( int i = 0 ; i &lt;= n ; i++) for( int j = 0 ; j &lt;= capacity ; j++) dp[i][j] = -1000 , cnt[i][j] = 0 ; ; dp[0][0] = 0 ; cnt[0][0] = 1 ; for( int i = 1 ; i &lt;= n ; i++) &#123; for( int j = 0 ; j &lt;= capacity ; j++) &#123; if( j &gt;= i ) &#123; if( dp[i-1][j] &gt; dp[i-1][ j - i ] + i ) &#123; dp[i][j] = dp[i-1][j]; cnt[i][j] = cnt[i-1][j] ; &#125; else &#123; dp[i][j] = dp[i-1][j-i] + i ; cnt[i][j] = cnt[i-1][j-i] + cnt[i-1][j] ; &#125; &#125; else dp[i][j] = dp[i-1][j] , cnt[i][j] = cnt[i-1][j] ; &#125; &#125; return cnt[n][capacity];&#125;int main()&#123; freopen("subset.in","r",stdin); freopen("subset.out","w",stdout); int n ; cin &gt;&gt; n ; cout &lt;&lt; solve(n) / 2 &lt;&lt; endl ; return 0 ;&#125; 2.2.3 runround code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788 /*ID:xiekeyi1PROG:runroundLANG:C++*/#include&lt;bits/stdc++.h&gt;using namespace std ;typedef long long ll ; bool judge( ll n )&#123; int digit = 0 ; ll t = n ; while( t != 0 ) t /= 10 , digit++; vector&lt;ll&gt; a ; int d[10] = &#123;0&#125; ; for( int i = digit - 1 ; i &gt;= 0 ; i-- ) &#123; int t = static_cast&lt;int&gt; ( ( n / pow( 10 , i ) ) ) % 10 ; if( d[t] != 0 || t == 0 ) return false ; else &#123; d[t]++; a.push_back( t ) ; &#125; &#125; int tt = 0 ; int b[15] = &#123;0&#125; ; for( int i = 1 ; i &lt;= digit ; i++) &#123; tt = ( a[ ( tt - 1 &lt; 0 ) ? ( a.size() - 1 ) : ( tt - 1 ) ] + tt ) % digit ; b[a[tt]]++; &#125; for( int i = 0 ; i &lt; a.size() ; i ++ ) &#123; if( b[ a[i] ] != 1 ) return false ; &#125; return true ;&#125;// int b[15] = &#123;0&#125; ;// int c[10] = &#123;0&#125; ; // for( int i = 0 ; i &lt; a.size() ; i++)// &#123;// b[i] = ( a[ ( i - 1 &lt; 0 ) ? (a.size() - 1 ) : ( i - 1 ) ] + i ) % digit ; // if( b[i] == i )// return false ; // else if( c[b[i]] == 0 )// c[b[i]]++;// else// return false ; // &#125;//// return true ;//&#125;int main()&#123; freopen("runround.in","r",stdin); freopen("runround.out","w",stdout); ll m ; cin &gt;&gt; m ; m++; while( true ) &#123; if( judge( m ) ) &#123; cout &lt;&lt; m &lt;&lt; endl ; return 0 ; &#125; else m++; &#125; return 0; &#125; 2.2.4 lamps code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117 /*ID:xiekeyi1PROG:lampsLANG:C++ */#include&lt;bits/stdc++.h&gt;using namespace std ;const int maxn = 110 ; int n ;int c ;vector&lt;int&gt; bright , dark ; int lamp[maxn]; int button[5];set&lt;string&gt; sq ; vector&lt;string&gt; ans ; bool flag = false ; // 01翻转操作inline void overturn( int &amp;n )&#123; if( n == 1 ) n = 0 ; else n = 1 ; return ;&#125;void dfs( int m )&#123; // 开关每一位都确定后，模拟并检测。 if( m == 5 ) &#123; int a[n+5]; fill( a , a + n + 1 , 1 ) ; &#123; // 检测对于当前的按键，是否满足c的限制.(因为作用域问题，拿大括号括起来了) int t = 0 ; for( int i = 1 ; i &lt;= 4 ; i++) if( button[i] == 1 ) t++; if( t &gt; c || ( t % 2 != c % 2 ) ) return ; &#125; // 模拟部分 if( button[1] == 1 ) for( int i = 1 ; i &lt;= n ; i++) overturn(a[i]); if( button[2] == 1 ) for( int i = 1 ; i &lt;= n ; i+=2) overturn(a[i]); if( button[3] == 1 ) for( int i = 2 ; i &lt;= n ; i+=2) overturn(a[i]); if( button[4] == 1 ) for( int i = 1 ; i &lt;= n ; i+=3) overturn(a[i]); // 检测模拟后结果是否满足条件 for( int i = 1 ; i &lt;= n ; i++) if( lamp[i] != -1 &amp;&amp; a[i] != lamp[i] ) return ; // 记录答案 string t ; for( int i = 1 ; i &lt;= n ; i++) t += a[i] + '0' ; if( sq.count(t) &lt;= 0 ) ans.push_back(t) , flag = true ; sq.insert(t); return ; &#125; // 模拟每一个开关状态 button[m] = 1 ; dfs( m + 1 ) ; button[m] = 0 ; dfs( m + 1 ) ; return ;&#125;int main()&#123; freopen("lamps.in" , "r" , stdin) ; freopen("lamps.out", "w" , stdout) ; memset( lamp , -1 , sizeof(lamp) ) ; cin &gt;&gt; n ; cin &gt;&gt; c; int t ; while( ( cin &gt;&gt; t ) &amp;&amp; t != -1 ) bright.push_back(t); while( ( cin &gt;&gt; t ) &amp;&amp; t != - 1 ) dark.push_back(t); for( int i = 0 ; i &lt; bright.size() ; i++) lamp[bright[i]] = 1 ; for( int i = 0 ; i &lt; dark.size() ; i++) lamp[dark[i]] = 0 ; dfs(1); if(!flag) cout &lt;&lt; "IMPOSSIBLE" &lt;&lt; endl ; else &#123; sort( ans.begin() , ans.end() ); for( vector&lt;string&gt; :: iterator iter = ans.begin() ; iter != ans.end() ; ++iter) cout &lt;&lt; *iter &lt;&lt; endl ; &#125; return 0 ; &#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>USACO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO-2.2.4-PartyLamps-模拟搜索]]></title>
    <url>%2F3b4b621e.html</url>
    <content type="text"><![CDATA[模拟、DFS搜索、小结论。 感觉这一章不少题，考察的是时间复杂度的计算。 题意： 给定一个N，表示N盏灯( \(10 \leq N \leq 100\) ) 。 给定操作数C( $ 0 C 10000 $ )。 四种操作： 1. 按钮1：当按下此按钮，将改变所有的灯：本来亮着的灯就熄灭，本来是关着的灯被点亮。 2. 按钮2：当按下此按钮，将改变所有奇数号的灯。 3. 按钮3：当按下此按钮，将改变所有偶数号的灯。 4. 按钮4：当按下此按钮，将改变所有序号是$ 3*K+1 (K 0) $的灯。例如：1,4,7... 一开始所有的灯都是亮着的。 给定最后灯亮暗的结果* (有部分灯未给)*，求所有灯最后的可能情况。(按字典序输出，被这个WA了一下) 做法： 一开始想到朴素做法，就是枚举每一次操作，枚举C次。那么时间复杂度是(\(O(4^c)\)) , 显然不合要求。 考虑到，对于每一种操作，不按和两次是一样的，按一次和按三次是一样的。 因此，我们只需要枚举对应每个操作，是按了还是没按就可以了。时间复杂度是(\(O(2^4)\))，考虑到还要检测和模拟，时间复杂度应该在(\(O(2^4 * n )\) )这个水平。这样也就过了。 本来想自己写个实现set&lt;string&gt;功能的，用来处理去重，不过了解了一下，似乎要用到字符串hash。暂时还没学过，遂作罢。 代码： code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117 /*ID:xiekeyi1PROG:lampsLANG:C++ */#include&lt;bits/stdc++.h&gt;using namespace std ;const int maxn = 110 ; int n ;int c ;vector&lt;int&gt; bright , dark ; int lamp[maxn]; int button[5];set&lt;string&gt; sq ; vector&lt;string&gt; ans ; bool flag = false ; // 01翻转操作inline void overturn( int &amp;n )&#123; if( n == 1 ) n = 0 ; else n = 1 ; return ;&#125;void dfs( int m )&#123; // 开关每一位都确定后，模拟并检测。 if( m == 5 ) &#123; int a[n+5]; fill( a , a + n + 1 , 1 ) ; &#123; // 检测对于当前的按键，是否满足c的限制.(因为作用域问题，拿大括号括起来了) int t = 0 ; for( int i = 1 ; i &lt;= 4 ; i++) if( button[i] == 1 ) t++; if( t &gt; c || ( t % 2 != c % 2 ) ) return ; &#125; // 模拟部分 if( button[1] == 1 ) for( int i = 1 ; i &lt;= n ; i++) overturn(a[i]); if( button[2] == 1 ) for( int i = 1 ; i &lt;= n ; i+=2) overturn(a[i]); if( button[3] == 1 ) for( int i = 2 ; i &lt;= n ; i+=2) overturn(a[i]); if( button[4] == 1 ) for( int i = 1 ; i &lt;= n ; i+=3) overturn(a[i]); // 检测模拟后结果是否满足条件 for( int i = 1 ; i &lt;= n ; i++) if( lamp[i] != -1 &amp;&amp; a[i] != lamp[i] ) return ; // 记录答案 string t ; for( int i = 1 ; i &lt;= n ; i++) t += a[i] + '0' ; if( sq.count(t) &lt;= 0 ) ans.push_back(t) , flag = true ; sq.insert(t); return ; &#125; // 模拟每一个开关状态 button[m] = 1 ; dfs( m + 1 ) ; button[m] = 0 ; dfs( m + 1 ) ; return ;&#125;int main()&#123; freopen("lamps.in" , "r" , stdin) ; freopen("lamps.out", "w" , stdout) ; memset( lamp , -1 , sizeof(lamp) ) ; cin &gt;&gt; n ; cin &gt;&gt; c; int t ; while( ( cin &gt;&gt; t ) &amp;&amp; t != -1 ) bright.push_back(t); while( ( cin &gt;&gt; t ) &amp;&amp; t != - 1 ) dark.push_back(t); for( int i = 0 ; i &lt; bright.size() ; i++) lamp[bright[i]] = 1 ; for( int i = 0 ; i &lt; dark.size() ; i++) lamp[dark[i]] = 0 ; dfs(1); if(!flag) cout &lt;&lt; "IMPOSSIBLE" &lt;&lt; endl ; else &#123; sort( ans.begin() , ans.end() ); for( vector&lt;string&gt; :: iterator iter = ans.begin() ; iter != ans.end() ; ++iter) cout &lt;&lt; *iter &lt;&lt; endl ; &#125; return 0 ; &#125; 对于这道题，看dalao说第一次做，做到这个程度就可以了。这也是nocow的官方思路。不过对于这道题，深究下去还有一些优化。 如: 对于超过6盏灯的，其实只需要看前六个就可以了。因为1和7对应、2和8对应...... (如果自身六个都不能互相对应，肯定是IMPOSSIBLE) 在luogu的P1468题解看到了闪耀星空写的一个比较深入的想法。对自己有所启发，因此转了贴在下面。 深究： 这道题如果深究的话会变得非常简单， 但是提前声明，如果对这道题兴趣不大，或者是初学者，建议跳过， 刚才的分析已经足以过这道题。 我们现在记不按按钮，以及按下1，2，3，4按钮分别O，①，②，③，④， 那么，按下3，4，可以记为③④，以此类推， 我们发现一个问题，那就是①，②，③之间微妙的关系， ①②=③，而②③=①，①③=②（可以自己试试），于是我们知道，①②③也相当与不按，即相差3的倍数也可互相转换； 所以，所谓前四个的16种按法其实只有8种， 分别为：O,①，②，③，④，①④，②④，③④； 然后讨论c， 由于当c&gt;4时，均可化为当c&lt;=4的情况， 所以我们先讨论当c&lt;=4的情况， 当c=0时，只有一种O； 当c=1时，四种：①，②，③，④； 当c=2时，除了④均可（可以自己想想）； 当c=3时，由于3-1=2，所以c=1的情况都满足，而在c=2中，把所有有前三类的展开，如①④变为②③④， 可知满足c=2的同时满足c=3，所以c=3其实是c=2和c=1的并集，即所有按法均可。 当c=4时，由于4-1=3（①②③相当于不按），且4-2=2，由上，c=4也是所有按法均可。 当c&gt;4时，我先有一个引理：对于任意的正整数n&gt;1，均可写成n=2p+3q(p,q为非负整数）的形式， 证明如下：若n为偶数，必然成立，若n为奇数，必然大于2，则n-3必为非负偶数，得证。 由这个引理我们可以知道，任意c&gt;4均可写成，c=2p+3q+3(p,q为非负整数）的形式，而可知， 对于两个相同的按键，以及情况①②③（按键三次），均相当于不按，所以任意c&gt;4均可化归为c=3的情况， 即当c&gt;4时，所有按法均可。 综上所述， 当c=0时，只有一种O； 当c=1时，四种：①，②，③，④； 当c=2时，除了④均可； 当c&gt;2时，所有按法均可。 好了，这样一来就非常简单了， 只有四种情况，8种按法。]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>USACO</tag>
        <tag>模拟</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO-2-2-3-Runaround-模拟]]></title>
    <url>%2Fab5b75.html</url>
    <content type="text"><![CDATA[感觉到这里其实到自己的瓶颈了，每一道题都要想一段时间才能做出来。 这道题挺暴力的，让我比较意外。毕竟上面刚刚一道01背包求方案数233。 不过为什么暴力能过，我还是想了挺久的。 题意: 挺难描述的，这里贴洛谷的翻译(应该是nocow翻译过来的) &gt;循环数是那些不包括0且没有重复数字的整数(比如81362)并且还应同时具有一个有趣的性质, 就像这个例子: &gt;如果你从最左边的数字开始(在这个例子中是8)向右数最左边这个数(如果数到了最右边就回到最左边),你会停止在另一个新的数字(如果停在一个相同的数字上，这个数就不是循环数).就像: 8 1 3 6 2 从最左边接下去数8个数字: 1 3 6 2 8 1 3 6 所以下一个数字是6 &gt;重复这样做 (这次从“6”开始数6个数字) 并且你会停止在一个新的数字上: 2 8 1 3 6 2, 也就是2 &gt;再这样做 (这次数两个): 8 1 &gt;再一次 (这次一个): 3 &gt;又一次: 6 2 8 这时你回到了起点,在经过每个数字一次后回到起点的就是循环数。如果你经过每一个数字一次以后没有回到起点, 你的数字不是一个循环数。 &gt;给你一个数字 M (在1到9位之间), 找出第一个比 M大的循环数, 输出数据保证结果能用一个无符号长整型数（21亿）装下。 &gt;（追加提醒：循环数每个数位都必须要访问到） 一开始想了下暴力。 然后如何判断一开始觉得直接模拟太麻烦了，于是考虑了一下。 错误的以为，是对每位数都执行这样的操作，然后计算出来操作后得到的下标。只要下标互不重复，也就表示是循环数了。 于是进一步想过后得到，对于第\(i\)个数而言，只要$ ( i + a_{i-1} ) % n $ 各不相同(应该算是一个完全剩余系？)，就可以了。 于是只要注意( i - 1 &lt; 0 ) ? ( a.size() - 1 ) : ( i - 1 ) 就可以了。 虽然在当时很快想到了这个如何去检测一个数字是否是循环数的比较好写的写法，但是一直有一个问题困扰着我。 就是答案中暗示可能数据有\(2e9\)那么大，那么会不会出现连续\(1e9\)个数字里都找不到满足条件的数导致超时？ 想了很久，没什么头绪。 只是想的是，如果遍历\(1e5\)，大概有6位就会被遍历了，改变对于9位数来说也有不少了，那么会不会出现不了这种情况呢？ 因为不会证明。 于是就按这个想法交了一发。 发现WA了。 WA的数据是\(738192\). 如果按题目中要求，会是一个不停在7和1中循环的数列，无法遍历到其他数中。但是按照我的想法，却会是成立的。 于是最后还是得暴力模拟。 模拟主要方法就是，有多少位模拟多少次， 然后最后在统计一下有没有重复出现过的下标或者没出现过的下标即可。 提交后，竟然A了。 事后发现自己想多了。 这道题时间复杂度应该是 \(O(9!)\) ， 因为是各不相同且没有\(0\)的数字，所以应该去生成全排列。而不是逐一枚举。 逐一枚举的话，时间复杂度就是玄学了。 代码： code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071 /*ID:xiekeyi1PROG:runroundLANG:C++*/#include&lt;bits/stdc++.h&gt;using namespace std ;typedef long long ll ; bool judge( ll n )&#123; int digit = 0 ; ll t = n ; while( t != 0 ) t /= 10 , digit++; // 计算位数 vector&lt;ll&gt; a ; // 计算是否有重复和和0 int d[10] = &#123;0&#125; ; for( int i = digit - 1 ; i &gt;= 0 ; i-- ) &#123; int t = static_cast&lt;int&gt; ( ( n / pow( 10 , i ) ) ) % 10 ; if( d[t] != 0 || t == 0 ) return false ; else &#123; d[t]++; a.push_back( t ) ; &#125; &#125; // 模拟 int tt = 0 ; int b[15] = &#123;0&#125; ; for( int i = 1 ; i &lt;= digit ; i++) &#123; tt = ( a[ ( tt - 1 &lt; 0 ) ? ( a.size() - 1 ) : ( tt - 1 ) ] + tt ) % digit ; b[a[tt]]++; &#125; for( int i = 0 ; i &lt; a.size() ; i ++ ) &#123; if( b[ a[i] ] != 1 ) return false ; &#125; return true ;&#125;int main()&#123; freopen("runround.in","r",stdin); freopen("runround.out","w",stdout); ll m ; cin &gt;&gt; m ; m++; while( true ) &#123; if( judge( m ) ) &#123; cout &lt;&lt; m &lt;&lt; endl ; return 0 ; &#125; else m++; &#125; return 0; &#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO 2.2.2 subset 01背包求方案数]]></title>
    <url>%2F42aa9afc.html</url>
    <content type="text"><![CDATA[题意: 给定一个N( N \(\leq\) 39)，表示有 1 - n 个数。每个数只能选一次，要求你将这N个数分成和相等的两部分。问有多少种分法？ 做法： 一开始第一反应是DFS。 对于每一个数字有选和不选两种方案。然后DFS下去就可以了。 后来发现N是39。一开始考虑是不是要折半搜索，或者花式剪枝。 一开始写了一个花式剪枝，剪枝策略是： 对于总和是奇数的直接返回0(不可能拆成和相等的两部分)。 从大到小选取，当目前选取的和已经超过了总和的一半的时候，直接return 。 依然会T。于是就想折半搜索。想了一会没什么思绪。 在想如何去把这个DFS写成记忆化搜索的过程中，突然发现这不就是个背包嘛。(果然有人曾说的，DP写不好的时候，先想搜索，然后从搜索想如何写成记忆化搜索，在这过程中想出DP的状态转移，是很不错的方法。) 本质上来讲，这道题就是N个物品\(a\_{i}\) ， 每个物品的重量是i(即它本身)。问恰好能装满容积为\(\frac{\sum\_{i=1}^n{a\_i}}{2}\) 的背包的** 方案数**吗？* (注意这里答案应该是最终答案除以2，因为有重复计算的关系)* 朴素的01背包很简单 定义dp[i][j]表示一共有i个物品，背包最大容量为j，所能装的物品的最大价值。 12345678for( int i = 1 ; i &lt;= N ; i++) for( int j = 1 ; j &lt;= capacity ; j++) &#123; if( j &gt;= weight[i] ) dp[i][j] = max( dp[i-1][j] , dp[i-1][j - weight[i]] + value[i] ) ; else dp[i][j] = dp[i-1][j] ; &#125; 注意一下dp数组都初始化为0，以及很多教材中提到的都是第二个循环从 j == weight[i] 开始的。但是实际上之前的dp数组也要转移过来。 ** 另可用滚动数组优化，空间复杂度减去一维** 如果是要求，恰好装满背包的话，那么我们应该注意除了dp[0][0]初始化为0，其他都应该初始化为\(-inf\)。 我们可以通过搜索去考虑。如果是搜索的话，除了dp[0][0]是return 0 ，其他应该是没有装满都返回\(-inf\)。而在DP中，因为是要取max的，所以就初始化为-inf就可以了。 01背包求方案数 我主要是在这里卡了一段时间。 曾经在学习Dijkstra的过程中，遇到需要记录路径问题的时候。被人告知: ** dp的时候需要记录路径、决策之类的，直接再开一个和dp数组结构基本一样的数组去记录就可以了。** 这个思想对我帮助很大。记录这些信息，本质上其实就是记录决策。决策的记录方式，映射下来，不就是和dp数组结构一样吗？ 于是这道题我开了cnt[n][capacity] 这样一个数组去记录。(有的人选择在DP数组中再加一个维度去记录，本质上是一样的) 也就是定义cnt[i][j] 表示i个物品，(恰好)放在容量为j的背包中的方案数。 不过在实际写的过程中，发现还有一些小问题要处理。 就是在转移的过程中，这个cnt数组，如何转移？ 我们观察到dp数组的转移主要是 1234if( dp[i-1][j] &gt; dp[i-1][ j - weight[i] ] + value[i] ) dp[i][j] = dp[i-1][j] ;else dp[i][j] = dp[i-1][j - weight[i] ] + value[i] ; cnt数组显然要在dp转移的过程中转移。 12345if( dp[i-1][j] &gt; dp[i-1][ j - weight[i] ] + value[i] ) dp[i][j] = dp[i-1][j] , cnt[i][j] = cnt[i-1][j] ;else dp[i][j] = dp[i-1][j - weight[i] ] + value[i] , cnt[i][j] = cnt[i-1][j - weight[i] ] + cnt[i-1][j]; 转移过程大概如上。 对于dp[i][j]由dp[i-1][j] 转移而来的时候，显然dp[i][j]对应的方案数没有变化，可以直接继承cnt[i-1][j]过来。 对于dp[i][j]由dp[i-1][j - weight[i] ] + value[i] 转移时。 一开始我想的是等于cnt[i-1][j-weight[i]] + 1 后来发现计算出来的远远小于答案。 毕竟这是组合问题，直接加1的话，差的太远了。 然后网上查了一下，发现别人的转移如上所示。 一开始我以为是指i个物品放入容量为j的背包的方案数，可以 由i-1个物品放入j的背包里的方案数和i-1个物品放入j-i的方案数相加而来。然后怎么想都觉得怪怪的，如何按这个想法的话，不应该是由i-1个物品放入i的背包里的方案数和j-i的方案数相加而来才可以吗？ 于是私自改了一下这个地方。但是改了后也还是不能理解，因为这样如何避免重复计算呢？ 因此卡了一段时间。 卡了一段时间后，想明白了，这不就是组合数递推的公式吗: \[ C\_n^m = C\_{n-1}^m + C\_{n-1}^{m-1} \] 这个公式的理解是，对于n个物品取m个，可以由n-1个物品直接取m个得来(也就是新加的物品不取)，也可以由n-1个物品取m-1个物品，然后加上新增的这个物品得来。 那么，这个cnt[i][j]的转移方法，不就可以看做是由前i-1个物品直接取了j个容量的方案数得来加上由前i-1个物品中取j - weight[i]容量的物品再加上当前的这个重量为weight[i]的物品得来吗？ 借此做完了这道题。 虽然理解了，但是目前在转移过程中，还是常常按自己的想法写成 j - i 和 i 。 因为卡了一段时间，所以写下来整理一下自己思路。 代码： code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768 /*ID:xiekeyi1PROG:subsetLANG:C++ */#include&lt;bits/stdc++.h&gt;using namespace std ;long long solve( int n ) &#123; int all_sum = 0 ; for( int i = 1 ; i &lt;= n ; i++) all_sum += i ; if( all_sum % 2 ) return 0; int capacity = all_sum / 2 ; int dp[n + 20 ][capacity + 50 ] ; long long cnt[n + 20][capacity + 50 ] ; for( int i = 0 ; i &lt;= n ; i++) for( int j = 0 ; j &lt;= capacity ; j++) dp[i][j] = -1000 , cnt[i][j] = 0 ; ; dp[0][0] = 0 ; cnt[0][0] = 1 ; for( int i = 1 ; i &lt;= n ; i++) &#123; for( int j = 0 ; j &lt;= capacity ; j++) &#123; if( j &gt;= i ) &#123; if( dp[i-1][j] &gt; dp[i-1][ j - i ] + i ) &#123; dp[i][j] = dp[i-1][j]; cnt[i][j] = cnt[i-1][j] ; &#125; else &#123; dp[i][j] = dp[i-1][j-i] + i ; cnt[i][j] = cnt[i-1][j-i] + cnt[i-1][j] ; &#125; &#125; else dp[i][j] = dp[i-1][j] , cnt[i][j] = cnt[i-1][j] ; &#125; &#125; return cnt[n][capacity];&#125;int main()&#123; freopen("subset.in","r",stdin); freopen("subset.out","w",stdout); int n ; cin &gt;&gt; n ; cout &lt;&lt; solve(n) / 2 &lt;&lt; endl ; return 0 ;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>USACO</tag>
        <tag>背包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO-Chapter2-Section2.1]]></title>
    <url>%2F6273dfc7.html</url>
    <content type="text"><![CDATA[USACO-Chapter2-Section2.1 1castle code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990 /*ID:xiekeyi1PROG:castleLANG:C++*/#include&lt;bits/stdc++.h&gt;using namespace std ;const int maxn = 55;int graph[maxn][maxn][5];int roomsize[maxn*maxn] ;int vis[maxn][maxn];int m , n , color , maxsize ; int dx[] = &#123; 1 , 0 , -1 , 0 &#125; ;int dy[] = &#123; 0 , 1 , 0 , -1 &#125;;int nowsize ; int ans_row , ans_col ; char dir ; void scan()&#123; cin &gt;&gt; m &gt;&gt; n ; for( int i = 1 ; i &lt;= n ; i++) for( int j = 1 ; j &lt;= m ; j++) &#123; int t ; cin &gt;&gt; t ; for( int k = 3 ; k &gt;= 0 ; k--) graph[i][j][k] = t % 2 , t = t &gt;&gt; 1 ; &#125;&#125;void floodfill( int x , int y )&#123; vis[x][y] = true ; roomsize[color]++; graph[x][y][4] = color ; for( int i = 0 ; i &lt; 4 ; i++) &#123; int nx = x + dx[i] ; int ny = y + dy[i]; if( nx &lt; 1 || ny &lt; 1 || nx &gt; n || ny &gt; m ) continue ; if( vis[nx][ny] || graph[x][y][i] ) continue ; floodfill(nx,ny); &#125;&#125;void merge( int x , int y )&#123; int sum = 0 ; if( x &gt;= 2 &amp;&amp; graph[x-1][y][4] != graph[x][y][4] ) &#123; sum = roomsize[ graph[x-1][y][4] ] + roomsize[ graph[x][y][4] ] ; if( sum &gt; maxsize) maxsize=sum,ans_row=x,ans_col=y,dir='N' ; &#125; if( y &lt; m &amp;&amp; graph[x][y+1][4] != graph[x][y][4] ) &#123; sum = roomsize[ graph[x][y+1][4] ] + roomsize[ graph[x][y][4] ] ; if( sum &gt; maxsize ) maxsize = sum , ans_row = x , ans_col = y , dir = 'E' ; &#125;&#125;int main()&#123; freopen("castle.in","r",stdin); freopen("castle.out","w",stdout); scan(); for( int i = 1 ; i &lt;= n ; i++) for( int j = 1 ; j &lt;= m ; j++) &#123; if( !vis[i][j] ) &#123; roomsize[ color ] = 0 ; floodfill( i , j ); color++; &#125; &#125; for( int i = 0 ; i &lt; color ; i++) nowsize = max( nowsize , roomsize[ i ] ) ; for( int i = 1 ; i &lt;= m ; i++) for( int j = n ; j &gt;= 1 ; j--) merge(j,i); cout &lt;&lt; color &lt;&lt; endl &lt;&lt; nowsize &lt;&lt; endl &lt;&lt; maxsize &lt;&lt; endl &lt;&lt; ans_row &lt;&lt; ' ' &lt;&lt; ans_col &lt;&lt; ' ' &lt;&lt; dir &lt;&lt; endl ; return 0 ;&#125; 2frac1 code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 /*ID:xiekeyi1PROG:frac1LANG:C++*/#include&lt;bits/stdc++.h&gt;using namespace std ;const int maxn = 170 ; struct node&#123; int fenzi , fenmu ; long double value ;&#125;x[maxn*maxn];bool operator &lt; ( struct node a , struct node b ) &#123; return a.value &lt; b.value ;&#125;int gcd( int a , int b )&#123; if( b == 0 ) return a ; if( a == 0 ) return b ; else return gcd( b , a % b ) ;&#125;int main()&#123; freopen("frac1.in","r",stdin); freopen("frac1.out","w",stdout); int n ; cin &gt;&gt; n ; int cnt = 0 ; for( int i = 0 ; i &lt;= n ; i++) for( int j = 1 ; j &lt;= n ; j++) if( gcd( i , j ) == 1 &amp;&amp; ( (i+0.0) / j ) &lt;= 1 ) x[cnt].fenzi = i , x[cnt].fenmu = j , x[cnt].value = (x[cnt].fenzi + 0.0) / x[cnt].fenmu , cnt++; sort(x,x+cnt); for( int i = 0 ; i &lt; cnt ; i++) printf("%d/%d\n",x[i].fenzi,x[i].fenmu); return 0 ; &#125; 3sort3 code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 /*ID:xiekeyi1PROG:sort3LANG:C++*/#include&lt;bits/stdc++.h&gt;using namespace std ;const int maxn = 1010 ;int a[maxn] , b[maxn];int c[5][5] ;int main()&#123; freopen("sort3.in","r",stdin); freopen("sort3.out","w",stdout); int n ; cin &gt;&gt; n ; for( int i = 1 ; i &lt;= n ; i++) &#123; cin &gt;&gt; a[i] ; b[i] = a[i] ; &#125; sort( b+1 , b+1+n ) ; for( int i = 1 ; i &lt;= n ; i++) if( a[i] != b[i] ) c[ b[i] ][ a[i] ]++; int ans = 0 ; for( int i = 1 ; i &lt;= 3 ; i++) &#123; for( int j = 1 ; j &lt;= 3 ;j++) &#123; if( c[i][j] &amp;&amp; c[j][i] ) &#123; int t = min( c[i][j] , c[j][i] ); c[i][j] -= t , c[j][i] -=t , ans+=t ; &#125; &#125; &#125; ans+= c[1][2] * 2 ; ans+= c[1][3] * 2 ; cout &lt;&lt; ans &lt;&lt; endl ; return 0 ; &#125; 4holstein code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374 /*ID:xiekeyi1PROG:holsteinLANG:C++*/#include&lt;bits/stdc++.h&gt;using namespace std ;const int maxn = 30 ; int v , vv[maxn] , g , gg[maxn][maxn];void init()&#123; cin &gt;&gt; v ; for( int i = 1 ; i &lt;= v ; i++) cin &gt;&gt; vv[i]; cin &gt;&gt; g ; for( int i = 1 ; i &lt;= g ; i++) for( int j = 1 ; j &lt;= v ; j++) cin &gt;&gt; gg[i][j];&#125;bool flag = false ;int num[maxn];int cnt = 0 ;int k = 1 ; void work() &#123; int a[30] = &#123;0&#125;; for( int i = 1 ; i &lt;= cnt ; i++) for( int j = 1 ; j &lt;= v ; j++) a[j] += gg[ num[i] ][j] ; for( int i = 1 ; i &lt;= v ; i++) if( a[i] &lt; vv[i] ) return ; flag = true ; cout &lt;&lt; cnt ; for( int i = 1 ; i &lt;= cnt ; i++) cout &lt;&lt; ' ' &lt;&lt; num[i] ; cout &lt;&lt; endl ;&#125;void dfs( int t )&#123; if( flag || t &gt; g ) return ; if( cnt &gt;= k ) &#123; work() ; return ; &#125; cnt++; num[cnt] = t + 1 ; dfs( t + 1 ) ; cnt--; dfs( t + 1 ) ; return ; &#125;int main()&#123; freopen("holstein.in","r",stdin); freopen("holstein.out","w",stdout); init() ; while( !flag ) &#123; dfs(0); k++; &#125; return 0 ; &#125; 5hamming code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889 /*ID:xiekeyi1PROG:hammingLANG:C++ */#include&lt;bits/stdc++.h&gt;using namespace std ;bool judge( int b , int n , int d , int aj)&#123; bitset&lt;8&gt; judge( n ^ aj ) ; int t1 = 0 , t2 = 0 ; for( int i = 0 ; i &lt; b ; i++) if( judge.test( i ) ) t1++; if( t1 &lt; d ) return false ; // judge.flip(); // for( int i = 0 ; i &lt; b ; i++) // if( judge.test( i ) ) // t2++; // if( t1 &lt; d &amp;&amp; t2 &lt; d ) // return false ; return true ; // int t1 = judge.count(); // judge.flip(); // int t2 = judge.count(); // if( t1 != d &amp;&amp; t2 != d ) // return false ; // return true ; &#125;int main()&#123; freopen("hamming.in","r",stdin); freopen("hamming.out","w",stdout); int n , b , d ; cin &gt;&gt; n &gt;&gt; b &gt;&gt; d ; int cnt = 0 ; vector&lt;int&gt; a; a.push_back(0); int i = 0 ; while( a.size() != n) &#123; for( ; i &lt;= 300; ) &#123; i++; //cout &lt;&lt; "Debug: " &lt;&lt; i &lt;&lt; endl ; bool flag = true ; for( int j = 0 ; j &lt; a.size() ; j++) &#123; //bitset&lt;8&gt; judge( i ^ a[j] ) ; if( !judge( b, i , d , a[j] ) ) &#123; flag = false ; break ; &#125; &#125; if( flag ) &#123; a.push_back(i) ; //cout &lt;&lt; "Debug:" &lt;&lt; i &lt;&lt; endl ; break ; &#125; &#125; &#125; int tcnt = 0 ; for( int i = 0 ; i &lt; a.size() ; i++) &#123; ++tcnt; if( tcnt == 1 ) cout &lt;&lt; a[i] ; else if( tcnt != 10 ) cout &lt;&lt; ' ' &lt;&lt; a[i] ; else if( tcnt == 10 ) &#123; tcnt = 0 ; cout &lt;&lt; ' ' &lt;&lt; a[i] &lt;&lt; endl ; &#125; &#125; if( tcnt != 0 ) cout &lt;&lt; endl ; return 0 ; &#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>USACO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO-Chapter1-Section1.5]]></title>
    <url>%2F10c67777.html</url>
    <content type="text"><![CDATA[1numtri code12345678910111213141516171819202122232425262728293031323334353637383940 /*ID:xiekeyi1PROG:numtriLANG:C++*/#include&lt;bits/stdc++.h&gt;using namespace std ;const int maxn = 1000 + 10 ;// ′óé?íù??int data[maxn][maxn] , dp[maxn][maxn];int main()&#123; freopen("numtri.in","r",stdin); freopen("numtri.out","w",stdout); int n ; cin &gt;&gt; n ; for( int i = 1 ; i &lt;= n ; i++) for( int j = 1 ; j &lt;= i ; j++) cin &gt;&gt; data[i][j] ; dp[1][1] = data[1][1] ; for( int i = 2 ; i &lt;= n ; i++) &#123; for( int j = 1 ; j &lt;= i ; j++) &#123; dp[i][j] = max(dp[i-1][j-1] , dp[i-1][j] ) + data[i][j] ; //注意边界问题 &#125; &#125; int ans = 0 ; for( int i = 1 ; i &lt;= n ; i++) ans = max( dp[n][i] , ans ) ; cout &lt;&lt; ans &lt;&lt; endl ; return 0 ;&#125; 2pprime code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178 /*ID:xiekeyi1PROG:pprimeLANG:C++*/#include&lt;bits/stdc++.h&gt;using namespace std ;bool isprime( int n )&#123; if( n == 0 || n == 1 ) return false ; if( n == 2 ) return true ; int sqrt_n = sqrt(n) ; for( int i = 2 ; i &lt;= sqrt_n ; i++) if( n % i == 0 ) return false ; return true ; &#125;int digit( int n )&#123; int d = 0 ; while( n != 0 ) n/=10 , d++; return d ; &#125;void f( int a , int b , int n )&#123; if( n &gt;= a &amp;&amp; n &lt;= b &amp;&amp; isprime( n ) ) cout &lt;&lt; n &lt;&lt; endl ; return ; &#125;void func( int a , int b , int dd1 , int dd2)&#123; int palindrom = 0; for( int i = dd1 ; i &lt;= dd2; i++) &#123; if( i == 1 ) &#123; for( int d1 = 0 ; d1 &lt;= 9 ; d1++) &#123; palindrom = d1 ; f(a,b,palindrom) ; &#125; &#125; else if ( i == 2 ) &#123; for( int d1 = 1 ; d1 &lt;= 9 ; d1++) &#123; palindrom = 1e1 * d1 + 1e0 * d1 ; f(a,b,palindrom); &#125; &#125; else if( i == 3 ) &#123; for( int d1 = 1 ; d1 &lt;= 9 ; d1++) &#123; for( int d2 = 0 ; d2 &lt;= 9 ; d2++) &#123; palindrom = 1e2 * d1 + 1e1 * d2 + d1 ; f(a,b,palindrom); &#125; &#125; &#125; else if( i == 4 ) &#123; for( int d1 = 1 ; d1 &lt;= 9 ; d1++) &#123; for( int d2 = 0 ; d2 &lt;= 9 ; d2++) &#123; palindrom = 1e3 * d1 + 1e2 * d2 + 1e1 * d2 + 1e0 * d1 ; f(a,b,palindrom) ; &#125; &#125; &#125; else if( i == 5 ) &#123; for( int d1 = 1 ; d1 &lt;= 9 ; d1++) &#123; for( int d2 = 0 ; d2 &lt;= 9 ; d2++ ) &#123; for( int d3 = 0 ; d3 &lt;= 9 ; d3++) &#123; palindrom = 1e4 * d1 + 1e3 * d2 + 1e2 * d3 + 1e1 * d2 + 1e0 * d1 ; f(a,b,palindrom) ; &#125; &#125; &#125; &#125; else if( i == 6 ) &#123; for( int d1 = 1 ; d1 &lt;= 9 ; d1++) &#123; for( int d2 = 0 ; d2 &lt;= 9 ; d2++) &#123; for( int d3 = 0 ; d3 &lt;= 9 ; d3++) &#123; palindrom = 1e5 * d1 + 1e4 * d2 + 1e3 * d3 + 1e2 * d3 + 1e1 * d2 + 1e0 * d1 ; f(a,b,palindrom); &#125; &#125; &#125; &#125; else if( i == 7 ) &#123; for( int d1 = 1 ; d1 &lt;= 9 ; d1++) &#123; for( int d2 = 0 ; d2 &lt;= 9 ; d2++) &#123; for( int d3 = 0 ; d3 &lt;= 9 ; d3++) &#123; for( int d4 = 0 ; d4 &lt;= 9 ; d4++) &#123; palindrom = 1e6 * d1 + 1e5 * d2 + 1e4 * d3 + 1e3 * d4 + 1e2 * d3 + 1e1 * d2 + 1e0 * d1 ; f(a,b,palindrom); &#125; &#125; &#125; &#125; &#125; else if( i == 8 ) &#123; for( int d1 = 1 ; d1 &lt;= 9 ; d1++) for( int d2 = 0 ; d2 &lt;= 9 ; d2++) for( int d3 = 0 ; d3 &lt;= 9 ; d3++) for( int d4 = 0 ; d4 &lt;=9 ; d4++) &#123; palindrom = 1e7 * d1 + 1e6 * d2 + 1e5 * d3 + 1e4 * d4 + 1e3 * d4 + 1e2 * d3 + 1e1 * d2 + 1e0 * d1 ; f(a,b,palindrom); &#125; &#125; else if( i == 9 ) &#123; for( int d1 = 1 ; d1 &lt;= 9 ; d1++) for( int d2 = 0 ; d2 &lt;= 9 ; d2++) for( int d3 = 0 ; d3 &lt;=9 ; d3++ ) for( int d4 = 0 ; d4 &lt;= 9 ; d4++) for( int d5 = 0 ; d5 &lt;= 9 ; d5++) &#123; palindrom = 1e8 * d1 + 1e7 * d2 + 1e6 * d3 + 1e5 * d4 + 1e4 * d5 + 1e3 * d4 + 1e2 * d3 + 1e1 * d2 + 1e0 * d1 ; f(a,b,palindrom); &#125; &#125; &#125; return ; &#125; int main()&#123; freopen("pprime.in","r",stdin); freopen("pprime.out","w",stdout); int a , b ; cin &gt;&gt; a &gt;&gt; b ; int d1 = digit(a) , d2 = digit(b) ; func( a , b , d1 , d2 ) ; return 0 ;&#125; 3sprime code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556 /*ID:xiekeyi1PROG:sprimeLANG:C++*/#include&lt;bits/stdc++.h&gt;using namespace std ;int ans = 0 ; bool isprime( int n )&#123; if( n == 0 || n == 1 ) return false ; if( n == 2 ) return true ; for( int i = 2 ; i &lt;= sqrt(n) ; i++) if( n % i == 0 ) return false ; return true ;&#125;void dfs( int n )&#123; if( n == 0 ) &#123; cout &lt;&lt; ans &lt;&lt; endl ; &#125; for( int i = 1 ; i &lt;= 9 ; i++) &#123; int t = ans ; ans = i + ans * 10 ; if( isprime ( ans ) ) dfs( n - 1 ) ; ans = t ; &#125;&#125; int main()&#123; freopen("sprime.in","r",stdin); freopen("sprime.out","w",stdout); int n ; cin &gt;&gt; n ; ans = 0 ; dfs(n) ; return 0 ;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>USACO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO-Chapter1-Section1.4]]></title>
    <url>%2F67c147e1.html</url>
    <content type="text"><![CDATA[1ariprog code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879 /*ID:xiekeyi1PROG:ariprogLANG:C++ */#include&lt;bits/stdc++.h&gt;using namespace std ;const int maxn = 250 * 250 * 2 ; bool a[maxn + 10 ] ; void init( int m )&#123; memset( a , false , sizeof(a) ) ; for( int i = 0 ; i &lt;= m ; i++) for( int j = i ; j &lt;= m ; j++) a[ i*i + j*j ] = true ; return ; &#125;struct node&#123; int a , b ; node( int _a , int _b) : a(_a) , b(_b) &#123;&#125; &#125;;vector&lt;node&gt; ans ; bool cmp( struct node a , struct node b )&#123; if( a.b &lt; b.b ) return true ; else if( a.b == b.b ) return a.a &lt; b.a ; else return false ;&#125;int main()&#123; freopen("ariprog.in","r",stdin); freopen("ariprog.out","w",stdout); int n , m; cin &gt;&gt; n &gt;&gt; m ; init(m) ; int d = 1 ; int maxx = m*m + m*m ; bool flag = false ; while( ( n - 1 ) * d &lt;= maxx) &#123; for( int i = 0 ; i &lt;= maxx - ( n - 1 ) * d ; i++) &#123; bool f = true ; for( int j = i ; j &lt;= i + ( n - 1 ) * d ; j +=d ) &#123; if( a[j] == false ) &#123; f = false ; break ; &#125; &#125; if( f ) &#123; ans.push_back( node(i,d) ) ; flag = true ; &#125; &#125; d++ ; &#125; sort( ans.begin() , ans.end() , cmp ) ; if( flag ) for( vector&lt;node&gt; :: iterator iter = ans.begin() ; iter != ans.end() ; iter++) cout &lt;&lt; iter-&gt;a &lt;&lt; ' ' &lt;&lt; iter-&gt;b &lt;&lt; endl ; else cout &lt;&lt; "NONE" &lt;&lt; endl ; return 0 ; &#125; 2milk3 code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273 /*ID:xiekeyi1PROG:milk3LANG:C++*/#include&lt;bits/stdc++.h&gt;using namespace std ;const int maxn =25;bool vis[maxn][maxn];bool note[maxn];int aa[4];void dfs( int a , int b , int c )&#123; if( vis[a][b] ) return ; vis[a][b] = true ; if( a == 0 ) note[c] = true ; int temp[4]; temp[1] = a , temp[2] = b , temp[3] = c ; for( int i = 1 ; i &lt;= 3 ; i++) &#123; for( int j = 1 ; j &lt;= 3 ; j++) &#123; if( i != j ) &#123; if( temp[i] != 0 &amp;&amp; temp[j] &lt; aa[j] ) &#123; if( temp[i] &lt;= aa[j] - temp[j] ) &#123; int t1 = temp[i] , t2 = temp[j] ; temp[j] += temp[i] ; temp[i] = 0 ; dfs( temp[1] ,temp[2] , temp[3]); temp[i] = t1 , temp[j] = t2 ; &#125; if( temp[i] &gt; aa[j] - temp[j] ) &#123; int t1= temp[i] , t2 = temp[j] ; temp[i] -= aa[j] - temp[j] ; temp[j] = aa[j] ; dfs( temp[1] , temp[2] , temp[3]); temp[i] = t1 , temp[j] = t2 ; &#125; &#125; &#125; &#125; &#125;&#125;int main()&#123; freopen("milk3.in","r",stdin); freopen("milk3.out","w",stdout); cin &gt;&gt; aa[1] &gt;&gt; aa[2] &gt;&gt; aa[3] ; dfs( 0,0,aa[3]) ; for( int i = 0 ; i &lt;= aa[3] - 1 ; i++) &#123; if( note[i] ) cout &lt;&lt; i &lt;&lt; ' ' ; &#125; cout &lt;&lt; aa[3] &lt;&lt; endl ; return 0 ; &#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>USACO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO-Chapter1-Section1.3]]></title>
    <url>%2Ff9a5d242.html</url>
    <content type="text"><![CDATA[1milk code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758 /*ID:xiekeyi1PROG:milkLANG:C++ */#include&lt;bits/stdc++.h&gt;using namespace std ;const int maxm = 5050 ; struct P&#123; int price ; int amount ;&#125;a[maxm];bool cmp( struct P a , struct P b )&#123; return ( a.price &lt; b.price ) ;&#125;int main()&#123; freopen("milk.in","r",stdin); freopen("milk.out","w",stdout); ios::sync_with_stdio(false); cin.tie(false) ; int n ; int m ; cin &gt;&gt; n &gt;&gt; m ; for( int i = 1 ; i &lt;= m ; i++) cin &gt;&gt; a[i].price &gt;&gt; a[i].amount ; sort(a+1,a+1+m,cmp); int ans = 0 ; int cnt = 1 ; while( n != 0 ) &#123; if( a[cnt].amount &lt;= n ) &#123; n -= a[cnt].amount; ans += a[cnt].amount * a[cnt].price; a[cnt].amount = 0 ; &#125; else &#123; ans+= n * a[cnt].price ; a[cnt].amount -= n ; n = 0 ; &#125; cnt++; &#125; cout &lt;&lt; ans &lt;&lt; endl ; return 0 ; &#125; 2barn1 code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374 /*ID:xiekeyi1PROG:barn1LANG:C++ */#include&lt;bits/stdc++.h&gt;using namespace std ; int a[210]; int maxr = 0 ; int minl = 999 ; void filling( int l , int r )&#123; for( int i = l ; i &lt;= r ; i++ ) a[i] = 3 ; &#125;int func()&#123; int l = 0 , r = 0 ; int cnt = 0 ; for( int i = minl ; i &lt;= maxr ; i++) &#123; if( a[i] != 0 ) continue ; int temp = 1 ; int j ; for( j = i + 1 ; j &lt;= maxr ; j++) &#123; if( a[j] == 0 ) temp++; else break ; &#125; if( temp &gt;= ( r - l + 1 ) ) l = i , r = j - 1 , cnt = temp ; ; &#125; filling( l , r ) ; return cnt ; &#125;int main()&#123; freopen("barn1.in","r",stdin); freopen("barn1.out","w",stdout); int m , s , c ; cin &gt;&gt; m &gt;&gt; s &gt;&gt; c ; memset( a , 0 , sizeof(a) ) ; int ans = 0 , mm = 1 ; for( int i = 1 ; i &lt;= c ; i++) &#123; int t ; cin &gt;&gt; t ; a[t] = 1 ; maxr = max( t , maxr ) ; minl = min( minl , t ) ; &#125; ans = maxr - minl + 1 ; while( mm &lt; m &amp;&amp; mm &lt; c ) &#123; ans = ans - func() ; mm++; &#125; cout &lt;&lt; ans &lt;&lt; endl ; return 0 ; &#125; 3crypt1 code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768 /*ID:xiekeyi1PROG:crypt1LANG:C++ */#include&lt;bits/stdc++.h&gt;using namespace std ;int a[100];set&lt;int&gt; b ;bool judge( int n )&#123; while( n != 0 ) &#123; if( !b.count( n % 10 ) ) return false ; n /= 10 ; &#125; return true ; &#125;int main()&#123; freopen("crypt1.in","r",stdin); freopen("crypt1.out","w",stdout); int n ; cin &gt;&gt; n ; for( int i = 1 ; i &lt;= n ; i++) &#123; cin &gt;&gt; a[i]; b.insert(a[i]) ; &#125; int ans = 0 ; int q = 0 , w = 0 , e = 0 ; for( int i = 1 ; i &lt;= n ; i++) &#123; for( int j = 1 ; j &lt;= n ; j++) &#123; for( int k = 1 ; k &lt;= n ; k++) &#123; for( int l = 1 ; l &lt;= n ; l++) &#123; for( int m = 1 ; m &lt;= n ; m++) &#123; q = ( a[i] * 100 + a[j] * 10 + a[k] ) * a[m] ; w = ( a[i] * 100 + a[j] * 10 + a[k] ) * a[l]; e = ( a[i] * 100 + a[j] * 10 + a[k] ) * ( a[l] * 10 + a[m] ) ; if( w &lt; 1000 &amp;&amp; q &lt; 1000 &amp;&amp; e &lt; 10000 &amp;&amp; judge(q) &amp;&amp; judge(w) &amp;&amp; judge(e) ) &#123; ans++; //cout &lt;&lt; q &lt;&lt; ' ' &lt;&lt; w &lt;&lt; ' ' &lt;&lt; e &lt;&lt; endl ; &#125; &#125; &#125; &#125; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl ; return 0 ; &#125; 4combo code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687 /*ID:xiekeyi1PROG:comboLANG:C++ */#include&lt;bits/stdc++.h&gt;using namespace std ;int n ;int john[4] , master[4];int similar( int a , int b )&#123; if( a &gt;= n - 1 &amp;&amp; b &lt;= n -1 ) return min( abs( a - b ) , abs( a - n - b ) ) ; if( b &gt;= n - 1 &amp;&amp; a &lt;= n - 1 ) return min( abs( a - b ) , abs( b - n - a ) ) ; return abs( a - b ) ; &#125;//int s( int a[] , int b )//&#123;// int minn = 99999999 ;// for( int i = 1 ; i &lt;= 3 ; i++ )// minn = min( minn , similar( b , a[i] ) ) ;//// return minn ;//&#125;bool judge( int a , int b , int c )&#123; int cnt = 0 ; if( similar( john[1] , a ) &lt;= 2 ) cnt++; if( similar( john[2] , b ) &lt;= 2 ) cnt++; if( similar( john[3] , c ) &lt;= 2 ) cnt++; if( cnt == 3 ) return true ; cnt = 0 ; if( similar( master[1] , a ) &lt;= 2 ) cnt++; if( similar( master[2] , b ) &lt;= 2 ) cnt++; if( similar( master[3] , c ) &lt;= 2 ) cnt++; if( cnt == 3 ) return true ; return false ; &#125;int main()&#123; freopen("combo.in","r",stdin); freopen("combo.out","w",stdout); cin &gt;&gt; n ; cin &gt;&gt; john[1] &gt;&gt; john[2] &gt;&gt; john[3] &gt;&gt; master[1] &gt;&gt; master[2] &gt;&gt; master[3] ; int ans = 0 ; for( int i = 1 ; i &lt;= n ; i++ ) &#123; for( int j = 1 ; j &lt;= n ; j++) &#123; for( int k = 1 ; k &lt;= n ; k++) &#123; if( judge( i , j , k ) ) &#123; ans++ ; // cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; j &lt;&lt; ' ' &lt;&lt; k &lt;&lt; endl ; &#125; &#125; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl ; return 0 ; &#125; 5wormhole code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899 /*ID:xiekeyi1PROG:wormholeLANG:C++ */#include&lt;bits/stdc++.h&gt;using namespace std ;int n ;int ans = 0 ;int b[15] ;struct node&#123; int x , y ;&#125;a[15];bool cmp( struct node a , struct node b )&#123; if( a.y &lt; b.y ) return 1 ; else if( a.y == b.y) return a.x &lt; b.x ; else return false ;&#125;bool doit( int num , int x , int begin , int into )&#123; if( num != 1 &amp;&amp; begin == x &amp;&amp; into == 0 ) return true ; else if( into == 0 ) &#123; if( a[x].y == a[x+1].y ) &#123; return doit( num+1,x+1,begin,1 ); &#125; else return false ; &#125; else &#123; return doit( num+1, b[x] , begin , 0 ) ; &#125;&#125;bool judge()&#123; for( int i = 1 ; i &lt;= n ; i++) if( doit( 1 , i , i , 0 ) == 1 ) return true ; return false ; &#125;void mpair( int x )&#123; if ( x == n + 1 ) &#123; if( judge() == 1) ans++; return ; &#125; else if( b[x] == 0 ) &#123; for( int i = x + 1 ; i &lt;= n ; i++) &#123; if( b[i] == 0 ) &#123; b[x] = i ; b[i] = x ; mpair(x+1); b[x] = 0 ; b[i] = 0 ; &#125; &#125; &#125; else mpair(x+1);&#125;int main()&#123; freopen("wormhole.in","r",stdin); freopen("wormhole.out","w",stdout); cin &gt;&gt; n ; for( int i = 1 ; i &lt;= n ; i++) cin &gt;&gt; a[i].x &gt;&gt; a[i].y ; sort(a+1,a+1+n,cmp) ; mpair(1); cout &lt;&lt; ans &lt;&lt; endl ; return 0 ; &#125; 6skidegisn code1234567891011121314151617181920212223242526272829303132333435363738394041 /*ID:xiekeyi1PROG: skidesign LANG:C++*/#include&lt;bits/stdc++.h&gt;using namespace std ;const int maxn = 1010 ;int a[maxn];int main()&#123; freopen("skidesign.in","r",stdin); freopen("skidesign.out","w",stdout); int n ; int ans = 0x7FFFFFFF; cin &gt;&gt; n ; for( int i = 1 ; i &lt;= n ; i++) cin &gt;&gt; a[i] ; sort( a+1 , a+1+n ) ; for( int i = a[1] ; i &lt;= a[n] ; i++) &#123; int temp = 0 ; for( int j = 1 ; j &lt;= n ; j++) &#123; if( a[j] &lt; i ) temp+= static_cast&lt;int&gt; ( pow( abs( i - a[j] ) , 2 ) ) ; if( a[j] &gt; i + 17 ) temp += static_cast&lt;int&gt; ( pow( abs( i + 17 - a[j] ) , 2 ) ) ; &#125; ans = min( ans , temp ) ; &#125; cout &lt;&lt; ans &lt;&lt; endl ; return 0 ; &#125; ** 错误代码 ** code123456789101112131415161718192021222324252627282930313233343536373839404142434445 /*ID:xiekeyi1PROG: skidesign LANG:C++*/// ??óD????è? 2 1 100 ?a?ùμ?ê?è??êìa #include&lt;bits/stdc++.h&gt;using namespace std ;const int maxn = 1010 ;int a[maxn];int main()&#123; freopen("skidesign.in","r",stdin); freopen("skidesign.out","w",stdout); int n ; int ans = 0xFFFFFFF; cin &gt;&gt; n ; for( int i = 1 ; i &lt;= n ; i++) cin &gt;&gt; a[i] ; sort( a+1 , a+1+n ) ; for( int i = 1 ; i &lt;= n ; i++) &#123; for( int j = n ; j &gt;= i ; j-- ) &#123; if( a[j] - a[i] &lt;= 17 ) &#123; int temp = 0 ; for( int k = 1 ; k &lt; i ; k++) temp += static_cast&lt;int&gt; ( pow( abs( a[k] - a[i] ) , 2 ) ) ; for( int k = n ; k &gt; j ; k-- ) temp+= static_cast&lt;int&gt; ( pow( abs( a[k] - a[j] ) , 2 ) ) ; ans = min( temp , ans) ; &#125; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl ; return 0 ; &#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>USACO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO-Chapter1-Section1.2]]></title>
    <url>%2F8ea2e2d4.html</url>
    <content type="text"><![CDATA[1milk2 code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657 /*ID:xiekeyi1PROG:milk2LANG:C++ */#include&lt;bits/stdc++.h&gt;using namespace std ; const int MAXN = 5010;struct point &#123; int begin , end ;&#125; a[MAXN] ;bool cmp( struct point a , struct point b )&#123; if( a.begin &lt; b.begin) return true ; else if( a.begin == b.begin &amp;&amp; a.end &lt; b.end ) return true ; else return false ; &#125;int main()&#123; freopen("milk2.in","r",stdin); freopen("milk2.out","w",stdout); int n ; cin &gt;&gt; n ; for( int i = 1 ; i &lt;= n ; i++) cin &gt;&gt; a[i].begin &gt;&gt; a[i].end ; sort(a+1,a+1+n,cmp) ; int ans1= 0 , ans2 = 0 ; int tem_begin = a[1].begin , tem_end= a[1].end; ans1 = max( tem_end - tem_begin , ans1 ); for( int i = 2 ; i &lt;=n ; i++) &#123; if( a[i].begin &lt;= tem_end) &#123; tem_end = max( tem_end , a[i].end) ; &#125; else &#123; ans1 = max(ans1 , tem_end - tem_begin ) ; ans2 =max( ans2 , a[i].begin - tem_end) ; tem_begin = a[i].begin; tem_end = a[i].end ; &#125; &#125; cout &lt;&lt; ans1 &lt;&lt; ' ' &lt;&lt; ans2 &lt;&lt; endl ; return 0 ; &#125; 2transform code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166 /*ID:xiekeyi1PROG:transformLANG:C++*/#include&lt;bits/stdc++.h&gt;using namespace std ;//#define DEBUG const int maxn = 15 ;char a[maxn][maxn] , b[maxn][maxn] , c[maxn][maxn];//template&lt;typename T&gt;//void swap( T &amp;a , T &amp;b )//&#123;// T c ;// c = a ;// a = b ;// b = a ; // return ; //&#125;bool judge( char a[maxn][maxn] , char b[maxn][maxn] , int &amp;n )&#123; for( int i = 1 ; i &lt;= n ; i++) for( int j = 1 ; j &lt;= n ; j++) if( a[i][j] != b[i][j] ) return false ; return true ;&#125;int rolate( int &amp;n )&#123; for( int i = 1 ; i &lt;= n ; i++) &#123; for( int j = 1 ; j &lt;= n ; j++) &#123; c[j][n-i+1] = a[i][j] ; &#125; &#125; if( judge( c , b , n ) ) return 1 ; for( int i = 1 ; i &lt;= n ; i++) &#123; for( int j = 1 ; j &lt;= n ; j++) &#123; c[n-i+1][n-j+1] = a[i][j] ; &#125; &#125; if( judge ( c , b , n ) ) return 2; for( int i = 1 ; i &lt;= n ; i++) &#123; for( int j = 1 ; j &lt;= n ; j++) &#123; c[n-j+1][i] = a[i][j] ; &#125; &#125; if( judge ( c , b , n ) ) return 3 ; for( int i = 1 ; i &lt;= n ; i++) for( int j = 1 ; j &lt;= n ; j++) c[i][j] = a[i][j] ; for( int i = 1 ; i &lt;= n ; i++) &#123; for( int j = 1 ; j &lt;= n / 2 ; j++) &#123; swap( c[i][j] , c[i][n-j+1]) ; &#125; &#125; if( judge( c , b , n ) ) return 4 ; // for( int i = 1 ; i &lt;= n ; i++) // for( int j = 1 ; j &lt;=n ; j++) // c[i][j] = a[i][j] ;#ifdef DEBUG for( int i = 1 ; i &lt;= n ; i++) &#123; for( int j = 1 ; j &lt;= n ; j++) cout &lt;&lt; c[i][j]; cout &lt;&lt; endl ; &#125; cout &lt;&lt; endl &lt;&lt; endl ; #endif char d[maxn][maxn]; for( int i = 1 ; i &lt;= n ; i++) for( int j = 1 ; j &lt;= n ; j++) d[j][n-i+1] = c[i][j] ;#ifdef DEBUG for( int i = 1 ; i &lt;= n ; i++) &#123; for( int j = 1 ; j &lt;= n ; j++) cout &lt;&lt; d[i][j] ; cout &lt;&lt; endl ; &#125; cout &lt;&lt; endl &lt;&lt; endl ;#endif if( judge( d , b , n ) ) return 5 ; for( int i = 1 ; i &lt;= n ; i++) for( int j = 1 ; j &lt;= n ; j++) d[n-i+1][n-j+1] = c[i][j] ;#ifdef DEBUG for( int i = 1 ; i &lt;= n ; i++) &#123; for( int j = 1 ; j &lt;= n ; j++) cout &lt;&lt; d[i][j] ; cout &lt;&lt; endl ; &#125; cout &lt;&lt; endl &lt;&lt; endl ;#endif if( judge( d , b , n ) ) return 5 ; for( int i = 1 ; i &lt;= n ; i++) for( int j = 1 ; j &lt;= n ; j++) d[n-j+1][i] = a[i][j] ;#ifdef DEBUG for( int i = 1 ; i &lt;= n ; i++) &#123; for( int j = 1 ; j &lt;= n ; j++) cout &lt;&lt; d[i][j] ; cout &lt;&lt; endl ; &#125; cout &lt;&lt; endl &lt;&lt; endl ;#endif if( judge( d , b , n ) ) return 5 ; if( judge( a , b , n ) ) return 6 ; return 7 ; &#125;int main()&#123; freopen("transform.in","r",stdin); freopen("transform.out","w",stdout) ; int n ; cin &gt;&gt; n ; char ch ; for( int i = 1 ; i &lt;= n ; i++) for( int j = 1 ; j &lt;=n ; j++) &#123; cin &gt;&gt; ch ; a[i][j] = ch ; &#125; for( int i = 1 ; i &lt;= n ; i++ ) for( int j = 1 ; j &lt;= n ; j++) &#123; cin &gt;&gt; ch ; b[i][j] = ch ; &#125; cout &lt;&lt; rolate(n) &lt;&lt; endl ; return 0 ; &#125; 3namenum code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 /*ID:xiekeyiPROG:namenumLANG:C++ */#include&lt;bits/stdc++.h&gt;#include&lt;iostream&gt;using namespace std ;int f( char ch )&#123; if( ch &lt; 'Q' ) return ( ch - 'A' + 1 + 2 ) / 3 + 1 ; else return ( ch - 'A' + 1 + 1 ) / 3 + 1 ;&#125;long long func( string &amp;s) &#123; long long ans = 0 ; for( int i = 0 ; i &lt; s.size() ; i++) ans = ans*10 + f(s[i]) ; return ans ;&#125;int main()&#123; ifstream fin ; freopen("namenum.out","w",stdout); fin.open("namenum.in",fstream::in); long long n ; fin &gt;&gt; n ; string s ; fin.close() ; fin.open("dict.txt",fstream::in); bool flag = false ; while( fin &gt;&gt; s ) if( func(s) == n ) &#123; cout &lt;&lt; s &lt;&lt; endl ; flag = true ; &#125; if( !flag ) cout &lt;&lt; "NONE" &lt;&lt; endl ; fin.close() ; return 0 ; &#125; 4palsquare code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273 /*ID:xiekeyi1PROG:palsquareLANG:C++ */#include&lt;bits/stdc++.h&gt;using namespace std ;const int maxn = 1000;int a[maxn] , b[maxn] ;void translate( int n , int B , int flag , int &amp;d )&#123; int digit = 0 ; while( n != 0 ) &#123; if( flag == 1 ) a[digit++] = n % B ; else b[digit++] = n % B ; n /= B ; &#125; d = digit ; return ; &#125;bool judge( int b[] , int d )&#123; for( int i = 0 ; i &lt;= d / 2 ; i++) if( b[i] != b[d-i-1] ) return false ; return true ;&#125;ostream&amp; p( int b[] , int d ) &#123; for( int i = d - 1 ; i &gt;= 0 ; i--) &#123; if( b[i] &lt; 10 ) cout &lt;&lt; b[i] ; else cout &lt;&lt; static_cast&lt;char&gt; ( b[i] - 10 + 'A' ) ; &#125; return cout ; &#125;int main()&#123; freopen("palsquare.in","r",stdin); freopen("palsquare.out","w",stdout); int B ; cin &gt;&gt; B ; for( int i = 1 ; i &lt;= 300 ; i++) &#123; int d1 = 0 , d2 = 0 ; int t = i * i ; translate( t , B , 2 , d2 ) ; if( judge( b , d2 ) ) &#123; translate( i , B , 1 , d1 ) ; p(a,d1) &lt;&lt; ' ' ; p(b,d2) &lt;&lt; endl ; &#125; &#125; return 0 ; &#125; 5dualpal code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960 /*ID:xiekeyi1PROG:dualpalLANG:C++ */#include&lt;bits/stdc++.h&gt;using namespace std ;const int maxn = 100 ;int a[maxn] ;void f( int a[] , int n , int b , int &amp;d )&#123; int digit = 0 ; while( n != 0 ) &#123; a[digit++] = n % b ; n /= b ; &#125; d = digit ; return ; &#125;bool judge( int a[] , int d )&#123; for( int i = 0 ; i &lt;= d/2 ; i++) if( a[i] != a[ d-i-1] ) return false ; return true ;&#125;int main()&#123; freopen("dualpal.in","r",stdin); freopen("dualpal.out","w",stdout); int n , s ; cin &gt;&gt; n &gt;&gt; s ; int i = 0 ; int temp = s+1 ; for( i = 0 ; i &lt; n ; ) &#123; int flag = 0 ; for( int j = 2 ; j &lt;= 10 ; j++) &#123; int d = 0 ; f(a,temp,j,d); if( judge( a , d ) ) flag++; if( flag &gt;= 2 ) &#123; cout &lt;&lt; temp &lt;&lt; endl ; i++; break ; &#125; &#125; temp++; &#125; return 0 ; &#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>USACO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO Chapter1 Section1.1]]></title>
    <url>%2F6a6ef8c4.html</url>
    <content type="text"><![CDATA[0test ```c++ code12345678910111213141516171819 /*ID:xiekeyi1PROG:testLANG:C++*/#include&lt;bits/stdc++.h&gt;using namespace std ;int main()&#123; freopen("test.in","r",stdin); freopen("test.out","w",stdout) ; long long a , b ; cin &gt;&gt; a &gt;&gt; b ; cout &lt;&lt; a + b &lt;&lt; endl ; return 0 ; &#125; ### 1ride code12345678910111213141516171819202122232425262728 /*ID:xiekeyi1PROG:rideLANG:C++*/#include&lt;bits/stdc++.h&gt;using namespace std ;int main()&#123; freopen("ride.in","r",stdin); freopen("ride.out","w",stdout) ; string s1 , s2 ; cin &gt;&gt; s1 &gt;&gt; s2 ; int ans1 = 1 , ans2 = 1 ; for( int i = 0 ; i &lt; s1.size() ; i++) ans1 *= (s1[i] - 'A' + 1 ) % 47 ; for( int i = 0 ; i &lt; s2.size() ; i++) ans2 *= (s2[i] - 'A' + 1 ) % 47 ; ans1 %= 47 , ans2 %= 47 ; if( ans1 == ans2 ) cout &lt;&lt; "GO" &lt;&lt; endl ; else cout &lt;&lt; "STAY" &lt;&lt; endl ; return 0 ; &#125; 2gift code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455 /*ID:xiekeyi1PROG:gift1LANG:C++*/#include&lt;bits/stdc++.h&gt;using namespace std ;map&lt;string,int&gt; na;struct &#123; string name ; int account = 0 ; int begiven = 0 ; &#125;a[1000];int main()&#123; freopen("gift1.in","r",stdin); freopen("gift1.out","w",stdout); int n ; cin &gt;&gt; n; for( int i = 1 ; i &lt;= n ; i++) &#123; cin &gt;&gt; a[i].name ; na[ a[i].name] = i ; &#125; string tempname ; int tempmoney , ng ; while( cin &gt;&gt; tempname &gt;&gt; tempmoney &gt;&gt; ng ) &#123; int tem = 0 ; a[ na[tempname] ].account -= tempmoney ; if( ng != 0 ) &#123; tem = tempmoney / ng ; a[ na[tempname] ].account = a[ na[tempname] ].account - ( a[ na[tempname] ].account + tem * ng ) ; &#125; for( int i = 1 ; i &lt;= ng ; i++) &#123; string t ; cin &gt;&gt; t ; a[ na[t] ] . begiven += tem ; &#125; &#125; for( int i = 1 ; i &lt;= n ; i++) &#123; cout &lt;&lt; a[i].name &lt;&lt; ' ' &lt;&lt; a[i].account + a[i].begiven &lt;&lt; endl ; &#125; return 0 ;&#125; code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586 ### 3friday```c++/*ID:xiekeyi1PROG:fridayLANG:C++*/#include&lt;bits/stdc++.h&gt;using namespace std ;int a[10] = &#123;0&#125; ;bool isleapyear( int n )&#123; if( n % 4 == 0 &amp;&amp; n % 100 != 0 ) return true ; else if( n % 400 == 0 ) return true ; else return false ;&#125;int days_month( int y , int m )&#123; switch(m)&#123; case 1 : case 3 : case 5 : case 7 : case 8 : case 10: case 12: return 31 ; case 4 : case 6 : case 9 : case 11 : return 30 ; case 2: if( isleapyear(y) ) return 29 ; else return 28 ; &#125;&#125;int days( int y , int m , int d )&#123; int ans = 0 ; for( int i = 1900 ; i &lt; y ; i++) &#123; if( isleapyear( i ) ) ans+=366; else ans+=365; &#125; for( int i = 1 ; i &lt; m ; i++) &#123; ans+= days_month( y , i ) ; &#125; ans += d ; return ans - 1 ; &#125; int main()&#123; freopen("friday.in" , "r" , stdin) ; freopen("friday.out" , "w" , stdout) ; int n ; cin &gt;&gt; n ; for( int i = 1900 ; i &lt; ( n + 1900 ) ; i++) &#123; for( int j = 1 ; j &lt;= 12 ; j++) a[ days(i,j,13) % 7 + 1 ]++ ; &#125; cout &lt;&lt; a[6] &lt;&lt; ' ' &lt;&lt; a[7] &lt;&lt; ' ' &lt;&lt; a[1] &lt;&lt; ' ' &lt;&lt; a[2] &lt;&lt; ' ' &lt;&lt; a[3] &lt;&lt; ' ' &lt;&lt; a[4] &lt;&lt; ' ' &lt;&lt; a[5] &lt;&lt; endl ; return 0 ; &#125; 4beads code123456789101112131415161718192021222324252627282930313233343536 /*ID:xiekeyi1PROG:beadsLANG:C++*/#include&lt;bits/stdc++.h&gt;using namespace std ; int main()&#123; freopen("beads.in","r",stdin); freopen("beads.out","w",stdout); int n ; string s ; cin &gt;&gt; n &gt;&gt; s ; s+=s; int a = 0 , b = 0 , w = 0 , c = 0 , ans = 0 ; for( int i = 0 ; i &lt; n*2 ; i++) &#123; if( s[i] == 'w' ) b++,w++; else if( s[i] == c ) b++,w=0; else &#123; ans = max( a+b,ans) ; a = b - w ; b = w + 1 ; w = 0 ; c = s[i] ; &#125; &#125; ans = max( a+b , ans ) ; cout &lt;&lt; min( ans , n ) &lt;&lt; endl ; return 0 ; &#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>USACO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[遇到的不错的思维水题]]></title>
    <url>%2F4888449e.html</url>
    <content type="text"><![CDATA[本文持续更新。 题目 矩阵翻转问题 给定一个01矩阵n*m ， \(n , m \leq 1000\) 。 两人轮流操作： 每次选择一个数值为1的点： 使得每次选择的点(包含)到右下角的矩阵01状态翻转。 无法操作则输。 问先手必胜还是后手必胜？ 题目来源: 2017Summertraining V8 讲课 博弈论 树翻转问题 上一道题进阶版：hdu5963(2016 CCPC 合肥) 一棵树，每个边有一个边权1,0。每次选一个边权为1的边， 将从这个边开始到根的路径的所有边的边权翻转。 不能操作则输。 问先手胜还是后手胜？ K倍动态减法游戏 两个人轮流取石子，第一次取可以取任意个(0除外)，但是不能取完，以后每次都只能取不超过上一次取的k倍(0除外)。 问先手必胜，还是后手必胜？ 当k = 2时 hdu2516 当\(1 \leq k \leq 1e5\) hdu2580 毒药问题 1000个瓶子中有一瓶毒药（编号000 ~ 999 ），一只老鼠吃到毒药一周后会死，瓶子里有无穷多的药水，老鼠可以吃任意瓶药水。 1. 如果只有10只老鼠，如何在一周内检测出老鼠所吃的毒药的编号是由哪几位数字组成？（如毒药为 413号的话，答案是1 3 4 、 3 1 4 、 4 1 3 等都对） 2. 如果只有10只老鼠，如何在一周内检测出所吃的毒药是哪一瓶？ 3. 如果要在两周内检测出哪一瓶是毒药，最少需要几只老鼠？ Codeforces Taxes 题目链接：Codeforces Round #382 (Div. 2)-735D TAXES 题意：年收入是N，那么需要缴税额是N除自身外的最大因子。为了偷税可以把N拆成K个数，但是拆成的数不能为1，因为这样会被税务局发现。找出最小税额。 好像是CCPC 2017 哈尔滨题 输入一个n，已知该数列是由 1 - n 共n个数组成的。 要求构造一个数列，数列满足 \[a\_{n} \\bmod | a\_{n} - a\_{n-2} | =0\] 给出任意一个满足要求的数列。 ----- 解答 矩阵反转问题 我们观察到无论如何进行游戏，每次必将使局面减少1个1(换句话说，将1个1恒久地变为0了，不可能再变回来了) 因此局面是朝着右下角不断缩小的。 最后必然缩小到最后一个格。 那么，如果右下角一开始是0，先手无论如何操作，都会将右下角变成1，后手只要将右下角一个变成0。那么这样操作下去，给先手的人一定是一个右下角是0的局面。所以先手必输。 反之，先手必胜。 (这道题很适合讲完博弈论的必胜必败态后出一下2333) 树翻转问题 考虑假如只有一条链，那么先手如果将第一个边的1变成0，后手无论怎么操作，都只能把这个1变回去，或者不可操作输了。 因此，如果第一个边是1，那么先手必胜。 如果是树的话，只需要知道和这棵树的根节点连接的边权为1的边的个数是奇数还是偶数就可以了。 (这里已经有点SG函数、异或之类的意思了) k倍动态减法游戏。 我目前对这里的理解还有一些问题，未完待续，仅供参考。 1. 当k等于1时，我们将石子数拆成二进制数，会发现先手如果每次只取1个的话，会把最后一位由1变成0，或者由0变成1。因此，只要最后一位是1的话，先手必胜。否则后手必胜。(因为局面必定会缩小到最后只有一位) 2. 1. 当k等于2时，同样将石子拆成二进制数，如果第一次取了1个，会发现第二次取只能取1个（即将最后一位0 1变换）或者取2个（即将倒数第二位0 1变换） ， 然后由任何一个正整数都可以由两个斐波那契数相加得到，求解.(我对这里不太理解，未完待续) 用必胜态必败态DP转移得到。不过这里细节比较多，比如dp[n][n]在第一手的时候因为不能拿完，但是在第二手又可以拿完，这里需要注意一下变化。 这道题V8当时主要讲的是如何把\(O(n^{3})\) (朴素)* 优化到\(O(n^{2})\) (减少维数) 再优化到\(O(n)\) (单调栈) 。 第一次听讲的时候惊艳了。 当到k倍的问题的时候，请参考NOI2009冬令营论文——《从“k倍动态减法游戏”出发探究一类组合游戏问题》 毒药问题 这其实是我一开始错误的想法改编后成的问题。 对于这样的话，只要让所有数字带0的药水，给第0个老鼠吃，所有数字带1的药水给第1个老鼠吃即可由哪几只老鼠死亡来判断所含数字。 将1000瓶药水的编号二进制拆分，正好是10位以内，即可把10只老鼠分别对应一个二进制位。由此准确确定毒药的二进制位，转成十进制即可。 将1000瓶药水三进制拆分，这样第一天可确定毒药每一位数字是否为0，第二天可确定是否为1，然后排除法确定哪些是2。 1000转成三进制是7位，所以需要7只老鼠。 Codeforces Taxes 哥德巴赫猜想。 需要注意的是，人们熟知的哥德巴赫猜想，是\(1+1=2\)，但是那是建立在1被作为素数的情况下。 因此，现代的哥德巴赫猜想有些不同。 &gt;原初猜想的现代陈述为：任一大于5的整数都可写成三个质数之和。欧拉在回信中也提出另一等价版本，即任一大于2的偶数都可写成两个质数之和。 &gt;今日常见的猜想陈述为欧拉的版本，即任一大于2的偶数都可写成两个素数之和，亦称为“强哥德巴赫猜想”或“关于偶数的哥德巴赫猜想”。 &gt;从关于偶数的哥德巴赫猜想，可推出：任一大于7的奇数都可写成三个质数之和的猜想。后者称为“弱哥德巴赫猜想”或“关于奇数的哥德巴赫猜想”。若关于偶数的哥德巴赫猜想是对的，则关于奇数的哥德巴赫猜想也会是对的。弱哥德巴赫猜想尚未完全解决，但1937年时前苏联数学家维诺格拉多夫已经证明充分大的奇质数都能写成三个质数的和，也称为“哥德巴赫-维诺格拉朵夫定理”或“三素数定理”。 因此，我们只需要对 大于7的奇数，判断他是否是由一个质数+2这个质数得来的，如果是，则答案为2，否则为3. 对大于2的偶数，答案为2. 好像是CCPC 2017 哈尔滨的题 本来我想的是任意偶数差两个都可以满足要求，但是奇数和质数就不太满足，然后考虑了一下，质数要满足，必定是$ a_{n} 与 a_{n-2} $ 相差1。因为任何数 mod 1 都是0 。 所以考虑构造数字的方法就是 类似于蛇形填数，第 1、3、5、7、.... n-1 依次填1234567，然后n-2、6、4、...2 以此填写8 9 10 11... 即可]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>水题</tag>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 442 Div.2 877B Nikita and String]]></title>
    <url>%2Ff11372ef.html</url>
    <content type="text"><![CDATA[题目链接： Codeforces 442 Div.2 B 题意: 给出一个只由小写字母ab组成的串，删除任意字符后，将剩下的拼起来（不改变顺序） ，问剩下的串满足由:\(s\_{1}\)、\(s\_{2}\)、\(s\_{3}\) 组成，其中\(s\_{1}\)为全部由小写字母a组成的或者是空串，\(s\_{2}\)为全部由小写字母b组成的或者是空串, \(s\_{3}\)为全部由小写字母a组成的或者是空串。 求满足这样条件的串，最长的长度是多少？( |s| &lt; 5000 ) 一开始比赛的时候，我考虑的是维护一个前缀和，把a看为正数，把b看为负数。 然后前缀和维护的话大概就是这么一个样子。 12345678910111213141516for( int j = i ; j &lt; length + 1 ; j++) &#123; if( s[i] == s[j] ) cnt++; else &#123; i = j - 1 ; if( s[i] == 'a' ) a.push_back( cnt ) ; else if(s[i] == 'b' ) a.push_back( -cnt ) ; cnt = 0 ; break ; &#125; &#125; &#125; 然后我想当然的认为，这道题就是求 Max{ a[i] + a[j] + a[k] ) ( i &lt; j &lt; ) } 结果WA了整整一个比赛。 主要原因是没有考虑到，有可能拼起来更长的情况。 比如: aaaabaaaaa 这样，可以把b删去后把a全部看成一起，这个做法没有考虑到这个情况。 思维太僵化了，其实有很简单的做法。结果经常自己陷入一开始的思维定式跳不出来。 做法1 因为数据量只由5000，所以其实可以直接\(n^{2}\)枚举分界点，然后前缀和之类的统计一下就可以了。 这道题细节不算少，分界点如何枚举，如何处理空串这类，我处理了不短的时间。 时间复杂度: \(O(n^{2})\) （前缀和） 做法2 我们可以用dp[n][3]这样的数组表示，其中dp[0]表示只由a构成的串，dp[1]表示由a、b构成的串，dp[2]表示由a、b、a构成的串。 那么，当我s[i] == 'a' 时， 123dp[i][0] = dp[i-1][0] + 1;dp[i][1] = dp[i-1][1] ;dp[i][2] = max( dp[i-1][1] + 1 , dp[i-1][2] + 1 ) ; 当 s[i] == 'b' 时 123dp[i][0] = dp[i-1][0] ;dp[i][1] = max( dp[i-1][1] + 1 , dp[i-1][0] + 1 ) ;dp[i][2] = dp[i-1][2] ; 转移应该是显而易见的。 对于只由a构成的串，每次都是遇到a的时候加一。 由ab构成的串，可以由 只由a的串转移而来，或者由ab串转移而来。 aba构成的串，可以由ab转移而来，也可以由aba转移而来。 时间复杂度: \(O(n)\) 做法3 我们可以把a看做是1，b看做是2，b后面的a看做是3. 那么题目就变成了求最长上升子序列（LIS）问题。 求LIS的做法有 \(O(n^{2})\)和\(O(nlogn)\)的做法。 这个写法本质上其实和做法2很像，因为只由3个数字的LIS，所以可以用做法2去实现。 因为这个方法细节较多，b前后的问题比较难处理，而且有了更容易理解的做法2. 因此没有写这个做法的代码。 做法1代码： code12345678910111213141516171819202122232425262728293031323334353637383940414243 // enumerate every interval .#include&lt;bits/stdc++.h&gt;using namespace std ;const int maxn = 5050 ;int a[maxn] , b[maxn];char s[maxn];int main()&#123; scanf("%s" , s + 1 ) ; int length = strlen(s+1) ; for( int i = 1 ; i &lt;= length ; i++) &#123; if( s[i] == 'a' ) a[i] = a[i-1] + 1 ; else a[i] = a[i-1]; if( s[i] == 'b' ) b[i] = b[i-1] + 1 ; else b[i] = b[i-1] ; &#125; int ans = 0 ; for( int i = 0 ; i &lt;= length + 1 ; i++) &#123; for( int j = i ; j &lt;= length + 1 ; j++) &#123; ans = max( ans , a[i] + b[j] - b[i] + ( ( j &gt;= length + 1 ) ? 0 : ( a[length] - a[j] ) ) ) ; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl ; return 0;&#125; 做法2代码： code123456789101112131415161718192021222324252627282930313233 #include&lt;bits/stdc++.h&gt;using namespace std ;const int maxn = 5050 ; int dp[maxn][3];int main()&#123; string s ; cin &gt;&gt; s ; for( int i = 0 ; i &lt; s.size() ; i++) &#123; if( s[i] == 'a' ) &#123; dp[i][0] = dp[i-1][0] + 1; dp[i][1] = dp[i-1][1] ; dp[i][2] = max( dp[i-1][1] + 1 , dp[i-1][2] + 1 ) ; &#125; else if( s[i] == 'b' ) &#123; dp[i][0] = dp[i-1][0] ; dp[i][1] = max( dp[i-1][1] + 1 , dp[i-1][0] + 1 ) ; dp[i][2] = dp[i-1][2] ; &#125; &#125; cout &lt;&lt; max( &#123; dp[s.size()-1][0] , dp[s.size()-1][1] , dp[s.size()-1][2] &#125; ) &lt;&lt; endl ; return 0 ; &#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>codeforces</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用HEXO+github.io搭建博客]]></title>
    <url>%2F461fdda0.html</url>
    <content type="text"><![CDATA[发现很多人都自建博客，比较可控也比较干净清爽，于是准备自己也搭建一个博客。 一方面熟悉一下具体流程，一方面是因为自己有一个空闲的腾讯云服务器。 正好可以把它利用起来。 优点: * 可自己随意发表文章，没什么广告，清爽。 * 可自己折腾前端、研究建站。 * 很多东西存于本地，方便移植、备份、管理。 * 可以本地预览 缺点: * 需要自己域名、服务器。比较花钱。( github.io ) 有免费空间。 * 搭建比较麻烦。(本来我还想实习运维，结果自己照着框架、教程，还搭了一个周末) 事先了解了一下，常用的博客框架有jekyll(github官方推荐)、HEXO、Wordpress 。 wordpress收费，比较贵。优点是很容易搭建、比较友好。 不过因为自己本来就是为了折腾和学习，感觉优点反而成了缺点。所以不考虑了。 一开始比较想搭建jekyll，毕竟github官方推荐，和github.io配合最好。但是看HEXO扩展、支持又比较多。所以在这两个里面摇摆不定。 后来研究了一下发现jekyll是基于ruby的。 因为我认为我在Windows下写博客比较多，在Linux下主要只是写代码。 e 了解到ruby环境在Windows下比较难以搭建，比较麻烦。而HEXO是基于nodejs的，nodejs在Windows环境下比较友好。 考虑到这一点后，果断选择了HEXO。 本机环境搭建 安装Git环境 随便在git官网下载安装就好了。 注意一下它可以自动这是Path ，并且可以将Windows的回车换行转换成Linux的风格换行，这两个地方选择一下，在Windows下会变得比较方面。 在cmd(powershell)中输入 git --version , 显示版本号后即安装成功。 安装Node.js环境 在Node.js 找到适合自己系统的环境安装，一路下一步即可。 在cmd(powershell)中输入npm --version ， 显示版本号后即安装成功。 安装HEXO 命令行下输入 npm install hexo-cli -g , npm install hexo --save . npm是Node.js的包管理工具，可以理解为npm是用来安装Node.js程序的 hexo-cli是 hexo - Command Line Interface ，Hexo的命令行模式。 -g是指 -global， 全局安装。 1. 表示将安装包放在 /usr/local 或 nodejs的安装目录。 2. 可以直接在命令行中使用。 --save 是指自动处理一下依赖关系，将依赖关系的版本号和模块添加到 package.json 里。 安装完成后，cmd(powersheel)中输入 hexo --version ， 显示版本号后即安装成功。 本地使用HEXO 新建一个自己博客的文件夹。 用命令行进入该文件夹，输入 hexo init ，初始化本文件夹为hexo目录。 然后输入 npm install ，用npm自动安装所需要的组件。 接下来输入 hexo g ，即可生成博客。 输入 hexo s ， 即可在 http://localhost:4000/ 中预览自己的博客。 现在基本就可以使用HEXO了。 HEXO常用命令 - hexo new &quot;title&quot; 即可在source/_post/ 文件夹里找到，在里面写文章即可。 - hexo new page &quot;newpage&quot; 会在source/ 文件夹内创建一个新文件夹，对应一个新的页面（需要和_config.yml)相关联。 - hexo g 生成本地页面 - hexo d 将本地页面发布到网站上 - hexo d -g ， 等价于 hexo g ; hexo d - hexo s 开启本地服务器 ，可在本地预览。 HEXO的主题 可在github等很多地方找到。 使用方法各不相同，主要改好_config.yml和/themes/对应主题/_config.yml 即可 少部分主题怎么调都调不对，可考虑是主题问题。一开始我使用huno ，tags怎么调都有一些问题，后来换了主题后解决 这里推荐NEXT 主题， 使用教程多，持续更新，使用方便。 配置git 设置git的user name和email，用于标识自己git的身份。 12git config --global user.name &quot;Yourname&quot;git config --global user.email &quot;Youemail@xxx.com&quot; 这样就把全局的名字设置好了。 生成密钥 运行 ssh-keygen -t rsa -C &quot;xxxxx@xxx.com&quot; -t用于制定密钥类型为rsa，-C提供一个注释. 这样就生成了一对公钥和私钥。 LINUX默认放在/home/.ssh目录下 WINDOWS默认在C:\Users\xxxx\.ssh 下 将公钥id_rsa.pub 内的内容复制放到仓库-setting-Deploy keys下 或放到个人设置-SSH and GPG keys下即可 通过自己的私钥和公钥配对来证明自己本人。 Github Pages Github提供了 xxxx.github.io 这个域名供我们使用。 我们在github里新建一个仓库，取名为 xxxxx.github.io (必须取这个名字) 然后github会自动帮我们配置好各种文件。 之后在HEXO安装包里找到_config.xml ， 写成如下这段（如果前面有#号删掉即可，#号表示注释） 1234deploy: type: git repo: https://github.com/xxxxx/xxxxxx.github.io.git branch: master 然后即可通过 HEXO D 将自己已经生成的数据发布到该域名了。 之后即可通过该域名访问你的博客了，也可自己购买域名后做CNAME解析。 备份问题 做好备份可以方便跨电脑写作或更换电脑等情况。 我是新建了一个仓库用来备份，只要 1234git init git add .git commitgit push 这样就可以了。 有的人是新建分支来备份，我因为还不太熟练git所以没有采用。 另外有部分已经有git下来的文件夹(比如我的主题) 我还不知道怎么用git push 上去。 在此提供一个思路。 将其部署在自己的云服务器上 这是我折腾最久的一点。。。 我的环境是Ubuntu 16.04 LTS 腾讯云。 需要安装git和nginx. git是用来使自己的博客文件夹能推送发布到云服务器。 nginx是用来使自己的云服务器可以变成一个HTTP服务器，被广泛使用。 Nginx (engine x) 是一个高性能的HTTP和反向代理服务器，也是一个IMAP/POP3/SMTP服务器。 安装git(ubuntu大多默认自带) apt-get install git 安装nginx apt-get install nginx 配置云服务器 在/home/.ssh文件夹下创建一个authorized_keys文件，将id_rsa.pub复制后粘贴到这个文件内，即可在自己电脑上SSH到这台服务器。 建议创建一个专用的git用户来确保安全。 不过我一开始创建用户后很多权限处理都不太对，后来用默认用户成功以后也就没有再创建用户了。 然后在本地创建一个目录作为git仓库 比如在/home下 mkdir git 创建一个git文件夹 chown -R $USER:$USER /home/git chmod -R 755 /home/git 使当前用户有权限在这个git文件夹下搞事。 cd /home/git 进入该文件夹后 git init --bare hexo.git 创建一个hexo.git文件夹作为git仓库。 在/home/git/hexo.git/hook 文件夹下有一个post-update.sample文件，重命名为post-update后，修改内容为 123456#!/bin/shcd /cd /usr/share/nginx/html/git clone /home/git/hexo.gitcp -rf hexo/* .rm -rf hexo 表示每当该目录有更新，用bash命令，进入nginx默认目录，克隆该目录，将hexo的文件都复制下来，并删除hexo文件夹。 现在即可通过该云服务器IP访问自己博客了。 修改本机HEXO下的_config.yml 参照上文github.io的deploy写法即可。 也可以像我这样同时推送多个仓库(防止github无法正常访问，也为自己云服务器到期后切换到github提供方便） 一开始试了好多写法，发现都不太对。 最后查了下发现是 12345deploy: type: git repo: github: https://github.com/xxxxxx/xxxxx.github.io.git,master tencent: ubuntu@xxx.xxx.xxx.xxx.xxx:~/git/hexo.git,master 简单来说就是 12repo: 标签名: 地址 , 分支 遇到的一些坑 /usr/share/nginx/html/是nginx默认做网页的目录，不过不同安装方式该目录似乎不同。因此需要在/etc/nginx/的nginx.conf或/sites-enabled文件夹内 ，将root 后面的目录改为 /usr/share/nginx/html/文件夹。(发现还有的改site-available)文件夹的。 有的人修改的不是post-update文件，而是/hook/下新创建了一个post-receive文件进行了一些操作。 我没有试过，不知道是否可行 有很多时候问题是权限不够，我被这个坑了很久。请把用到的相关目录都添加相应权限。权限添加修改方法上文已给出 本文目的是为了给像我一样想自己搭建博客，又不知道怎么搭建，并且遇到很多坑不知道怎么解决的人一些帮助。 本文致力于使大家看完后都可以搭建成功。 因为本文开始动笔比学习搭建博客晚了一段时间，所以有些坑踩过后，不一定还记得是什么了，因此会有一些疏漏。 在阅读本文中有什么困难和不清晰，麻烦和我联系或评论。 以便我加以完善，方便更多人可以搭建出自己的博客。]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>HEXO</tag>
        <tag>github.io</tag>
      </tags>
  </entry>
</search>
